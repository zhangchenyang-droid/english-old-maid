/* UI layer (DOM). No ES modules so file:// works. */

// Basic polyfills / diagnostics for mobile browsers
if (!window.CSS) window.CSS = {};
if (typeof window.CSS.escape !== "function") {
  window.CSS.escape = function (value) {
    // Minimal escape for use in attribute selectors.
    return String(value).replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
  };
}

function showFatalError(err) {
  try {
    const msg = (err && (err.stack || err.message)) ? String(err.stack || err.message) : String(err);
    const box = document.createElement("div");
    box.style.position = "fixed";
    box.style.inset = "12px";
    box.style.zIndex = "20000";
    box.style.background = "rgba(0,0,0,0.78)";
    box.style.color = "white";
    box.style.padding = "12px";
    box.style.borderRadius = "14px";
    box.style.overflow = "auto";
    box.style.fontSize = "12px";
    box.style.whiteSpace = "pre-wrap";
    box.innerText = "é¡µé¢å‘ç”Ÿé”™è¯¯ï¼ˆè¯·æˆªå›¾å‘æˆ‘ï¼‰ï¼š\n\n" + msg;
    box.addEventListener("click", () => box.remove());
    document.body.appendChild(box);
  } catch {
    // ignore
  }
}

window.addEventListener("error", (e) => showFatalError(e.error || e.message || e), { passive: true });
window.addEventListener("unhandledrejection", (e) => showFatalError(e.reason || e), { passive: true });

function $(sel) {
  const el = document.querySelector(sel);
  if (!el) throw new Error(`Missing element: ${sel}`);
  return el;
}

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function seatEls() {
  return {
    top: { name: $("#pTopName"), count: $("#pTopCount"), hand: $("#pTopHand") },
    left: { name: $("#pLeftName"), count: $("#pLeftCount"), hand: $("#pLeftHand") },
    right: { name: $("#pRightName"), count: $("#pRightCount"), hand: $("#pRightHand") },
    bottom: { name: $("#pBottomName"), count: $("#pBottomCount"), hand: $("#pBottomHand") },
  };
}

function renderSeats(game, opts = {}) {
  const dealMode = !!opts.deal;
  const animateExpand = !!opts.animateExpand; // new option: animate card repositioning
  // Fixed mapping: 0 bottom(you), 1 right, 2 top, 3 left.
  const map = seatEls();
  const seatByIdx = {
    0: map.bottom,
    1: map.right,
    2: map.top,
    3: map.left,
  };

  for (let i = 0; i < game.players.length; i++) {
    const p = game.players[i];
    const s = seatByIdx[i];
    if (!s) continue;
    s.name.innerHTML = `${escapeHtml(p.name)} ${p.kind === "ai" ? "<span class=\"pill\">AI</span>" : "<span class=\"pill\">ç©å®¶</span>"}`;

    // ğŸ†• æ˜¾ç¤ºæ‰‹ç‰Œæ•°é‡ + A/B åˆ†å¸ƒ
    if (p.out) {
      s.count.textContent = "å·²å‡ºå®Œ";
    } else {
      let aCount = 0, bCount = 0;
      for (const c of p.hand) {
        if (!c || c.type === "joker" || !c.side) continue;
        if (c.side === "A") aCount++;
        else if (c.side === "B") bCount++;
      }
      const diff = aCount - bCount;
      const diffStr = diff > 0 ? `+${diff}` : String(diff);
      s.count.textContent = `æ‰‹ç‰Œ ${p.hand.length} (A:${aCount} B:${bCount} ${diffStr})`;
    }
  }

  // Render AI hands as backs only; human hand face-up.
  for (let i = 0; i < game.players.length; i++) {
    const p = game.players[i];
    const s = seatByIdx[i];

    // è·³è¿‡æ­£åœ¨åšè‡ªé€‚åº”è°ƒæ•´åŠ¨ç”»çš„æ‰‹ç‰ŒåŒºåŸŸ
    if (s.hand.dataset.adjusting === "true") {
      console.log(`[renderSeats] è·³è¿‡ç©å®¶${i}çš„æ‰‹ç‰Œæ¸²æŸ“ï¼Œæ­£åœ¨åšè‡ªé€‚åº”åŠ¨ç”»`);
      continue;
    }

    s.hand.innerHTML = "";
    if (i === 0) {
      // You: show face-up cards (selectable on table)
      const n = p.hand.length;
      const center = (n - 1) / 2;
      for (let idx = 0; idx < n; idx++) {
        const card = p.hand[idx];
        const div = document.createElement("div");
        div.className = `faceCard ${card.type === "joker" ? "joker imgCard" : ""} ${card.type === "img" ? "imgCard" : ""}`;
        div.dataset.cardId = card.id;
        if (dealMode) div.dataset.dealIndex = String(idx);

        // Fan layout (more readable: larger spacing between cards)
        // Cap overall width to avoid spilling off the bottom plank.
        const maxFanWidth = 920; // px (wider so text/images aren't covered)
        const spread = Math.min(62, maxFanWidth / Math.max(1, n - 1));
        const d = idx - center;
        div.style.setProperty("--x", `${d * spread}px`);
        div.style.setProperty("--rot", `${d * 0.9}deg`);
        div.style.setProperty("--y", `${Math.abs(d) * 0.8}px`);
        div.style.zIndex = String(100 + idx);

        // Add expand animation class when joker is dealt
        if (animateExpand) {
          div.style.transition = "transform 300ms cubic-bezier(0.22, 1, 0.36, 1)";
        }

        if (card.type === "joker") {
          div.dataset.corner = "";
          div.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
            </div>
          `;
        } else {
          div.dataset.corner = "";
          div.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="${escapeHtml(card.imgSrc)}" alt="card" draggable="false" /></div>
            </div>
          `;
        }
        s.hand.appendChild(div);
      }
    } else {
      // AI: show backs only. If it's your turn and this AI is upstream, render full clickable backs.
      const isHumanTurn = game.players[game.currentPlayerIndex].kind === "human";
      const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
      const isUpstreamForDraw = isHumanTurn && upstreamIdx === i && !game.turnHasDrawn;
      // Render as a pile like the reference: top zone piles sideways, left/right piles vertical.
      const showN = p.hand.length;
      const cCenter = (showN - 1) / 2;
      // Make the upstream pile clickable (tap pile -> open overlay).
      if (isUpstreamForDraw) s.hand.dataset.fromPlayerIndex = String(i);
      else s.hand.removeAttribute("data-from-player-index");

      for (let k = 0; k < showN; k++) {
        const b = document.createElement("div");
        b.className = "miniBack";
        if (dealMode) b.dataset.dealIndex = String(k);
        b.textContent = "";
        const d = k - cCenter;
        let sx = 0;
        let sy = 0;
        let srot = 0;
        if (i === 2) {
          // top player: pile spreads to the left (as in reference)
          sx = d * 12;
          sy = d * 0.3;
          srot = 0;
        } else {
          // left/right: pile spreads downward
          sx = d * 0.3;
          sy = d * 9;
          // rotate 90Â° around each card's center for side players
          srot = i === 1 || i === 3 ? 90 : 0;
        }
        b.style.setProperty("--sx", `${sx}px`);
        b.style.setProperty("--sy", `${sy}px`);
        b.style.setProperty("--srot", `${srot}deg`);
        b.style.transitionDelay = `0ms`;
        b.style.zIndex = String(10 + k);

        // Add expand animation when joker is dealt
        if (animateExpand) {
          b.style.transition = "left 300ms cubic-bezier(0.22, 1, 0.36, 1), top 300ms cubic-bezier(0.22, 1, 0.36, 1)";
        }

        s.hand.appendChild(b);
      }
    }
  }
}

function renderDiscardPile(game) {
  const pile = $("#discardPile");
  const count = $("#discardCount");
  count.textContent = `å…± ${game.discardPile.length} å¼ `;
  pile.innerHTML = "";

  // Two-pile discard: each discarded *pair* becomes (leftPileCard, rightPileCard).http://127.0.0.1:8000/english-old-maid/assets/animal_cards/4_2_A.png
  // Next discard covers the previous (stacking), instead of spreading around.
  function hash01(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h >>> 0) % 10000) / 10000;
  }
  function rotJitter(cardId, idx) {
    return (hash01(`${cardId}|${idx}`) - 0.5) * 8; // -4..4 deg
  }

  const pairs = [];
  for (let i = 0; i < game.discardPile.length; i += 2) {
    pairs.push([game.discardPile[i], game.discardPile[i + 1]]);
  }
  const leftPile = pairs.map((p) => p[0]).filter(Boolean);
  const rightPile = pairs.map((p) => p[1]).filter(Boolean);

  const MAX_DEPTH = 18; // render last N layers for perf; older still exist logically
  const leftShown = leftPile.slice(-MAX_DEPTH);
  const rightShown = rightPile.slice(-MAX_DEPTH);

  function renderCardFaceUp(c, xPercent, yPercent, z) {
    const div = document.createElement("div");
    const isJoker = c.type === "joker";
    div.className = `discardCard ${isJoker ? "joker" : "imgDiscard"}`;
    div.style.left = `${xPercent}%`;
    div.style.top = `${yPercent}%`;
    div.style.transform = `translate(-50%, -50%) rotate(${rotJitter(c.id, z)}deg)`;
    div.style.zIndex = String(z);

    if (isJoker) {
      div.dataset.corner = "";
      div.innerHTML = `
        <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
      `;
    } else {
      div.dataset.corner = "";
      div.innerHTML = `
        <div class="imgWrap"><img class="cardImg" src="${escapeHtml(c.imgSrc)}" alt="card" draggable="false" /></div>
      `;
    }

    pile.appendChild(div);
  }

  // Left pile center and right pile center inside the discard zone
  const leftX = 28;
  const rightX = 72;
  const baseY = 52;

  // Render bottom-to-top so newer cards cover older ones.
  for (let i = 0; i < leftShown.length; i++) {
    const c = leftShown[i];
    renderCardFaceUp(c, leftX, baseY, 10 + i);
  }
  for (let i = 0; i < rightShown.length; i++) {
    const c = rightShown[i];
    renderCardFaceUp(c, rightX, baseY, 100 + i);
  }
}

// no TTS in standard card mode

function flyToDiscard(fromEl) {
  const pile = $("#discardPile");
  const from = fromEl.getBoundingClientRect();
  const to = pile.getBoundingClientRect();

  // ä¸å…‹éš†ï¼Œç›´æ¥æ“ä½œåŸå§‹å¡ç‰Œå…ƒç´ 
  fromEl.classList.add("flyingCard");
  fromEl.style.position = "fixed";
  fromEl.style.left = `${from.left}px`;
  fromEl.style.top = `${from.top}px`;
  fromEl.style.width = `${from.width}px`;
  fromEl.style.height = `${from.height}px`;
  fromEl.style.margin = "0";
  fromEl.style.zIndex = "10000";
  fromEl.style.pointerEvents = "none";

  // è·å– .tableBg ä¸­å¿ƒç‚¹
  const tableBg = document.querySelector('.tableBg');
  const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
  const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
  const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

  // Determine target position based on card suffix (_A -> left, _B -> right)
  const cardId = fromEl.dataset.cardId || "";
  const isACard = cardId.includes("_A");
  const isBCard = cardId.includes("_B");

  // Calculate target position (matching renderDiscardPile positions)
  const leftX = 0.28;
  const rightX = 0.72;
  const targetXPercent = isACard ? leftX : (isBCard ? rightX : 0.5);

  const startX = from.left + from.width / 2;
  const startY = from.top + from.height / 2;
  const targetX = to.left + to.width * targetXPercent;
  const targetY = to.top + to.height * 0.52;

  // Calculate scale to match discardCard size (92px base width)
  const discardScale = getComputedStyle(document.documentElement).getPropertyValue('--scale-discard-pile') || "1";
  const targetWidth = 92 * parseFloat(discardScale);
  const scaleTarget = targetWidth / from.width;

  // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆä¸å¼ƒç‰Œå †ä¸€è‡´ï¼‰
  const currentDiscardLength = (window.game && window.game.discardPile) ? window.game.discardPile.length : 0;
  const targetZ = isACard ? (10 + Math.floor(currentDiscardLength / 2)) : (100 + Math.floor(currentDiscardLength / 2));

  function hash01(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h >>> 0) % 10000) / 10000;
  }
  const targetRotation = (hash01(`${cardId}|${targetZ}`) - 0.5) * 8;

  // å¼§çº¿æ§åˆ¶ç‚¹ï¼šå›´ç»• .tableBg ä¸­å¿ƒ
  const midX = (startX + targetX) / 2;
  const midY = (startY + targetY) / 2;
  const toCenterX = centerX - midX;
  const toCenterY = centerY - midY;

  const dist = Math.sqrt(Math.pow(targetX - startX, 2) + Math.pow(targetY - startY, 2));
  const arcHeight = Math.min(80, dist * 0.3);
  const controlX = midX + toCenterX * 0.2;
  const controlY = midY + toCenterY * 0.2 - arcHeight;

  const steps = 30;
  const keyframes = [];
  const overshootDist = dist * 0.04;

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    let easeT, overshoot;

    if (t <= 0.68) {
      const t1 = t / 0.68;
      easeT = 1 - Math.pow(1 - t1, 2.5);
      overshoot = 1.04;
    } else {
      const t2 = (t - 0.68) / 0.32;
      const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
      easeT = 1.04 - 0.04 * easeT2;
      overshoot = easeT;
    }

    // è´å¡å°”æ›²çº¿è½¨è¿¹
    const arcT = Math.min(easeT, 1.0);
    const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*targetX;
    const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*targetY;

    const dirX = targetX - startX;
    const dirY = targetY - startY;
    const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
    const normX = dirLen > 0 ? dirX / dirLen : 0;
    const normY = dirLen > 0 ? dirY / dirLen : 0;
    const overshootAmount = (overshoot - 1.0) * overshootDist;

    const x = baseX + normX * overshootAmount;
    const y = baseY + normY * overshootAmount;

    const currentScale = 1 + (scaleTarget - 1) * Math.min(easeT, 1.0);
    const currentRotation = targetRotation * Math.min(easeT, 1.0);
    const opacity = 1 - 0.05 * Math.min(easeT, 1.0);

    keyframes.push({
      left: `${x}px`,
      top: `${y}px`,
      transform: `translate(-50%, -50%) scale(${currentScale}) rotate(${currentRotation}deg)`,
      opacity: opacity,
      offset: t
    });
  }

  const anim = fromEl.animate(keyframes, {
    duration: 520,
    easing: "linear"
  });

  anim.onfinish = () => {
    fromEl.remove();
  };

  return anim; // è¿”å›åŠ¨ç”»å¯¹è±¡ï¼Œæ–¹ä¾¿å¤–éƒ¨ç›‘å¬
}

function seatHandElByPlayerIndex(idx) {
  // Fixed mapping: 0 bottom(you), 1 right, 2 top, 3 left.
  if (idx === 0) return $("#pBottomHand");
  if (idx === 1) return $("#pRightHand");
  if (idx === 2) return $("#pTopHand");
  return $("#pLeftHand");
}

function flyFromRectToRect(fromRect, toRect, cardEl, playerIndex, onComplete) {
  // Handle both old (4 params) and new (5 params) signatures
  if (typeof playerIndex === 'function') {
    onComplete = playerIndex;
    playerIndex = 0; // default to player
  }

  // ä¸å…‹éš†ï¼Œç›´æ¥æ“ä½œåŸå§‹å¡ç‰Œå…ƒç´ 
  // å˜æˆ fixed å®šä½ï¼Œè„±ç¦»æ–‡æ¡£æµ
  cardEl.style.position = "fixed";
  cardEl.style.left = `${fromRect.left}px`;
  cardEl.style.top = `${fromRect.top}px`;
  cardEl.style.width = `${fromRect.width}px`;
  cardEl.style.height = `${fromRect.height}px`;
  cardEl.style.margin = "0";
  cardEl.style.zIndex = "10000";
  cardEl.style.pointerEvents = "none";

  // è·å– .tableBg ä¸­å¿ƒç‚¹ï¼ˆä½œä¸ºå¼§çº¿çš„å‚è€ƒç‚¹ï¼‰
  const tableBg = document.querySelector('.tableBg');
  const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
  const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
  const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

  const startX = fromRect.left + fromRect.width / 2;
  const startY = fromRect.top + fromRect.height / 2;
  const endX = toRect.left + toRect.width / 2;
  const endY = toRect.top + toRect.height / 2;

  // Calculate scale to match target card size
  const targetScale = toRect.width / fromRect.width;

  // å¼§çº¿æ§åˆ¶ç‚¹ï¼šå›´ç»• .tableBg ä¸­å¿ƒç‚¹
  // æ§åˆ¶ç‚¹ä½äºèµ·ç‚¹å’Œç»ˆç‚¹ä¹‹é—´ï¼Œä½†åå‘ä¸­å¿ƒ
  const midX = (startX + endX) / 2;
  const midY = (startY + endY) / 2;
  const toCenterX = centerX - midX;
  const toCenterY = centerY - midY;

  // å¼§çº¿é«˜åº¦ï¼šæ ¹æ®è·ç¦»å’Œä½ç½®åŠ¨æ€è°ƒæ•´
  const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
  const arcHeight = Math.min(200, dist * 0.4);
  const controlX = midX + toCenterX * 0.3; // 30% åå‘ä¸­å¿ƒ
  const controlY = midY + toCenterY * 0.3 - arcHeight; // åŠ ä¸Šå¼§çº¿é«˜åº¦

  // Determine rotation based on target player
  let targetRotation = 0;
  if (playerIndex === 3) targetRotation = 90;        // Left AI
  else if (playerIndex === 1) targetRotation = -90;  // Right AI
  else if (playerIndex === 2) targetRotation = -180; // Top AI
  else targetRotation = 0;                            // Player (bottom)

  const keyframes = [];
  const steps = 30;
  const overshootRatio = 0.05;
  const overshootDist = dist * overshootRatio;

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    let easeT, overshoot;

    // Two-phase animation: approach with overshoot, then settle
    if (t <= 0.72) {
      const t1 = t / 0.72;
      easeT = 1 - Math.pow(1 - t1, 3);
      overshoot = 1.05;
    } else {
      const t2 = (t - 0.72) / 0.28;
      const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
      easeT = 1.05 - 0.05 * easeT2;
      overshoot = easeT;
    }

    // è´å¡å°”æ›²çº¿è½¨è¿¹ï¼ˆå›´ç»•ä¸­å¿ƒç‚¹çš„å¼§çº¿ï¼‰
    const baseX = (1-easeT)*(1-easeT)*startX + 2*(1-easeT)*easeT*controlX + easeT*easeT*endX;
    const baseY = (1-easeT)*(1-easeT)*startY + 2*(1-easeT)*easeT*controlY + easeT*easeT*endY;

    // æ·»åŠ è¿‡å†²
    const dirX = endX - startX;
    const dirY = endY - startY;
    const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
    const normX = dirLen > 0 ? dirX / dirLen : 0;
    const normY = dirLen > 0 ? dirY / dirLen : 0;
    const overshootAmount = (overshoot - 1.0) * overshootDist;
    const x = baseX + normX * overshootAmount;
    const y = baseY + normY * overshootAmount;

    const currentScale = 1 + (targetScale - 1) * Math.min(easeT, 1.0);
    const currentRotation = targetRotation * Math.min(easeT, 1.0);
    const flipRotation = playerIndex === 0 ? 0 : Math.min(easeT, 1.0) * 180;

    keyframes.push({
      left: `${x}px`,
      top: `${y}px`,
      transform: `translate(-50%, -50%) scale(${currentScale}) rotate(${currentRotation}deg) rotateY(${flipRotation}deg)`,
      opacity: 1 - 0.05 * Math.min(easeT, 1.0)
    });
  }

  cardEl.animate(keyframes, {
    duration: 560,
    easing: "linear"
  }).onfinish = () => {
    cardEl.remove();
    if (onComplete) onComplete();
  };
}

// Animate card draw with flying card (source -> target player hand)
// Physics-based arc trajectory with proper rotation and overshoot
function animateDrawCardFly(fromPlayerIdx, toPlayerIdx, drawnCard, onComplete) {
  try {
    const fromHandEl = seatHandElByPlayerIndex(fromPlayerIdx);
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);
    if (!fromHandEl || !toHandEl) {
      if (onComplete) onComplete();
      return;
    }

    const fromRect = fromHandEl.getBoundingClientRect();
    const toRect = toHandEl.getBoundingClientRect();

    // å¦‚æœæºæ‰‹ç‰Œé«˜åº¦ä¸º0ï¼ˆå·²å‡ºå®Œç‰Œï¼‰ï¼Œä½¿ç”¨é»˜è®¤å€¼é¿å…åŠ¨ç”»å¤±æ•ˆ
    const safeWidth = fromRect.width || 100;
    const safeHeight = fromRect.height || 100;
    if (fromRect.height === 0 || fromRect.width === 0) {
      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] æºæ‰‹ç‰ŒåŒºåŸŸå°ºå¯¸å¼‚å¸¸ width:${fromRect.width} height:${fromRect.height}ï¼Œä½¿ç”¨é»˜è®¤å€¼`);
    }

    // è·å– .tableBg ä¸­å¿ƒç‚¹ä½œä¸ºå¼§çº¿å‚è€ƒ
    const tableBg = document.querySelector('.tableBg');
    const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
    const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
    const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

    // è®¡ç®—èµ·ç‚¹å’Œç»ˆç‚¹ï¼ˆä¸­å¿ƒåæ ‡ï¼‰
    const startX = fromRect.left + safeWidth / 2;
    const startY = fromRect.top + safeHeight / 2;
    const endX = toRect.left + toRect.width / 2;
    const endY = toRect.top + toRect.height / 2;

    // ç¡®å®šç›®æ ‡ç©å®¶æ‰‹ç‰Œçš„å®é™…å¡ç‰Œå°ºå¯¸ï¼ˆç”¨äºç¼©æ”¾ï¼‰
    let targetCardWidth, targetCardHeight;
    if (toPlayerIdx === 0) {
      // ç©å®¶æ‰‹ç‰Œï¼ˆåº•éƒ¨ï¼‰
      const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 0.85;
      targetCardWidth = 86 * scalePlayer;
      targetCardHeight = 124 * scalePlayer;
    } else if (toPlayerIdx === 2) {
      // AIä¸Šå®¶
      const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1.29;
      targetCardWidth = 52 * scaleTop;
      targetCardHeight = 72 * scaleTop;
    } else {
      // AIå·¦å³å®¶
      const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1.25;
      targetCardWidth = 64 * scaleSide;
      targetCardHeight = 89 * scaleSide;
    }

    // åˆ›å»ºé£è¡Œå¡ç‰Œï¼ˆåŒé¢ç»“æ„ï¼šæ­£é¢+èƒŒé¢ï¼‰
    const showFace = fromPlayerIdx === 0; // ä»äººç±»ç©å®¶æ‰‹ä¸­æŠ½å‡ºæ—¶æ˜¾ç¤ºæ­£é¢

    // ç¿»è½¬å®¹å™¨
    const flipContainer = document.createElement("div");
    flipContainer.style.width = "86px";
    flipContainer.style.height = "124px";
    flipContainer.style.position = "fixed";
    flipContainer.style.transformStyle = "preserve-3d";
    flipContainer.style.perspective = "1000px";
    flipContainer.style.left = `${startX - 43}px`;
    flipContainer.style.top = `${startY - 62}px`;
    flipContainer.style.zIndex = "10005";
    flipContainer.style.pointerEvents = "none";

    // èƒŒé¢ç‰Œ
    const backCard = document.createElement("div");
    backCard.className = "miniBack";
    backCard.style.width = "86px";
    backCard.style.height = "124px";
    backCard.style.position = "absolute";
    backCard.style.backfaceVisibility = "hidden";
    backCard.style.transform = "rotateY(0deg)";

    // æ­£é¢ç‰Œ
    const frontCard = document.createElement("div");
    frontCard.className = `faceCard ${drawnCard && drawnCard.type === "joker" ? "joker imgCard" : ""} ${drawnCard && drawnCard.type === "img" ? "imgCard" : ""}`;
    frontCard.style.width = "86px";
    frontCard.style.height = "124px";
    frontCard.style.position = "absolute";
    frontCard.style.backfaceVisibility = "hidden";
    frontCard.style.transform = "rotateY(180deg)";

    if (drawnCard) {
      if (drawnCard.type === "joker") {
        frontCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
          </div>
        `;
      } else {
        frontCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" draggable="false" /></div>
          </div>
        `;
      }
    }

    flipContainer.appendChild(backCard);
    flipContainer.appendChild(frontCard);
    document.body.appendChild(flipContainer);

    // è®¡ç®—å¼§çº¿æ§åˆ¶ç‚¹ï¼ˆå›´ç»• .tableBg ä¸­å¿ƒï¼‰
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const toCenterX = centerX - midX;
    const toCenterY = centerY - midY;

    const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    const arcHeight = Math.min(200, dist * 0.4); // å¼§çº¿é«˜åº¦
    const controlX = midX + toCenterX * 0.3;
    const controlY = midY + toCenterY * 0.3 - arcHeight;

    // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦
    let targetRotZ = 0;
    if (toPlayerIdx === 3) targetRotZ = 90;        // å·¦ä¾§AI
    else if (toPlayerIdx === 1) targetRotZ = -90;  // å³ä¾§AI
    else if (toPlayerIdx === 2) targetRotZ = 180;  // ä¸Šæ–¹AI
    else targetRotZ = 0;                            // ç©å®¶ï¼ˆåº•éƒ¨ï¼‰

    // è®¡ç®—ç›®æ ‡ç¼©æ”¾
    const targetScale = targetCardWidth / 86;

    // ç”Ÿæˆå…³é”®å¸§ï¼ˆè´å¡å°”æ›²çº¿ + è¿‡å†²ï¼‰
    const steps = 30;
    const keyframes = [];
    const overshootDist = dist * 0.05; // 5% è¿‡å†²

    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      let easeT, overshoot;

      // ä¸¤é˜¶æ®µç¼“åŠ¨ï¼šåŠ é€Ÿæ¥è¿‘ï¼ˆ68%ï¼‰+ è¿‡å†²å›è½ï¼ˆ32%ï¼‰
      if (t <= 0.72) {
        const t1 = t / 0.72;
        easeT = 1 - Math.pow(1 - t1, 3); // ease-out
        overshoot = 1.05; // 5% è¿‡å†²
      } else {
        const t2 = (t - 0.72) / 0.28;
        const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
        easeT = 1.05 - 0.05 * easeT2; // ä» 1.05 å›åˆ° 1.0
        overshoot = easeT;
      }

      // è´å¡å°”æ›²çº¿è½¨è¿¹ï¼ˆäºŒæ¬¡ï¼‰
      const arcT = Math.min(easeT, 1.0);
      const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*endX;
      const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*endY;

      // æ·»åŠ è¿‡å†²ï¼ˆæ²¿è¿åŠ¨æ–¹å‘ï¼‰
      const dirX = endX - startX;
      const dirY = endY - startY;
      const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
      const normX = dirLen > 0 ? dirX / dirLen : 0;
      const normY = dirLen > 0 ? dirY / dirLen : 0;
      const overshootAmount = (overshoot - 1.0) * overshootDist;

      const x = baseX + normX * overshootAmount;
      const y = baseY + normY * overshootAmount;

      // å¹³æ»‘ç¼©æ”¾
      const currentScale = 1 + (targetScale - 1) * Math.min(arcT, 1.0);

      // Zè½´æ—‹è½¬ï¼ˆå¯¹é½ç›®æ ‡ç©å®¶æ‰‹ç‰Œæ–¹å‘ï¼‰
      const currentRotZ = targetRotZ * Math.min(arcT, 1.0);

      // Yè½´ç¿»è½¬ï¼ˆä»äººç±»æ‰‹ä¸­æŠ½å‡ºæ—¶ï¼šæ­£é¢â†’èƒŒé¢ï¼›ä»AIæ‰‹ä¸­æŠ½åˆ°äººç±»æ‰‹ä¸­ï¼šèƒŒé¢â†’æ­£é¢ï¼‰
      let flipRotY = 0;
      if (showFace) {
        // ä»äººç±»æ‰‹ä¸­æŠ½å‡ºï¼šæ­£é¢(0deg) â†’ èƒŒé¢(180deg)
        flipRotY = Math.min(arcT, 1.0) * 180;
      } else if (toPlayerIdx === 0) {
        // æŠ½åˆ°äººç±»æ‰‹ä¸­ï¼šèƒŒé¢(0deg) â†’ æ­£é¢(180deg)
        flipRotY = Math.min(arcT, 1.0) * 180;
      }
      // AIä¹‹é—´æŠ½ç‰Œï¼šä¸ç¿»è½¬ï¼Œä¿æŒèƒŒé¢

      // æ·¡å‡ºæ•ˆæœ
      const opacity = 1 - 0.05 * Math.min(arcT, 1.0);

      keyframes.push({
        left: `${x - 43}px`,
        top: `${y - 62}px`,
        transform: `scale(${currentScale}) rotateZ(${currentRotZ}deg) rotateY(${flipRotY}deg)`,
        opacity: opacity,
        offset: t
      });
    }

    // æ‰§è¡ŒåŠ¨ç”»
    const anim = flipContainer.animate(keyframes, {
      duration: 560,
      easing: "linear" // ç¼“åŠ¨å·²åœ¨å…³é”®å¸§ä¸­æ‰‹åŠ¨å®ç°
    });

    anim.onfinish = () => {
      flipContainer.remove();
      if (onComplete) onComplete();
    };
  } catch (e) {
    console.error("animateDrawCardFly error:", e);
    if (onComplete) onComplete();
  }
}

// Animate card draw from a specific point (used when drawing from overlay)
// startX/startY: the actual pixel position where the card currently is
function animateDrawCardFlyFromPoint(startX, startY, toPlayerIdx, drawnCard, onComplete) {
  console.log("[animateDrawCardFlyFromPoint] å¼€å§‹", { startX, startY, toPlayerIdx, drawnCard });
  try {
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);
    console.log("[animateDrawCardFlyFromPoint] toHandEl:", toHandEl);
    if (!toHandEl) {
      console.log("[animateDrawCardFlyFromPoint] é”™è¯¯ï¼šæ‰¾ä¸åˆ°ç›®æ ‡æ‰‹ç‰Œå…ƒç´ ");
      if (onComplete) onComplete();
      return;
    }

    const toRect = toHandEl.getBoundingClientRect();

    // è·å– .tableBg ä¸­å¿ƒç‚¹ä½œä¸ºå¼§çº¿å‚è€ƒ
    const tableBg = document.querySelector('.tableBg');
    const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
    const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
    const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

    // ç»ˆç‚¹ï¼ˆä¸­å¿ƒåæ ‡ï¼‰
    const endX = toRect.left + toRect.width / 2;
    const endY = toRect.top + toRect.height / 2;

    // ç¡®å®šç›®æ ‡ç©å®¶æ‰‹ç‰Œçš„å®é™…å¡ç‰Œå°ºå¯¸ï¼ˆç”¨äºç¼©æ”¾ï¼‰
    let targetCardWidth, targetCardHeight;
    if (toPlayerIdx === 0) {
      // ç©å®¶æ‰‹ç‰Œï¼ˆåº•éƒ¨ï¼‰
      const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 0.85;
      targetCardWidth = 86 * scalePlayer;
      targetCardHeight = 124 * scalePlayer;
    } else if (toPlayerIdx === 2) {
      // AIä¸Šå®¶
      const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1.29;
      targetCardWidth = 52 * scaleTop;
      targetCardHeight = 72 * scaleTop;
    } else {
      // AIå·¦å³å®¶
      const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1.25;
      targetCardWidth = 64 * scaleSide;
      targetCardHeight = 89 * scaleSide;
    }

    // åˆ›å»ºé£è¡Œå¡ç‰Œï¼ˆå·²ç»æ˜¯æ­£é¢äº†ï¼Œå› ä¸ºåœ¨æŠ½ç‰Œç•Œé¢å·²ç»ç¿»è½¬è¿‡äº†ï¼‰
    const flyingCard = document.createElement("div");
    flyingCard.className = `faceCard ${drawnCard && drawnCard.type === "joker" ? "joker imgCard" : ""} ${drawnCard && drawnCard.type === "img" ? "imgCard" : ""}`;
    flyingCard.style.width = "140px"; // æŠ½ç‰Œç•Œé¢å¡ç‰Œå°ºå¯¸
    flyingCard.style.height = "196px";
    flyingCard.style.position = "fixed";
    flyingCard.style.left = `${startX - 70}px`;
    flyingCard.style.top = `${startY - 98}px`;
    flyingCard.style.zIndex = "10005";
    flyingCard.style.pointerEvents = "none";

    if (drawnCard) {
      if (drawnCard.type === "joker") {
        flyingCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
          </div>
        `;
      } else {
        flyingCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" draggable="false" /></div>
          </div>
        `;
      }
    }

    document.body.appendChild(flyingCard);

    // è®¡ç®—å¼§çº¿æ§åˆ¶ç‚¹ï¼ˆå›´ç»• .tableBg ä¸­å¿ƒï¼‰
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const toCenterX = centerX - midX;
    const toCenterY = centerY - midY;

    const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    const arcHeight = Math.min(200, dist * 0.4); // å¼§çº¿é«˜åº¦
    const controlX = midX + toCenterX * 0.3;
    const controlY = midY + toCenterY * 0.3 - arcHeight;

    // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆç©å®¶æ‰‹ç‰Œä¸æ—‹è½¬ï¼Œä¿æŒ0åº¦ï¼‰
    const targetRotZ = 0; // ç©å®¶æ‰‹ç‰Œå§‹ç»ˆæ˜¯0åº¦

    // è®¡ç®—ç›®æ ‡ç¼©æ”¾ï¼ˆä»æŠ½ç‰Œç•Œé¢140pxç¼©æ”¾åˆ°ç©å®¶æ‰‹ç‰Œå°ºå¯¸ï¼‰
    const targetScale = targetCardWidth / 140;

    // ç”Ÿæˆå…³é”®å¸§ï¼ˆè´å¡å°”æ›²çº¿ + è¿‡å†²ï¼‰
    const steps = 30;
    const keyframes = [];
    const overshootDist = dist * 0.05; // 5% è¿‡å†²

    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      let easeT, overshoot;

      // ä¸¤é˜¶æ®µç¼“åŠ¨ï¼šåŠ é€Ÿæ¥è¿‘ï¼ˆ68%ï¼‰+ è¿‡å†²å›è½ï¼ˆ32%ï¼‰
      if (t <= 0.72) {
        const t1 = t / 0.72;
        easeT = 1 - Math.pow(1 - t1, 3); // ease-out
        overshoot = 1.05; // 5% è¿‡å†²
      } else {
        const t2 = (t - 0.72) / 0.28;
        const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
        easeT = 1.05 - 0.05 * easeT2; // ä» 1.05 å›åˆ° 1.0
        overshoot = easeT;
      }

      // è´å¡å°”æ›²çº¿è½¨è¿¹ï¼ˆäºŒæ¬¡ï¼‰
      const arcT = Math.min(easeT, 1.0);
      const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*endX;
      const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*endY;

      // æ·»åŠ è¿‡å†²ï¼ˆæ²¿è¿åŠ¨æ–¹å‘ï¼‰
      const dirX = endX - startX;
      const dirY = endY - startY;
      const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
      const normX = dirLen > 0 ? dirX / dirLen : 0;
      const normY = dirLen > 0 ? dirY / dirLen : 0;
      const overshootAmount = (overshoot - 1.0) * overshootDist;

      const x = baseX + normX * overshootAmount;
      const y = baseY + normY * overshootAmount;

      // å¹³æ»‘ç¼©æ”¾
      const currentScale = 1 + (targetScale - 1) * Math.min(arcT, 1.0);

      // æ·¡å‡ºæ•ˆæœ
      const opacity = 1 - 0.05 * Math.min(arcT, 1.0);

      keyframes.push({
        left: `${x - 70}px`,
        top: `${y - 98}px`,
        transform: `scale(${currentScale})`,
        opacity: opacity,
        offset: t
      });
    }

    // æ‰§è¡ŒåŠ¨ç”»
    console.log("[animateDrawCardFlyFromPoint] å¼€å§‹åŠ¨ç”», keyframesæ•°é‡:", keyframes.length);
    const anim = flyingCard.animate(keyframes, {
      duration: 560,
      easing: "linear" // ç¼“åŠ¨å·²åœ¨å…³é”®å¸§ä¸­æ‰‹åŠ¨å®ç°
    });

    anim.onfinish = () => {
      console.log("[animateDrawCardFlyFromPoint] åŠ¨ç”»å®Œæˆï¼Œç§»é™¤å¡ç‰Œå¹¶è°ƒç”¨å›è°ƒ");
      flyingCard.remove();
      if (onComplete) {
        console.log("[animateDrawCardFlyFromPoint] è°ƒç”¨ onComplete");
        onComplete();
      } else {
        console.log("[animateDrawCardFlyFromPoint] è­¦å‘Šï¼šonComplete ä¸ºç©º");
      }
    };
  } catch (e) {
    console.error("animateDrawCardFlyFromPoint error:", e);
    if (onComplete) onComplete();
  }
}

// Animate AI discard pair: show two face-up cards flying from AI hand to discard pile
// Uses physics-based arc trajectory with overshoot and settle-back
function animateAiDiscardPair(playerIdx, card1, card2, fromRectOverride, onComplete) {
  // å¤„ç†å‚æ•°ï¼šå¦‚æœç¬¬4ä¸ªå‚æ•°æ˜¯å‡½æ•°ï¼Œè¯´æ˜æ²¡æœ‰ä¼  fromRectOverride
  if (typeof fromRectOverride === 'function') {
    onComplete = fromRectOverride;
    fromRectOverride = null;
  }

  console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] AI${playerIdx} å¼€å§‹é…å¯¹å‡ºç‰ŒåŠ¨ç”», card1:`, card1, "card2:", card2);
  try {
    const fromHandEl = seatHandElByPlayerIndex(playerIdx);
    const discardPile = document.getElementById("discardPile");
    console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] fromHandEl:`, fromHandEl, "discardPile:", discardPile);
    if (!fromHandEl || !discardPile) {
      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] å…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡åŠ¨ç”»`);
      if (onComplete) onComplete();
      return;
    }

    // ä½¿ç”¨ä¼ å…¥çš„ä½ç½®ï¼Œæˆ–è€…å®æ—¶è·å–
    const fromRect = fromRectOverride || fromHandEl.getBoundingClientRect();
    const toRect = discardPile.getBoundingClientRect();
    console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] fromRect:`, fromRect, "toRect:", toRect, "ä½¿ç”¨ä¼ å…¥ä½ç½®:", !!fromRectOverride);

    // åœ¨åŠ¨ç”»å¼€å§‹æ—¶ï¼Œç«‹å³è°ƒæ•´å‰©ä½™AIæ‰‹ç‰Œä½ç½®ï¼ˆå¡«è¡¥ç©ºç¼ºï¼‰
    // æ³¨æ„ï¼šæ­¤æ—¶ tryDiscardPairByCardIds è¿˜æœªè¢«è°ƒç”¨ï¼Œæ‰‹ç‰Œæ•°é‡è¿˜æ˜¯åŸå§‹å€¼
    const aiPlayer = window.game?.players?.[playerIdx];
    if (aiPlayer) {
      const currentN = aiPlayer.hand.length; // å½“å‰æ‰‹ç‰Œæ•°é‡
      const newN = currentN - 2; // å‡ºç‰Œåçš„æ•°é‡ï¼ˆå³å°†å‡2ï¼‰
      const allBackCards = Array.from(fromHandEl.querySelectorAll('.miniBack'));

      // æ ‡è®°æ‰‹ç‰ŒåŒºåŸŸæ­£åœ¨åšè‡ªé€‚åº”åŠ¨ç”»ï¼Œé˜²æ­¢ renderSeats é‡æ–°æ¸²æŸ“
      fromHandEl.dataset.adjusting = "true";

      // è®¡ç®—æ–°çš„å¸ƒå±€å‚æ•°
      const newCenter = (newN - 1) / 2;

      allBackCards.forEach((backCard, k) => {
        const d = k - newCenter;
        let sx = 0;
        let sy = 0;
        let srot = 0;

        if (playerIdx === 2) {
          // Top player: æ¨ªå‘å±•å¼€
          sx = d * 12;
          sy = d * 0.3;
          srot = 0;
        } else {
          // Left/Right: çºµå‘å±•å¼€
          sx = d * 0.3;
          sy = d * 9;
          srot = playerIdx === 1 || playerIdx === 3 ? 90 : 0;
        }

        // æ·»åŠ transitionå¹¶æ›´æ–°ä½ç½®
        backCard.style.transition = "left 420ms cubic-bezier(0.22, 1, 0.36, 1), top 420ms cubic-bezier(0.22, 1, 0.36, 1), transform 420ms cubic-bezier(0.22, 1, 0.36, 1)";

        requestAnimationFrame(() => {
          backCard.style.setProperty("--sx", `${sx}px`);
          backCard.style.setProperty("--sy", `${sy}px`);
          backCard.style.setProperty("--srot", `${srot}deg`);
        });
      });

      // 420ms åæ¸…é™¤æ ‡è®°ï¼Œå…è®¸é‡æ–°æ¸²æŸ“
      setTimeout(() => {
        fromHandEl.dataset.adjusting = "";
      }, 420);
    }

    // Sort cards: _A to left pile, _B to right pile
    let leftCard, rightCard;
    if (card1.imgSrc && card1.imgSrc.includes("_A.")) {
      leftCard = card1;
      rightCard = card2;
    } else if (card2.imgSrc && card2.imgSrc.includes("_A.")) {
      leftCard = card2;
      rightCard = card1;
    } else {
      // Fallback if no clear A/B suffix
      leftCard = card1;
      rightCard = card2;
    }

    const cards = [leftCard, rightCard];
    console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] å‡†å¤‡åˆ›å»ºé£è¡Œå¡ç‰Œ, leftCard:`, leftCard, "rightCard:", rightCard);
    let completed = 0;

    // Calculate rotation angle using same hash function as renderDiscardPile
    function hash01(str) {
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return ((h >>> 0) % 10000) / 10000;
    }
    function rotJitter(cardId, idx) {
      return (hash01(`${cardId}|${idx}`) - 0.5) * 8; // -4..4 deg
    }

    // Calculate z-index for each card (matching renderDiscardPile logic)
    const currentDiscardLength = window.game ? window.game.discardPile.length : 0;
    const leftZ = 10 + Math.floor(currentDiscardLength / 2);
    const rightZ = 100 + Math.floor(currentDiscardLength / 2);

    cards.forEach((card, index) => {
      // åˆ›å»ºç¿»è½¬å®¹å™¨ï¼ˆåŒé¢å¡ç‰Œï¼‰
      const flipContainer = document.createElement("div");
      flipContainer.style.width = "86px";
      flipContainer.style.height = "124px";
      flipContainer.style.position = "fixed";
      flipContainer.style.transformStyle = "preserve-3d";
      flipContainer.style.perspective = "1000px";

      const cardWidth = 86;
      const cardHeight = 124;

      // Staggered start position: left card slightly earlier/left, right card slightly later/right
      const startOffsetX = (index - 0.5) * 40; // wider separation
      const startOffsetY = index * -8; // slight vertical offset

      // ä¿®å¤ï¼šå¦‚æœ fromRect.height === 0ï¼Œä½¿ç”¨zoneåŒºåŸŸé«˜åº¦ä¼°ç®—
      const effectiveHeight = fromRect.height > 0 ? fromRect.height : 150;
      const startCenterX = fromRect.left + fromRect.width / 2 + startOffsetX;
      const startCenterY = fromRect.top + effectiveHeight / 2 + startOffsetY;

      const startLeft = startCenterX - cardWidth / 2;
      const startTop = startCenterY - cardHeight / 2;

      flipContainer.style.left = `${startLeft}px`;
      flipContainer.style.top = `${startTop}px`;
      flipContainer.style.zIndex = "10000";
      flipContainer.style.pointerEvents = "none";

      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] Card${index} fromRect.height=${fromRect.height}, ä½¿ç”¨é«˜åº¦=${effectiveHeight}`);
      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] Card${index} èµ·ç‚¹: (${startLeft}, ${startTop})`);

      // èƒŒé¢ç‰Œ
      const backCard = document.createElement("div");
      backCard.className = "miniBack";
      backCard.style.width = "86px";
      backCard.style.height = "124px";
      backCard.style.position = "absolute";
      backCard.style.backfaceVisibility = "hidden";
      backCard.style.transform = "rotateY(0deg)";

      // æ­£é¢ç‰Œ
      const frontCard = document.createElement("div");
      frontCard.className = `faceCard ${card.type === "img" ? "imgCard" : ""}`;
      frontCard.style.width = "86px";
      frontCard.style.height = "124px";
      frontCard.style.position = "absolute";
      frontCard.style.backfaceVisibility = "hidden";
      frontCard.style.transform = "rotateY(180deg)";
      if (card.type === "img") {
        frontCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="${escapeHtml(card.imgSrc)}" alt="card" draggable="false" /></div>
          </div>
        `;
      }

      flipContainer.appendChild(backCard);
      flipContainer.appendChild(frontCard);
      document.body.appendChild(flipContainer);

      // Target position: left pile (28%) or right pile (72%)
      // renderDiscardPile ä½¿ç”¨ left:xPercent% + transform:translate(-50%,-50%)
      // æ‰€ä»¥å®é™…ä¸­å¿ƒç‚¹ = toRect.left + toRect.width * xPercent
      const targetXPercent = index === 0 ? 0.28 : 0.72;
      const baseY = 0.52;

      // å¼ƒç‰Œå †å¡ç‰Œçš„å®é™…å°ºå¯¸ï¼ˆè€ƒè™‘ç¼©æ”¾ï¼‰
      const discardScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-discard-pile') || "1");
      const discardCardWidth = 92 * discardScale;  // discardCard åŸºç¡€å®½åº¦92px
      const discardCardHeight = 132 * discardScale; // discardCard åŸºç¡€é«˜åº¦132px

      // ç›®æ ‡ä¸­å¿ƒç‚¹ï¼ˆrenderDiscardPileä¸­å¡ç‰Œçš„å®é™…ä¸­å¿ƒï¼‰
      const targetCenterX = toRect.left + toRect.width * targetXPercent;
      const targetCenterY = toRect.top + toRect.height * baseY;

      // è½¬æ¢ä¸ºå·¦ä¸Šè§’åæ ‡ï¼ˆåŠ¨ç”»ä½¿ç”¨style.left/topï¼Œéœ€è¦å‡å»å¡ç‰Œå°ºå¯¸çš„ä¸€åŠï¼‰
      const targetX = targetCenterX - discardCardWidth / 2;
      const targetY = targetCenterY - discardCardHeight / 2;

      const startX = fromRect.left + fromRect.width / 2 + startOffsetX;
      const startY = fromRect.top + fromRect.height / 2 + startOffsetY;

      // ç›®æ ‡å°ºå¯¸åº”è¯¥æ˜¯ discardCard çš„å°ºå¯¸ (92x132)ï¼Œè€Œä¸æ˜¯ miniBack (86x124)
      const targetWidth = discardCardWidth;   // 92 * discardScale
      const scaleTarget = targetWidth / 86;   // ä»èµ·å§‹çš„86pxç¼©æ”¾åˆ°ç›®æ ‡å®½åº¦

      const zIndex = index === 0 ? leftZ : rightZ;
      const targetRotation = rotJitter(card.id, zIndex);

      console.log(`[AIå‡ºç‰Œä½ç½®] Card${index}:`, {
        targetXPercent, baseY,
        targetX, targetY,
        startX, startY,
        dx: targetX - startX,
        dy: targetY - startY
      });

      // Physics-based animation with arc trajectory and overshoot
      // Phase 1 (0% â†’ 68%): Fast approach with arc (ease-out)
      // Phase 2 (68% â†’ 100%): Settle back with slight overshoot (ease-in-out)
      const steps = 40;
      const keyframes = [];

      // Calculate arc trajectory (parabola)
      const dx = targetX - startX;
      const dy = targetY - startY;
      const dist = Math.sqrt(dx * dx + dy * dy);

      // Arc height proportional to distance (higher arc for longer throws)
      const arcHeight = Math.min(120, dist * 0.25); // peak height of arc

      // Overshoot distance (5% of total distance)
      const overshootDist = dist * 0.05;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        let easeT, overshoot;

        // Two-phase easing like dealEnter
        if (t <= 0.68) {
          // Phase 1: Fast approach with ease-out
          const t1 = t / 0.68;
          easeT = 1 - Math.pow(1 - t1, 2.5); // ease-out (slower at end)
          overshoot = 1.05; // 5% overshoot at end of phase 1
        } else {
          // Phase 2: Settle back with ease-in-out
          const t2 = (t - 0.68) / 0.32;
          const easeT2 = t2 < 0.5
            ? 4 * t2 * t2 * t2
            : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
          easeT = 1.05 - 0.05 * easeT2; // from 1.05 back to 1.0
          overshoot = easeT;
        }

        // Quadratic arc trajectory (parabola)
        // At t=0: (0, 0), t=0.5: (dx/2, -arcHeight), t=1: (dx, 0)
        const arcT = Math.min(easeT, 1.0);
        const baseX = dx * arcT;
        const baseY = dy * arcT;

        // Parabolic Y offset (arc curve)
        const arcY = -arcHeight * 4 * arcT * (1 - arcT); // parabola peaks at t=0.5

        // Apply overshoot in direction of movement
        const dirLen = Math.sqrt(dx * dx + dy * dy);
        const normX = dirLen > 0 ? dx / dirLen : 0;
        const normY = dirLen > 0 ? dy / dirLen : 0;
        const overshootAmount = (overshoot - 1.0) * overshootDist;

        const x = baseX + normX * overshootAmount;
        const y = baseY + arcY + normY * overshootAmount;

        // Scale smoothly from 1 to targetScale
        const currentScale = 1 + (scaleTarget - 1) * Math.min(easeT, 1.0);

        // Y-axis flip (èƒŒé¢ -> æ­£é¢): 0deg -> 180deg
        const flipRotation = Math.min(easeT, 1.0) * 180;

        // Z-axis tumbling rotation (adds realism)
        // Rotate faster during flight, slow down when landing
        const tumbleSpeed = 360 * (1 - Math.min(easeT, 1.0)); // slows down from 360 to 0
        const tumbleRotation = targetRotation + tumbleSpeed * arcT;

        // Opacity fade in/out slightly
        const opacity = 1 - 0.05 * Math.min(easeT, 1.0);

        keyframes.push({
          transform: `translate(${x}px, ${y}px) rotateY(${flipRotation}deg) scale(${currentScale}) rotate(${tumbleRotation}deg)`,
          opacity: opacity,
          offset: t
        });
      }

      // è°ƒè¯•ï¼šæ‰“å°æœ€åä¸€å¸§çš„ä½ç½®
      const lastFrame = keyframes[keyframes.length - 1];
      console.log(`AIå‡ºç‰Œ card${index} ç»ˆç‚¹:`, {
        startX, startY,
        targetX, targetY,
        dx, dy,
        lastFrame: lastFrame.transform
      });

      // Animate with baked-in easing
      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] Card${index} å¼€å§‹animate, keyframesæ•°é‡:`, keyframes.length);
      const anim = flipContainer.animate(keyframes, {
        duration: 680,
        easing: "linear"
      });
      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] Card${index} animateå¯¹è±¡åˆ›å»ºå®Œæˆ, playState:`, anim.playState);

      anim.onfinish = () => {
        console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] Card${index} åŠ¨ç”»å®Œæˆ`);
        flipContainer.remove();
        completed++;
        console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] completed=${completed}, total=${cards.length}`);
        if (completed === cards.length && onComplete) {
          console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] æ‰€æœ‰å¡ç‰‡å®Œæˆï¼Œè°ƒç”¨å›è°ƒ`);
          onComplete();
        }
      };
    });
  } catch (e) {
    console.error("animateAiDiscardPair error:", e);
    if (onComplete) onComplete();
  }
}

// Animate Joker draw: from source -> center reveal -> target hand
function animateJokerDrawReveal(fromPlayerIdx, toPlayerIdx, onComplete) {
  try {
    const fromHandEl = seatHandElByPlayerIndex(fromPlayerIdx);
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);
    if (!fromHandEl || !toHandEl) {
      if (onComplete) onComplete();
      return;
    }

    const fromRect = fromHandEl.getBoundingClientRect();
    const toRect = toHandEl.getBoundingClientRect();

    // Create flying Joker card
    const flyingCard = document.createElement("div");
    flyingCard.className = "faceCard joker imgCard";
    flyingCard.style.width = "86px";
    flyingCard.style.height = "124px";
    flyingCard.style.position = "fixed";
    flyingCard.style.left = `${fromRect.left + fromRect.width / 2 - 43}px`;
    flyingCard.style.top = `${fromRect.top + fromRect.height / 2 - 62}px`;
    flyingCard.style.zIndex = "10010";
    flyingCard.style.pointerEvents = "none";
    flyingCard.style.transform = "none";
    flyingCard.dataset.corner = "";
    flyingCard.innerHTML = `
      <div class="cardContent">
        <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
      </div>
    `;
    document.body.appendChild(flyingCard);

    // Calculate positions
    const startX = fromRect.left + fromRect.width / 2;
    const startY = fromRect.top + fromRect.height / 2;
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;
    const endX = toRect.left + toRect.width / 2;
    const endY = toRect.top + toRect.height / 2;

    // Step 1: Arc from source to center with overshoot
    const arcDist1 = Math.min(150, Math.abs(centerY - startY) * 0.5);
    const controlX1 = (startX + centerX) / 2;
    const controlY1 = (startY + centerY) / 2 - arcDist1; // Arc upward

    const keyframes1 = [];
    const steps1 = 30;
    for (let i = 0; i <= steps1; i++) {
      const t = i / steps1;
      let easeT;

      // Two-phase: gentle start with overshoot, then settle
      if (t <= 0.75) {
        const t1 = t / 0.75;
        // Quadratic ease-out for gentler start
        easeT = 1 - Math.pow(1 - t1, 2);
      } else {
        const t2 = (t - 0.75) / 0.25;
        easeT = 1.0 + 0.03 * (1 - t2); // smaller overshoot
      }

      const x = (1-easeT)*(1-easeT)*startX + 2*(1-easeT)*easeT*controlX1 + easeT*easeT*centerX;
      const y = (1-easeT)*(1-easeT)*startY + 2*(1-easeT)*easeT*controlY1 + easeT*easeT*centerY;
      const scale = 1 + 0.35 * Math.min(easeT, 1.0);
      const rotateY = easeT * 180; // Yè½´ç¿»è½¬ï¼šä»å¡èƒŒ(0Â°)ç¿»åˆ°æ­£é¢(180Â°)

      keyframes1.push({
        left: `${x - 43}px`,
        top: `${y - 62}px`,
        transform: `scale(${scale}) rotateY(${rotateY}deg)`,
        opacity: 1
      });
    }

    const anim1 = flyingCard.animate(keyframes1, {
      duration: 400, // å¿«é€Ÿé£åˆ°ä¸­é—´ï¼ˆä»680msç¼©çŸ­åˆ°400msï¼‰
      easing: "linear"
    });

    anim1.onfinish = () => {
      // Show name text
      const nameText = document.createElement("div");
      nameText.style.position = "fixed";
      nameText.style.left = "50%";
      nameText.style.top = `${centerY + 100}px`;
      nameText.style.transform = "translateX(-50%)";
      nameText.style.zIndex = "10011";
      nameText.style.fontSize = "18px";
      nameText.style.fontWeight = "900";
      nameText.style.color = "rgba(255,255,255,0.92)";
      nameText.style.textShadow = "0 2px 12px rgba(0,0,0,0.55)";
      nameText.style.pointerEvents = "none";
      nameText.textContent = `ç‹å…«ç‰Œ â†’ ${game?.players?.[toPlayerIdx]?.name || ""}`;
      document.body.appendChild(nameText);

      // Step 2: ç«‹å³é£å‘ç›®æ ‡ï¼ˆä¸åœç•™ï¼‰
      setTimeout(() => {
        nameText.remove();

        const arcDist2 = Math.min(150, Math.abs(endY - centerY) * 0.5);
        const controlX2 = (centerX + endX) / 2;
        const controlY2 = (centerY + endY) / 2 - arcDist2; // Arc upward

        const keyframes2 = [];
        const steps2 = 25;
        const overshootRatio = 0.05;
        const totalDist = Math.sqrt(Math.pow(endX - centerX, 2) + Math.pow(endY - centerY, 2));
        const overshootDist = totalDist * overshootRatio;

        for (let i = 0; i <= steps2; i++) {
          const t = i / steps2;
          let easeT, overshoot;

          if (t <= 0.72) {
            const t1 = t / 0.72;
            easeT = 1 - Math.pow(1 - t1, 3);
            overshoot = 1.05;
          } else {
            const t2 = (t - 0.72) / 0.28;
            const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
            easeT = 1.05 - 0.05 * easeT2;
            overshoot = easeT;
          }

          const baseX = (1-easeT)*(1-easeT)*centerX + 2*(1-easeT)*easeT*controlX2 + easeT*easeT*endX;
          const baseY = (1-easeT)*(1-easeT)*centerY + 2*(1-easeT)*easeT*controlY2 + easeT*easeT*endY;

          const dirX = endX - centerX;
          const dirY = endY - centerY;
          const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
          const normX = dirLen > 0 ? dirX / dirLen : 0;
          const normY = dirLen > 0 ? dirY / dirLen : 0;

          const overshootAmount = (overshoot - 1.0) * overshootDist;
          const x = baseX + normX * overshootAmount;
          const y = baseY + normY * overshootAmount;

          const scale = 1.35 - 0.6 * Math.min(easeT, 1.0);

          keyframes2.push({
            left: `${x - 43}px`,
            top: `${y - 62}px`,
            transform: `scale(${scale})`,
            opacity: 1 - 0.05 * Math.min(easeT, 1.0)
          });
        }

        const anim2 = flyingCard.animate(keyframes2, {
          duration: 560,
          easing: "linear"
        });

        anim2.onfinish = () => {
          flyingCard.remove();
          if (onComplete) onComplete();
        };
      }, 100); // ç«‹å³å¼€å§‹ç¬¬2æ®µï¼ˆä»…ç­‰100msæ˜¾ç¤ºæ–‡å­—ï¼‰
    };
  } catch (e) {
    console.error("animateJokerDrawReveal error:", e);
    if (onComplete) onComplete();
  }
}

// ç®€æ´çš„é£è¡Œå‡½æ•°ï¼šä».tableBgä¸­å¿ƒé£å‘ç©å®¶æ‰‹ç‰Œï¼Œ90åº¦æ—¶æ›¿æ¢å›¾ç‰‡
function flyJokerToPlayerSimple(game, playerIndex, onComplete) {
  try {
    const handEl = seatHandElByPlayerIndex(playerIndex);
    const player = game.players[playerIndex];
    const numCards = player ? player.hand.length + 1 : 1;

    // è·å–ç›®æ ‡å¡ç‰Œå°ºå¯¸
    let cardWidth, cardHeight;
    if (playerIndex === 0) {
      const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 1;
      cardWidth = 86 * s;
      cardHeight = 124 * s;
    } else if (playerIndex === 2) {
      const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1;
      cardWidth = 52 * s;
      cardHeight = 72 * s;
    } else {
      const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1;
      cardWidth = 64 * s;
      cardHeight = 89 * s;
    }

    // è®¡ç®—ç›®æ ‡ä½ç½®
    const handRect = handEl.getBoundingClientRect();
    let targetX, targetY;
    if (playerIndex === 0) {
      const center = (numCards - 1) / 2;
      const spread = Math.min(62, 920 / Math.max(1, numCards - 1));
      const d = numCards - 1 - center;
      targetX = handRect.left + handRect.width / 2 + d * spread;
      targetY = handRect.top + 18 + cardHeight / 2 + Math.abs(d) * 0.8;
    } else {
      const center = (numCards - 1) / 2;
      const d = numCards - 1 - center;
      if (playerIndex === 2) {
        targetX = handRect.left + handRect.width / 2 + d * 12;
        targetY = handRect.top + handRect.height / 2 + d * 0.3;
      } else {
        targetX = handRect.left + handRect.width / 2 + d * 0.3;
        targetY = handRect.top + handRect.height / 2 + d * 9;
      }
    }

    // è·å–.tableBgä¸­å¿ƒä½œä¸ºèµ·ç‚¹
    const tableBg = document.querySelector('.tableBg');
    const tbr = tableBg ? tableBg.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
    const startX = tbr.left + tbr.width / 2;
    const startY = tbr.top + tbr.height / 2;

    // åˆ›å»ºé£è¡Œå¡ç‰Œ
    const card = document.createElement('div');
    card.style.cssText = `position:fixed;left:${startX-43}px;top:${startY-62}px;width:86px;height:124px;z-index:10060;border:1px solid rgba(0,0,0,0.22);border-radius:16px;overflow:hidden;background:white;`;
    card.innerHTML = `<img id="jImg" style="width:100%;height:100%;object-fit:contain" src="./assets/joker.png">`;
    document.body.appendChild(card);

    const img = card.querySelector('#jImg');
    const targetScale = cardWidth / 86;
    let rotZ = 0;
    if (playerIndex === 1) rotZ = -90;
    else if (playerIndex === 2) rotZ = 180;
    else if (playerIndex === 3) rotZ = 90;

    const dist = Math.sqrt((targetX - startX) ** 2 + (targetY - startY) ** 2);
    const arc = Math.min(200, dist * 0.4);
    const cx = (startX + targetX) / 2;
    let cy = (startY + targetY) / 2;
    if (playerIndex === 0) cy -= arc;
    else if (playerIndex === 2) cy -= arc * 0.5;
    else cy += arc * 0.3;

    const kf = [];
    for (let i = 0; i <= 30; i++) {
      const t = i / 30;
      const et = 1 - (1 - t) ** 3;
      const x = (1 - et) ** 2 * startX + 2 * (1 - et) * et * cx + et ** 2 * targetX;
      const y = (1 - et) ** 2 * startY + 2 * (1 - et) * et * cy + et ** 2 * targetY;
      const sc = 1 + (targetScale - 1) * et;
      const rz = rotZ * et;
      let ry = 0;
      if (playerIndex !== 0 && et > 0.30) {
        ry = ((et - 0.30) / 0.70) * 180;
      }
      kf.push({ left: `${x - 43}px`, top: `${y - 62}px`, transform: `scale(${sc}) rotateZ(${rz}deg) rotateY(${ry}deg)`, opacity: 1 });
    }

    const an = card.animate(kf, { duration: 560, easing: 'linear', fill: 'forwards' });

    // AI: 90åº¦æ—¶æ›¿æ¢å›¾ç‰‡
    if (playerIndex !== 0 && img) {
      let flipped = false;
      const check = () => {
        if (flipped || an.playState === 'finished') return;
        const ct = an.currentTime || 0;
        const p = ct / 560;
        const et = 1 - (1 - p) ** 3;
        let ry = 0;
        if (et > 0.30) ry = ((et - 0.30) / 0.70) * 180;
        if (ry >= 90) {
          flipped = true;
          img.src = './assets/card-back.png';
          card.style.background = '#2b4a2d';
        } else {
          requestAnimationFrame(check);
        }
      };
      requestAnimationFrame(check);
    }

    an.onfinish = () => {
      card.remove();
      if (onComplete) onComplete();
    };
  } catch (e) {
    console.error('flyJokerToPlayerSimple error:', e);
    if (onComplete) onComplete();
  }
}

function showJokerRevealAndFly(game, playerIndex, onComplete) {
  // ğŸ¨ ä½¿ç”¨ç²’å­å‡èšç‰¹æ•ˆï¼ˆå¦‚æœå¯ç”¨ï¼‰
  if (window.JokerSummon && typeof window.JokerSummon.createSummonEffect === 'function') {
    const summonEffect = window.JokerSummon.createSummonEffect({
      jokerImageUrl: './assets/joker.png',
      duration: 1.2, // ç¼©çŸ­åˆ°1.2ç§’ï¼ˆæ‰­æ›²åœ¨60%åå°±åœæ­¢äº†ï¼‰
      onComplete: () => {
        summonEffect.destroy(); // é»‘å±ç¬é—´æ¶ˆå¤±
        flyJokerToPlayerSimple(game, playerIndex, onComplete); // ç«‹å³å¼€å§‹é£è¡Œ
      }
    });
    setTimeout(() => summonEffect.play(), 100);
    return;
  }

  // Fallback: åŸå§‹åŠ¨ç”»
  const prev = document.querySelector(".jokerRevealOverlay");
  if (prev) prev.remove();

  const name = game?.players?.[playerIndex]?.name || "";
  const wrap = document.createElement("div");
  wrap.className = "jokerRevealOverlay";
  wrap.innerHTML = `
    <div class="jokerRevealInner">
      <div class="revealStage">
        <div class="revealCard joker imgCard" data-corner="">
          <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" /></div>
        </div>
      </div>
      <div class="revealTo">ç‹å…«ç‰Œ â†’ ${escapeHtml(name)}</div>
    </div>
  `;
  document.body.appendChild(wrap);

  const revealEl = wrap.querySelector(".revealCard");
  if (!revealEl) {
    wrap.remove();
    if (onComplete) onComplete();
    return;
  }

  window.clearTimeout(showJokerRevealAndFly._t);
  showJokerRevealAndFly._t = window.setTimeout(() => {
    try {
      const from = revealEl.getBoundingClientRect();
      const handEl = seatHandElByPlayerIndex(playerIndex);
      const handRect = handEl.getBoundingClientRect();

      // Calculate target position: rightmost card position AFTER joker is added
      const player = game.players[playerIndex];
      const numCards = player ? player.hand.length + 1 : 1; // +1 for joker being added
      let targetX, targetY;

      // Get actual card size first (needed for position calculation)
      let cardWidth, cardHeight;
      if (playerIndex === 0) {
        const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 1;
        cardWidth = 86 * scalePlayer;
        cardHeight = 124 * scalePlayer;
      } else if (playerIndex === 2) {
        const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1;
        cardWidth = 52 * scaleTop;
        cardHeight = 72 * scaleTop;
      } else {
        const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1;
        cardWidth = 64 * scaleSide;
        cardHeight = 89 * scaleSide;
      }

      if (playerIndex === 0) {
        // Bottom player: calculate rightmost card position in fan layout (AFTER joker added)
        const center = (numCards - 1) / 2;
        const maxFanWidth = 920;
        const spread = Math.min(62, maxFanWidth / Math.max(1, numCards - 1));
        const rightmostIdx = numCards - 1;
        const rightmostD = rightmostIdx - center;
        // faceCard positioning: left: 50%, top: 18px, transform: translateX(-50%) translateX(var(--x)) translateY(var(--y))
        // So actual center X = handRect.left + handRect.width/2 + --x
        // Actual center Y = handRect.top + 18 + cardHeight/2 + --y
        const xOffset = rightmostD * spread;
        const yOffset = Math.abs(rightmostD) * 0.8;
        targetX = handRect.left + handRect.width / 2 + xOffset;
        targetY = handRect.top + 18 + cardHeight / 2 + yOffset;
      } else {
        // AI players: calculate tail position in their pile (AFTER joker added)
        const center = (numCards - 1) / 2;
        const tailIdx = numCards - 1;
        const tailD = tailIdx - center;

        if (playerIndex === 2) {
          // Top player: pile spreads left, tail is at left side (positive sx)
          const tailSx = tailD * 12;
          const tailSy = tailD * 0.3;
          targetX = handRect.left + handRect.width / 2 + tailSx;
          targetY = handRect.top + handRect.height / 2 + tailSy;
        } else {
          // Left/right players: pile spreads downward, tail is at bottom
          const tailSx = tailD * 0.3;
          const tailSy = tailD * 9;
          targetX = handRect.left + handRect.width / 2 + tailSx;
          targetY = handRect.top + handRect.height / 2 + tailSy;
        }
      }

      // Build target rect: targetX/targetY are CENTER positions
      // Convert to left/top (top-left corner) for the to object
      const to = {
        left: targetX - cardWidth / 2,
        top: targetY - cardHeight / 2,
        width: cardWidth,
        height: cardHeight
      };

      console.log(`[Joker] Player ${playerIndex}, numCards: ${numCards}, targetX: ${targetX}, targetY: ${targetY}, cardWidth: ${cardWidth}`);

      // ä¸å…‹éš†ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å¡ç‰Œå…ƒç´ 
      // ä» wrap ä¸­åˆ†ç¦» revealElï¼ˆé¿å… wrap.remove() æ—¶ä¸€èµ·åˆ é™¤ï¼‰
      revealEl.remove();
      flyFromRectToRect(from, to, revealEl, playerIndex, onComplete);
      wrap.remove();
    } catch {
      // ignore
      if (onComplete) onComplete();
    }
  }, 720);
}

function showDrawRevealAndFly(game, drawnCard, playerIndex) {
  const msg = $("#message");
  msg.classList.add("revealOnly");

  if (drawnCard.type === "joker") {
    const name = game?.players?.[playerIndex]?.name || "";
    msg.innerHTML = `
      <div class="revealStage">
        <div class="revealCard joker imgCard" data-corner="">
          <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" /></div>
        </div>
      </div>
      <div class="revealTo">ç‹å…«ç‰Œ â†’ ${escapeHtml(name)}</div>
    `;
  } else {
    msg.innerHTML = `
      <div class="revealStage">
        <div class="revealCard" data-corner="">
          <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" /></div>
        </div>
      </div>
    `;
  }

  const revealEl = msg.querySelector(".revealCard");
  if (!revealEl) return;
  // no suit coloring in image mode

  // Fly to the drawer's hand area after a short reveal.
  window.clearTimeout(showDrawRevealAndFly._t);
  showDrawRevealAndFly._t = window.setTimeout(() => {
    try {
      const from = revealEl.getBoundingClientRect();
      const handEl = seatHandElByPlayerIndex(playerIndex);
      const to = handEl.getBoundingClientRect();

      // ä¸å…‹éš†ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å¡ç‰Œå…ƒç´ 
      // ä» msg ä¸­åˆ†ç¦»å‡ºæ¥ï¼ˆé¿å… msg.innerHTML = "" æ—¶ä¸€èµ·æ¸…é™¤ï¼‰
      revealEl.remove();

      // æ¸…é™¤æ¶ˆæ¯åŒºåŸŸçš„å…¶ä»–å†…å®¹
      msg.innerHTML = "";
      msg.classList.remove("revealOnly");

      // é£è¡ŒåŠ¨ç”»
      flyFromRectToRect(from, to, revealEl);
    } catch {
      // ignore
      msg.innerHTML = "";
      msg.classList.remove("revealOnly");
    }
  }, 650);
}

function renderAction(game, settings) {
  const choiceRow = $("#choiceRow");
  const btnTryMatch = $("#btnTryMatch");
  const btnClearSelect = $("#btnClearSelect");
  const btnEndTurn = $("#btnEndTurn");

  if (game.gameOver) {
    choiceRow.classList.add("hidden");
    btnEndTurn.disabled = true;
    return;
  }

  const current = game.players[game.currentPlayerIndex];
  const targetIdx = window.Game.getUpstreamPlayerIndex(game);

  // Choice UI
  const isHumanTurn = current.kind === "human";
  choiceRow.classList.toggle("hidden", !isHumanTurn);
  btnTryMatch.disabled = true;
  btnClearSelect.disabled = true;

  // End turn gating: must draw once before ending
  const canDrawUpstream = window.Game.canDrawFrom(game, targetIdx);
  // è§„åˆ™ï¼šé€šå¸¸éœ€è¦å…ˆæŠ½ç‰Œå†ç»“æŸï¼›ä½†å¦‚æœä¸Šå®¶æ²¡ç‰Œå¯æŠ½ï¼Œåˆ™å…è®¸ç›´æ¥ç»“æŸé¿å…å¡æ­»
  btnEndTurn.disabled = !isHumanTurn || (!game.turnHasDrawn && canDrawUpstream);
}

function showLastEvent(game, settings) {
  const msg = $("#message");
  const ev = game.lastEvent;
  if (!ev) {
    msg.innerHTML = "";
    msg.classList.remove("revealOnly");
    return;
  }

  if (ev.type === "joker_deal") {
    // å‘ç‰Œç»“æŸåï¼šç‹å…«ç‰Œäº®ç›¸ï¼ˆå±å¹•å±…ä¸­ï¼‰ï¼Œç„¶åé£åˆ°æŒ‡å®šç©å®¶æ‰‹ç‰Œ
    msg.innerHTML = "";
    msg.classList.remove("revealOnly");
    showJokerRevealAndFly(game, Math.max(0, ev.playerIndex || 0));
  } else if (ev.type === "draw") {
    // Draw animations are now handled inline during the draw action (with flying card)
    // Only clear the message area here
    msg.innerHTML = "";
    msg.classList.remove("revealOnly");
  } else if (ev.type === "discard_pair") {
    // no text / no TTS
  } else if (ev.type === "mismatch") {
    // No textæç¤º
    msg.innerHTML = "";
  } else {
    msg.innerHTML = "";
  }
}

function renderAll(game, settings) {
  renderSeats(game);
  renderDiscardPile(game);
  renderAction(game, settings);
  showLastEvent(game, settings);
}

function runAiLoop(game, settings) {
  if (!game || game.gameOver) return;
  const current = game.players[game.currentPlayerIndex];
  if (!current) return;
  // If somehow we landed on an "out" player, immediately advance until we reach an active one.
  if (current.out) {
    window.Game.advanceTurn(game);
    renderAll(game, settings);
    return runAiLoop(game, settings);
  }
  if (current.kind !== "ai") return;

  // ç©å®¶å‡ºå±€ååŠ é€ŸAIå¯¹å±€
  const humanPlayer = game.players.find(p => p.kind === "human");
  const speedUpAi = humanPlayer && humanPlayer.out;
  const basePace = speedUpAi ? 200 : settings.aiPaceMs;

  // ğŸ†• å›åˆå¼€å§‹æ—¶å…ˆæ£€æŸ¥æ˜¯å¦æœ‰é…å¯¹ï¼Œå¦‚æœæœ‰åˆ™å…ˆå‡ºç‰Œå†æŠ½ç‰Œ
  const initialPair = window.Game.findAnyPairInHand(current.hand);
  if (initialPair && !game.turnHasDrawn) {
    console.log(`[AIå›åˆå¼€å§‹] AI${game.currentPlayerIndex} å‘ç°åˆå§‹é…å¯¹ï¼Œå…ˆå‡ºç‰Œ`);

    // å»¶è¿Ÿåå¼€å§‹å‡ºç‰Œï¼ˆç»™AIä¸€ä¸ª"æ€è€ƒ"çš„æ—¶é—´ï¼‰
    const initialThinkingDelay = speedUpAi ? 400 : (600 + Math.random() * 400);

    window.clearTimeout(runAiLoop._t);
    runAiLoop._t = window.setTimeout(() => {
      // é€’å½’å‡ºç‰Œç›´åˆ°æ²¡æœ‰é…å¯¹
      const discardAllInitialPairs = () => {
        const pair = window.Game.findAnyPairInHand(current.hand);
        if (!pair) {
          // æ²¡æœ‰é…å¯¹äº†ï¼Œç»§ç»­æ­£å¸¸æŠ½ç‰Œæµç¨‹
          console.log(`[AIå›åˆå¼€å§‹] AI${game.currentPlayerIndex} é…å¯¹å®Œæˆï¼Œå¼€å§‹æŠ½ç‰Œ`);
          proceedToDrawPhase();
          return;
        }

        // å‡ºç‰ŒåŠ¨ç”»ï¼šå…ˆå¯åŠ¨åŠ¨ç”»ï¼Œå®Œæˆåæ‰ç§»é™¤æ‰‹ç‰Œ
        const aiIdx = game.currentPlayerIndex;
        animateAiDiscardPair(aiIdx, pair[0], pair[1], () => {
          // åŠ¨ç”»å®Œæˆåæ‰ç§»é™¤æ‰‹ç‰Œ
          window.Game.tryDiscardPairByCardIds(game, aiIdx, pair[0].id, pair[1].id);
          renderAll(game, settings);

          // æ£€æŸ¥æ˜¯å¦å‡ºå±€
          if (current.out || game.gameOver) {
            window.Game.advanceTurn(game);
            renderAll(game, settings);
            runAiLoop(game, settings);
            return;
          }

          // ç­‰å¾…åç»§ç»­å‡ºä¸‹ä¸€å¯¹
          const thinkingDelay = speedUpAi ? 300 : (800 + Math.random() * 400);
          window.setTimeout(discardAllInitialPairs, thinkingDelay);
        });
      };

      discardAllInitialPairs();
    }, initialThinkingDelay);
    return;
  }

  // æ­£å¸¸æŠ½ç‰Œæµç¨‹
  function proceedToDrawPhase() {
    // AIï¼šä»ä¸Šå®¶æŠ½ä¸€å¼ ï¼ˆä½¿ç”¨æ™ºèƒ½æŠ½ç‰Œé€»è¾‘ï¼‰
    const targetIdx = window.Game.getUpstreamPlayerIndex(game);
    const target = game.players[targetIdx];
    if (!target || target.out || target.hand.length === 0) {
      window.Game.advanceTurn(game);
      renderAll(game, settings);
      return runAiLoop(game, settings);
    }

    // è®¡ç®—AIæŠ½ç‰Œå»¶è¿Ÿï¼ˆæ ¹æ®æ‰‹ç‰Œæ•°é‡å¢åŠ ç´§å¼ æ„Ÿï¼‰
    const aiDrawDelay = speedUpAi ? 200 : window.Game.getAiDrawDelay(game, game.currentPlayerIndex);

    window.clearTimeout(runAiLoop._t);
    runAiLoop._t = window.setTimeout(() => {
      try {
        // ä½¿ç”¨æ™ºèƒ½æŠ½ç‰Œç´¢å¼•ï¼ˆç¬¬ä¸‰æŠŠä¼šä¼˜å…ˆæŠ½JOKERï¼‰
        const idx = window.Game.getAiDrawIndex(game, game.currentPlayerIndex, targetIdx);
        const drawnCard = target.hand[idx];
        const isJoker = drawnCard && drawnCard.type === "joker";
        const currentIdx = game.currentPlayerIndex;

        if (isJoker) {
          // Joker: fly to center, reveal, then to AI hand
          animateJokerDrawReveal(targetIdx, currentIdx, () => {
            // After animation, execute the draw
            window.Game.drawCard(game, targetIdx, idx);
            renderAll(game, settings);

            // Continue AI turn: discard pairs with animation
            continueAiTurnAfterDraw();
          });
        } else {
          // Normal card: fly directly to AI hand
          animateDrawCardFly(targetIdx, currentIdx, drawnCard, () => {
            // After animation, execute the draw
            window.Game.drawCard(game, targetIdx, idx);
            renderAll(game, settings);

            // Continue AI turn: discard pairs with animation
            continueAiTurnAfterDraw();
          });
        }

        function continueAiTurnAfterDraw() {
          window.setTimeout(() => {
            try {
              // AI auto-discard all pairs it can find (with animations)
              const discardNextPair = () => {
                if (game.gameOver) {
                  // Game ended, just run next loop
                  renderAll(game, settings);
                  runAiLoop(game, settings);
                  return;
                }

                const currentPlayer = game.players[game.currentPlayerIndex];
                const pair = window.Game.findAnyPairInHand(currentPlayer.hand);
                if (!pair) {
                  // No more pairs, advance turn
                  if (!game.gameOver) window.Game.advanceTurn(game);
                  renderAll(game, settings);
                  runAiLoop(game, settings);
                  return;
                }

                // Animate discard, then execute and continue
                const aiIdx = game.currentPlayerIndex;
                animateAiDiscardPair(aiIdx, pair[0], pair[1], () => {
                  // åŠ¨ç”»å®Œæˆåæ‰ç§»é™¤æ‰‹ç‰Œ
                  window.Game.tryDiscardPairByCardIds(
                    game,
                    aiIdx,
                    pair[0].id,
                    pair[1].id
                  );
                  renderAll(game, settings);

                  // Wait a bit before next pair (800-1200ms random to simulate human thinking)
                  const thinkingDelay = 800 + Math.random() * 400;
                  window.setTimeout(discardNextPair, thinkingDelay);
                });
              };

              discardNextPair();
            } catch {
              // ignore
            }
          }, isJoker ? Math.max(basePace, 1200) : basePace);
        }
      } catch {
        // ignore
      }
    }, aiDrawDelay); // ä½¿ç”¨åŠ¨æ€è®¡ç®—çš„å»¶è¿Ÿæ—¶é—´
  }

  // å¦‚æœæ²¡æœ‰åˆå§‹é…å¯¹ï¼Œç›´æ¥è¿›å…¥æŠ½ç‰Œé˜¶æ®µ
  proceedToDrawPhase();
}

function initUi(imagePairs = []) {
  const settings = {
    showBothOnDraw: true,
    autoAdvanceMs: 0,
    aiPaceMs: 650,
  };

  const autoNextToggle = $("#autoNextToggle");
  const pairCountInput = $("#pairCount");
  const pairCountNum = $("#pairCountNum");
  const pairCountLabel = $("#pairCountLabel");
  const totalCardLabel = $("#totalCardLabel");
  const btnStart = $("#btnStart");
  const btnRestart = $("#btnRestart");
  const btnTryMatch = $("#btnTryMatch");
  const btnClearSelect = $("#btnClearSelect");
  const btnEndTurn = $("#btnEndTurn");
  const btnHintImg = $("#btnHintImg");
  const btnMatchImg = $("#btnMatchImg");
  const btnEndTurnImg = $("#btnEndTurnImg");
  const endOverlay = $("#endOverlay");
  const endTitle = $("#endTitle");
  const endSubtitle = $("#endSubtitle");
  const btnPlayAgain = $("#btnPlayAgain");
  const btnBackToSetup = $("#btnBackToSetup");
  const btnTune = $("#btnTune");
  const tunerPanel = $("#tunerPanel");
  const btnTuneClose = $("#btnTuneClose");
  const btnTuneReset = $("#btnTuneReset");
  const btnTuneImport = $("#btnTuneImport");
  const btnTuneCopy = $("#btnTuneCopy");
  const tunerControls = $("#tunerControls");
  const drawOverlay = $("#drawOverlay");
  const drawRow = $("#drawRow");
  const btnDrawClose = $("#btnDrawClose");
  const drawOverlayInner = drawOverlay.querySelector(".drawOverlayInner");
  const drawScroll = $("#drawScroll");
  const drawThumb = $("#drawThumb");
  // Hook for scrollbar recalculation (assigned in the scroll-sync IIFE below).
  let recalcDrawScrollSoon = null;
  // Draw overlay scrollbar: thumb appears as full bar then shrinks along the card "spread" timeline.
  let drawThumbAnimRaf = null;
  let drawThumbFinalWPercent = 100;

  let game = null;
  let selected = [];
  let lastHumanActionAt = 0;
  let hintT = null;
  let lastTurnPlayerId = null;
  let isDealing = false;
  let suppressHandClickUntil = 0;

  function advancePastOutPlayers() {
    if (!game || game.gameOver) return;
    // If the current player is out, immediately advance until reaching an active one.
    let guard = 0;
    while (!game.gameOver && game.players[game.currentPlayerIndex]?.out && guard++ < 10) {
      window.Game.advanceTurn(game);
    }
  }

  const HINT_MS = 3000;
  const LAYOUT_KEY = "oldmaid_layout_v1";

  const DEFAULT_LAYOUT = {
    top: { left: 32.8, top: -2.8, width: 34.5, height: 8 },
    left: { left: -2.2, top: 37.2, width: 15, height: 8 },
    right: { left: 74.1, top: 37.2, width: 41, height: 8 },
    bottom: { left: 19.7, top: 61.6, width: 62, height: 25 },
    center: { left: 30.5, top: 22.2, width: 40, height: 20 },
    buttons: {
      hint: { x: 0, y: 14 },
      match: { x: 3, y: 14 },
      endturn: { x: 6, y: 14 },
    },
    scales: {
      playerCard: 0.85,
      aiTopCard: 1.29,
      aiSideCard: 1.25,
      uiButtons: 0.84,
      discardPile: 0.82,
    },
  };

  function getZones() {
    return {
      top: document.querySelector(".zone-top"),
      left: document.querySelector(".zone-left"),
      right: document.querySelector(".zone-right"),
      bottom: document.querySelector(".zone-bottom"),
      center: document.querySelector(".zone-center"),
    };
  }

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }

  function clampToStep(n, min, max, step) {
    const clamped = clamp(n, min, max);
    const stepped = Math.round(clamped / step) * step;
    // Avoid floating point noise for 0.5 steps etc.
    return Number(stepped.toFixed(3));
  }

  function parseMaybeDecimal(raw) {
    if (raw == null) return NaN;
    const s = String(raw).trim().replace(",", ".");
    // Keep only first valid numeric token
    const m = s.match(/-?\d+(\.\d+)?/);
    return m ? Number(m[0]) : NaN;
  }

  function loadLayout() {
    try {
      const raw = localStorage.getItem(LAYOUT_KEY);
      const clone = (o) => JSON.parse(JSON.stringify(o));
      if (!raw) return clone(DEFAULT_LAYOUT);
      const parsed = JSON.parse(raw);
      // Deep-merge for buttons and cardSizes
      const merged = { ...clone(DEFAULT_LAYOUT), ...parsed };
      merged.buttons = { ...clone(DEFAULT_LAYOUT).buttons, ...(parsed.buttons || {}) };
      merged.buttons.hint = { x: 0, y: 0, ...(merged.buttons.hint || {}) };
      merged.buttons.match = { x: 0, y: 0, ...(merged.buttons.match || {}) };
      merged.buttons.endturn = { x: 0, y: 0, ...(merged.buttons.endturn || {}) };
      merged.scales = { ...clone(DEFAULT_LAYOUT).scales, ...(parsed.scales || {}) };
      return merged;
    } catch {
      return JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
    }
  }

  function saveLayout(layout) {
    try {
      localStorage.setItem(LAYOUT_KEY, JSON.stringify(layout));
    } catch {
      // ignore
    }
  }

  function applyLayout(layout) {
    const zones = getZones();
    for (const key of Object.keys(zones)) {
      const el = zones[key];
      const v = layout[key];
      if (!el || !v) continue;
      const left = clamp(Number(v.left), -10, 95);
      const top = clamp(Number(v.top), -10, 95);
      const width = clamp(Number(v.width), 8, 95);
      const height = clamp(Number(v.height), 8, 80);
      el.style.left = `${left}%`;
      el.style.top = `${top}%`;
      el.style.width = `${width}%`;
      el.style.height = `${height}%`;
    }

    // Button offsets
    const btns = layout.buttons || {};
    const applyBtn = (el, cfg) => {
      if (!el || !cfg) return;
      const x = clamp(Number(cfg.x), -260, 260);
      const y = clamp(Number(cfg.y), -180, 180);
      el.style.setProperty("--btnX", `${x}px`);
      el.style.setProperty("--btnY", `${y}px`);
    };
    applyBtn(btnHintImg, btns.hint);
    applyBtn(btnMatchImg, btns.match);
    applyBtn(btnEndTurnImg, btns.endturn);

    // Apply scales
    const scales = layout.scales || {};
    document.documentElement.style.setProperty("--scale-player-card", String(clamp(scales.playerCard || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-ai-top-card", String(clamp(scales.aiTopCard || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-ai-side-card", String(clamp(scales.aiSideCard || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-ui-buttons", String(clamp(scales.uiButtons || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-discard-pile", String(clamp(scales.discardPile || 1.0, 0.5, 2.0)));
  }

  function buildTunerUI(layout) {
    tunerControls.innerHTML = "";
    const groups = [
      ["top", "ä¸Šæ–¹AI"],
      ["left", "å·¦ä¾§AI"],
      ["right", "å³ä¾§AI"],
      ["bottom", "ç©å®¶æ‰‹ç‰Œ"],
      ["center", "å¼ƒç‰Œå †"],
    ];

    function addSlider(groupKey, prop, min, max, step) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = `${prop}(%)`;

      const input = document.createElement("input");
      input.type = "range";
      input.min = String(min);
      input.max = String(max);
      input.step = String(step);
      input.value = String(layout[groupKey][prop]);

      const num = document.createElement("input");
      // Use text input for better decimal keyboard support on mobile (number often hides '.')
      num.type = "text";
      num.className = "tunerNum";
      num.min = String(min);
      num.max = String(max);
      num.step = String(step);
      num.value = String(layout[groupKey][prop]);
      num.inputMode = "decimal";
      num.autocomplete = "off";
      num.spellcheck = false;

      const applyFromRange = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout[groupKey][prop] = n;
        input.value = String(n);
        // Keep number box in sync when slider is used
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextLive = () => {
        // While typing, don't rewrite the text box (so "1." / "-"/ "." can be typed).
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, min, max);
        layout[groupKey][prop] = n;
        input.value = String(n); // range will snap to its step
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextCommit = () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout[groupKey][prop] = n;
        input.value = String(n);
        num.value = String(n); // normalize on commit
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", applyFromRange);
      num.addEventListener("input", applyFromTextLive);
      num.addEventListener("change", applyFromTextCommit);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    function addPxSlider(buttonKey, prop, min, max, step) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = `${prop.toUpperCase()}(px)`;

      const input = document.createElement("input");
      input.type = "range";
      input.min = String(min);
      input.max = String(max);
      input.step = String(step);
      input.value = String(layout.buttons[buttonKey][prop]);

      const num = document.createElement("input");
      // Use text input for consistent keyboard and allow '.' / ',' on mobile
      num.type = "text";
      num.className = "tunerNum";
      num.min = String(min);
      num.max = String(max);
      num.step = String(step);
      num.value = String(layout.buttons[buttonKey][prop]);
      num.inputMode = "decimal";
      num.autocomplete = "off";
      num.spellcheck = false;

      const applyFromRange = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout.buttons[buttonKey][prop] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextLive = () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, min, max);
        layout.buttons[buttonKey][prop] = n;
        input.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextCommit = () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout.buttons[buttonKey][prop] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", applyFromRange);
      num.addEventListener("input", applyFromTextLive);
      num.addEventListener("change", applyFromTextCommit);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    for (const [key, title] of groups) {
      const g = document.createElement("div");
      g.className = "tunerGroup";
      const t = document.createElement("div");
      t.className = "tunerGroupTitle";
      t.textContent = title;
      g.appendChild(t);

      // Use finer steps so decimal tuning doesn't "snap back" on blur/close.
      g.appendChild(addSlider(key, "left", -10, 95, 0.1));
      g.appendChild(addSlider(key, "top", -10, 95, 0.1));
      g.appendChild(addSlider(key, "width", 8, 95, 0.1));
      g.appendChild(addSlider(key, "height", 8, 80, 0.1));
      tunerControls.appendChild(g);
    }

    // Button controls
    const btnGroup = document.createElement("div");
    btnGroup.className = "tunerGroup";
    const bt = document.createElement("div");
    bt.className = "tunerGroupTitle";
    bt.textContent = "æŒ‰é’®ä½ç§»ï¼ˆåƒç´ ï¼‰";
    btnGroup.appendChild(bt);

    const mkSub = (name) => {
      const t = document.createElement("div");
      t.style.marginTop = "8px";
      t.style.fontWeight = "900";
      t.style.fontSize = "12px";
      t.style.opacity = "0.9";
      t.textContent = name;
      return t;
    };

    btnGroup.appendChild(mkSub("æç¤º"));
    btnGroup.appendChild(addPxSlider("hint", "x", -260, 260, 1));
    btnGroup.appendChild(addPxSlider("hint", "y", -180, 180, 1));

    btnGroup.appendChild(mkSub("åŒ¹é…å‡ºç‰Œ"));
    btnGroup.appendChild(addPxSlider("match", "x", -260, 260, 1));
    btnGroup.appendChild(addPxSlider("match", "y", -180, 180, 1));

    btnGroup.appendChild(mkSub("ç»“æŸå›åˆ"));
    btnGroup.appendChild(addPxSlider("endturn", "x", -260, 260, 1));
    btnGroup.appendChild(addPxSlider("endturn", "y", -180, 180, 1));

    tunerControls.appendChild(btnGroup);

    // Scales group
    const scaleGroup = document.createElement("div");
    scaleGroup.className = "tunerGroup";
    const scaleTitle = document.createElement("div");
    scaleTitle.className = "tunerGroupTitle";
    scaleTitle.textContent = "å¡ç‰Œä¸æŒ‰é’®ç¼©æ”¾";
    scaleGroup.appendChild(scaleTitle);

    function addScaleSlider(scaleKey, label) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = label;

      const input = document.createElement("input");
      input.type = "range";
      input.min = "0.5";
      input.max = "2.0";
      input.step = "0.01";
      input.value = String(layout.scales[scaleKey]);

      const num = document.createElement("input");
      num.type = "text";
      num.className = "tunerNum";
      num.value = String(layout.scales[scaleKey]);
      num.inputMode = "decimal";

      const apply = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, 0.5, 2.0, 0.01);
        layout.scales[scaleKey] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", apply);
      num.addEventListener("input", () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, 0.5, 2.0);
        layout.scales[scaleKey] = n;
        input.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      });
      num.addEventListener("change", apply);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    scaleGroup.appendChild(addScaleSlider("playerCard", "ç©å®¶æ‰‹ç‰Œ"));
    scaleGroup.appendChild(addScaleSlider("aiTopCard", "AIä¸Šå®¶"));
    scaleGroup.appendChild(addScaleSlider("aiSideCard", "AIå·¦å³"));
    scaleGroup.appendChild(addScaleSlider("discardPile", "å¼ƒç‰Œå †"));
    scaleGroup.appendChild(addScaleSlider("uiButtons", "UIæŒ‰é’®"));

    tunerControls.appendChild(scaleGroup);
  }

  // Init layout tuning
  let layout = loadLayout();
  applyLayout(layout);
  buildTunerUI(layout);

  function updateTuneButtonState() {
    const gameEl = $("#game");
    btnTune.disabled = gameEl.classList.contains("hidden");
    if (btnTune.disabled) tunerPanel.classList.add("hidden");
  }
  updateTuneButtonState();

  function clearHintHighlight() {
    const cards = Array.from($("#pBottomHand").querySelectorAll(".faceCard"));
    for (const el of cards) {
      el.classList.remove("hintPulse");
      el.classList.remove("hintPulseAuto");
    }
  }

  function maybeShowHint(isAuto = false) {
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;

    const pair = window.Game.findAnyPairInHand(game.players[0].hand);
    if (!pair) return;

    const a = pair[0].id;
    const b = pair[1].id;

    if (isAuto) {
      // è‡ªåŠ¨æç¤ºï¼šåªæ˜¾ç¤ºå‘¼å¸ç¼©æ”¾åŠ¨ç”»ï¼Œä¸é€‰ä¸­
      const aEl = $("#pBottomHand").querySelector(
        `.faceCard[data-card-id="${CSS.escape(a)}"]`
      );
      const bEl = $("#pBottomHand").querySelector(
        `.faceCard[data-card-id="${CSS.escape(b)}"]`
      );
      for (const el of [aEl, bEl]) {
        if (!el) continue;
        el.classList.add("hintPulseAuto");
      }
    } else {
      // æ‰‹åŠ¨æç¤ºï¼šè‡ªåŠ¨é€‰ä¸­ä¸¤å¼ ç‰Œï¼ˆå¼¹å‡ºæ•ˆæœï¼‰
      selected = [a, b];
      renderSelectionHighlights();
      syncSelectionUi();
    }
  }

  function scheduleHintFromNow() {
    if (hintT) return; // already scheduled for current inactivity window
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;
    if (!window.Game.findAnyPairInHand(game.players[0].hand)) return;

    const stamp = lastHumanActionAt;
    hintT = window.setTimeout(() => {
      // If user acted since scheduling, do nothing.
      if (lastHumanActionAt !== stamp) return;
      maybeShowHint(true); // è‡ªåŠ¨æç¤ºæ ‡è®°ä¸º true
    }, HINT_MS);
  }

  function markHumanAction() {
    lastHumanActionAt = Date.now();
    clearHintHighlight();
    window.clearTimeout(hintT);
    hintT = null;
    scheduleHintFromNow();
  }

  // Ensure slider max matches available pairs, and clamp current value.
  if (Array.isArray(imagePairs) && imagePairs.length > 0) {
    pairCountInput.max = String(imagePairs.length);
    pairCountNum.max = String(imagePairs.length);
    if (Number(pairCountInput.value) > imagePairs.length) {
      pairCountInput.value = String(imagePairs.length);
      pairCountNum.value = String(imagePairs.length);
    }
  }

  function syncSettings() {
    settings.autoAdvanceMs = 0; // no longer used for turn flow
    settings.aiPaceMs = autoNextToggle.checked ? 650 : 9999999;

    const pc = Number(pairCountInput.value);
    pairCountNum.value = String(pc);
    pairCountLabel.textContent = String(pc);
    // image mode: 2 cards per pair + 1 joker
    totalCardLabel.textContent = String(pc * 2 + 1);
  }

  function pickPairs(n) {
    const arr = imagePairs.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, Math.max(1, Math.min(n, arr.length)));
  }

  function startNewGame() {
    syncSettings();
    const pairCount = Number(pairCountInput.value);
    const pickedPairs = pickPairs(pairCount);
    game = window.Game.createGame({
      pairs: pickedPairs,
      playerCount: 4,
      seed: String(Date.now()),
    });
    $("#setup").classList.add("hidden");
    $("#game").classList.remove("hidden");
    endOverlay.classList.add("hidden");
    updateTuneButtonState();
    selected = [];
    // Deal animation: render seats, then slide cards in from bottom with delays (no opacity changes).
    isDealing = true;
    renderSeats(game, { deal: true });
    renderDiscardPile(game);
    renderAction(game, settings);
    showLastEvent(game, settings);

    const allFace = Array.from(document.querySelectorAll("#pBottomHand .faceCard"));
    const aiBacks = Array.from(document.querySelectorAll(".seatHand .miniBack"));
    // Init state (AI uses simple fade-in; human uses composited transform animation)
    for (const el of aiBacks) el.classList.add("dealInit");

    // Compute delays: player cards left->right (idx asc).
    const base = 18;
    const stepHuman = 22;
    for (const el of allFace) {
      const idx = Number(el.dataset.dealIndex || 0);
      el.style.animationDelay = `${base + idx * stepHuman}ms`;
    }
    // AI: simple stagger per seat
    const stepAi = 18;
    for (const el of aiBacks) {
      const idx = Number(el.dataset.dealIndex || 0);
      el.style.transitionDelay = `${base + 80 + idx * stepAi}ms`;
    }

    // Trigger in next frame
    window.requestAnimationFrame(() => {
      for (const el of allFace) el.classList.add("dealAnim");
      for (const el of aiBacks) el.classList.add("dealIn");
    });

    // è®¡ç®—æœ€åä¸€å¼ ç©å®¶æ‰‹ç‰ŒåŠ¨ç”»å®Œæˆçš„æ—¶é—´ï¼ˆä¸åŒ…æ‹¬æ¸…ç†ç¼“å†²ï¼‰
    const lastCardCompleteMs = base + (allFace.length - 1) * stepHuman + 420;
    // å®Œæ•´çš„æ¸…ç†æ—¶é—´ï¼ˆåŒ…æ‹¬ç¼“å†²ï¼‰
    const totalMs = base + allFace.length * stepHuman + 420 + 120;

    // å®šä¹‰å¤„ç†å‡½æ•°
    function handleJokerThenPairs() {
      if (game?.jokerPending) {
        // å…ˆå‘JOKER
        const toIdx = Math.floor(Math.random() * game.players.length);
        game.lastEvent = null;

        renderSeats(game);
        renderDiscardPile(game);
        renderAction(game, settings);

        showJokerRevealAndFly(game, toIdx, () => {
          window.Game.dealPendingJokerToPlayer(game, toIdx);
          game.lastEvent = null;
          renderSeats(game, { animateExpand: true });
          renderDiscardPile(game);
          renderAction(game, settings);

          // JOKERå‘ç‰Œå®Œæˆåï¼Œç­‰å¾…1.5ç§’ï¼Œç„¶åå¼€å§‹æ‰€æœ‰ç©å®¶çš„é…å¯¹åŠ¨ç”»
          console.log("[JOKERå‘ç‰Œå®Œæˆ] ç­‰å¾…1.5ç§’åå¼€å§‹é…å¯¹...");
          setTimeout(() => {
            startInitialPairingAnimation();
          }, 1500);
        });
      } else {
        // æ²¡æœ‰JOKERï¼Œç›´æ¥å¼€å§‹é…å¯¹
        startInitialPairingAnimation();
      }
    }

    function startInitialPairingAnimation() {
      // ğŸ†• ç¬¬ä¸€æ­¥ï¼šåœ¨ç§»é™¤é…å¯¹ä¹‹å‰ï¼Œå…ˆä¿å­˜æ‰€æœ‰AIæ‰‹ç‰Œçš„ä½ç½®
      console.log("[å¼€å§‹é…å¯¹] æ­¥éª¤1ï¼šä¿å­˜æ‰€æœ‰AIæ‰‹ç‰Œä½ç½®...");
      const handPositions = {};
      for (let pi = 1; pi < game.players.length; pi++) {
        const handEl = seatHandElByPlayerIndex(pi);
        if (handEl) {
          // ä½¿ç”¨çˆ¶çº§ .zone çš„rectï¼Œå› ä¸º .seatHand çš„é«˜åº¦å¯èƒ½ä¸º0
          const zoneEl = handEl.parentElement;
          const rect = zoneEl ? zoneEl.getBoundingClientRect() : handEl.getBoundingClientRect();
          handPositions[pi] = rect;
          console.log(`[é…å¯¹åŠ¨ç”»] AI${pi} åŸå§‹ä½ç½®(ä½¿ç”¨zone):`, rect);
        }
      }

      // ç¬¬äºŒæ­¥ï¼šæ”¶é›†æ‰€æœ‰ç©å®¶çš„åˆå§‹é…å¯¹ï¼ˆä½†ä¸ç§»é™¤æ‰‹ç‰Œï¼ï¼‰
      console.log("[å¼€å§‹é…å¯¹] æ­¥éª¤2ï¼šæ”¶é›†é…å¯¹ç‰Œä¿¡æ¯...");
      const pairsByPlayer = {}; // { playerIdx: [{card1, card2}, ...] }

      for (let pi = 1; pi < game.players.length; pi++) {
        const player = game.players[pi];
        if (player && !player.out) {
          // åˆ›å»ºæ‰‹ç‰Œçš„å‰¯æœ¬ï¼Œç”¨äºæŸ¥æ‰¾é…å¯¹ï¼ˆä¸å½±å“åŸå§‹æ‰‹ç‰Œï¼‰
          const handCopy = [...player.hand];
          const pairs = [];

          while (handCopy.length > 0) {
            const pair = window.Game.findAnyPairInHand(handCopy);
            if (!pair) break;

            // ä¿å­˜é…å¯¹ä¿¡æ¯ï¼ˆå¼•ç”¨åŸå§‹å¡ç‰Œå¯¹è±¡ï¼‰
            const originalCard1 = player.hand.find(c => c.id === pair[0].id);
            const originalCard2 = player.hand.find(c => c.id === pair[1].id);

            if (originalCard1 && originalCard2) {
              pairs.push({ card1: originalCard1, card2: originalCard2 });
            }

            // ä»å‰¯æœ¬ä¸­ç§»é™¤è¿™ä¸€å¯¹ï¼ˆé¿å…é‡å¤æŸ¥æ‰¾ï¼‰
            const idx1 = handCopy.findIndex(c => c.id === pair[0].id);
            const idx2 = handCopy.findIndex(c => c.id === pair[1].id);
            if (idx1 >= 0) handCopy.splice(idx1, 1);
            if (idx2 >= 0) handCopy.splice(idx2, 1);
          }

          if (pairs.length > 0) {
            pairsByPlayer[pi] = pairs;
            console.log(`[å‘ç‰Œç»“æŸ] AI${pi} æ‰¾åˆ° ${pairs.length} å¯¹ç‰Œï¼ˆæœªç§»é™¤ï¼‰`);
          }
        }
      }

      // æŒ‰AIé¡ºåºæ’­æ”¾é…å¯¹åŠ¨ç”»
      const playerIndices = Object.keys(pairsByPlayer).map(Number).sort((a, b) => a - b);

      if (playerIndices.length > 0) {
        console.log(`[å‘ç‰Œç»“æŸ] å°†æŒ‰AIé¡ºåºæ’­æ”¾é…å¯¹åŠ¨ç”»`);

        // âš ï¸ ä¸è¦å…ˆæ›´æ–°UIï¼éœ€è¦å…ˆè·å–åŸå§‹æ‰‹ç‰Œä½ç½®ï¼ŒåŠ¨ç”»å®Œæˆåå†æ›´æ–°
        // renderSeats(game);
        // renderDiscardPile(game);

        let totalAnimsCompleted = 0;
        let totalAnimsExpected = 0;
        playerIndices.forEach(pi => {
          totalAnimsExpected += pairsByPlayer[pi].length * 2;
        });

        // é€’å½’æ’­æ”¾æ¯ä¸ªAIçš„é…å¯¹
        let currentPlayerIdx = 0;
        let accumulatedDelay = 0;

        function playNextPlayer() {
          if (currentPlayerIdx >= playerIndices.length) {
            // æ‰€æœ‰AIé…å¯¹å®Œæˆ
            console.log("[å‘ç‰Œç»“æŸ] æ‰€æœ‰é…å¯¹åŠ¨ç”»å®Œæˆï¼Œç­‰å¾…ååˆ·æ–°UI");
            setTimeout(() => {
              renderSeats(game);
              renderDiscardPile(game);
              proceedAfterInitialPairs();
            }, 300);
            return;
          }

          const pi = playerIndices[currentPlayerIdx];
          const pairs = pairsByPlayer[pi];
          const aiName = `AI${pi}`;

          // AIæ€è€ƒå»¶è¿Ÿï¼š500-800mséšæœº
          const thinkDelay = 500 + Math.random() * 300;
          console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} æ€è€ƒä¸­... (${Math.round(thinkDelay)}ms)`);

          setTimeout(() => {
            console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} å¼€å§‹å‡ºç‰Œ (${pairs.length}å¯¹)`);

            // ğŸ“ ä½¿ç”¨ä¹‹å‰ä¿å­˜çš„åŸå§‹ä½ç½®
            const originalFromRect = handPositions[pi];
            if (!originalFromRect) {
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} é”™è¯¯ï¼šæ²¡æœ‰ä¿å­˜çš„åŸå§‹ä½ç½®`);
              currentPlayerIdx++;
              playNextPlayer();
              return;
            }

            // é€’å½’æ’­æ”¾è¯¥AIçš„æ¯ä¸€å¯¹ç‰Œ
            let pairIdx = 0;

            function playNextPair() {
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} playNextPair, pairIdx=${pairIdx}, total=${pairs.length}`);
              if (pairIdx >= pairs.length) {
                // è¯¥AIçš„æ‰€æœ‰é…å¯¹å®Œæˆï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªAI
                console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} æ‰€æœ‰é…å¯¹å®Œæˆ`);
                currentPlayerIdx++;
                playNextPlayer();
                return;
              }

              const pair = pairs[pairIdx];
              const player = game.players[pi];

              // ä½¿ç”¨æœ€å¼€å§‹ä¿å­˜çš„åŸå§‹ä½ç½®ï¼ˆåœ¨ä»»ä½•ç§»é™¤æ“ä½œä¹‹å‰ï¼Œ2497è¡Œä¿å­˜çš„ï¼‰
              // è¿™ä¸ªä½ç½®æ˜¯æ‰‹ç‰Œå®Œæ•´æ—¶çš„ä½ç½®ï¼Œé«˜åº¦æ­£ç¡®
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} ä½¿ç”¨åŸå§‹ä¿å­˜ä½ç½®:`, originalFromRect);

              // ä»æ‰‹ç‰Œä¸­ç§»é™¤è¿™ä¸€å¯¹
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} ç§»é™¤é…å¯¹ ${pairIdx + 1}/${pairs.length}`);
              const idx1 = player.hand.findIndex(c => c.id === pair.card1.id);
              const idx2 = player.hand.findIndex(c => c.id === pair.card2.id);
              if (idx1 >= 0) player.hand.splice(idx1, 1);
              if (idx2 >= 0) player.hand.splice(idx2, 1);
              game.discardPile.push(pair.card1, pair.card2);
              player.out = player.hand.length === 0;

              // æ›´æ–°æ‰‹ç‰Œæ˜¾ç¤ºï¼ˆç§»é™¤åçš„çŠ¶æ€ï¼‰
              renderSeats(game);

              // è°ƒç”¨åŠ¨ç”»ï¼Œä¼ å…¥åŸå§‹ä¿å­˜çš„ä½ç½®
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} å¼€å§‹æ’­æ”¾åŠ¨ç”» pair ${pairIdx + 1}`);
              animateAiDiscardPair(pi, pair.card1, pair.card2, originalFromRect, () => {
                console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} åŠ¨ç”»å®Œæˆ pair ${pairIdx + 1}`);

                // åŠ¨ç”»å®Œæˆåæ‰ä»æ‰‹ç‰Œä¸­ç§»é™¤è¿™ä¸€å¯¹
                const idx1 = player.hand.findIndex(c => c.id === pair.card1.id);
                const idx2 = player.hand.findIndex(c => c.id === pair.card2.id);
                if (idx1 >= 0) player.hand.splice(idx1, 1);
                if (idx2 >= 0) player.hand.splice(idx2, 1);
                game.discardPile.push(pair.card1, pair.card2);
                player.out = player.hand.length === 0;

                // æ›´æ–°UI
                renderSeats(game);
                renderDiscardPile(game);

                // å»¶è¿Ÿåå‡ºä¸‹ä¸€å¯¹
                pairIdx++;
                if (pairIdx < pairs.length) {
                  const pairDelay = 800 + Math.random() * 400;
                  setTimeout(() => {
                    playNextPair();
                  }, pairDelay);
                } else {
                  // è¯¥AIæ‰€æœ‰ç‰Œå‡ºå®Œï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªAI
                  currentPlayerIdx++;
                  playNextPlayer();
                }
              });

            }

            // å¼€å§‹æ’­æ”¾è¯¥AIçš„ç¬¬ä¸€å¯¹
            console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} å‡†å¤‡æ’­æ”¾ç¬¬ä¸€å¯¹`);
            playNextPair();
          }, thinkDelay);
        }

        // å¼€å§‹æ’­æ”¾ç¬¬ä¸€ä¸ªAI
        playNextPlayer();
      } else {
        // æ²¡æœ‰åˆå§‹é…å¯¹ï¼Œç›´æ¥ç»§ç»­
        proceedAfterInitialPairs();
      }
    }

    function proceedAfterInitialPairs() {
      // é…å¯¹å®Œæˆï¼Œå¼€å§‹æ¸¸æˆ
      renderAll(game, settings);
      runAiLoop(game, settings);
    }

    // åœ¨æœ€åä¸€å¼ å¡åŠ¨ç”»å®Œæˆæ—¶ç«‹å³è§¦å‘Jokerç‰¹æ•ˆ
    window.setTimeout(() => {
      handleJokerThenPairs();
    }, lastCardCompleteMs);

    // ç¨åå†è¿›è¡Œæ¸…ç†
    window.setTimeout(() => {
      // Cleanup
      for (const el of [...allFace, ...aiBacks]) {
        el.classList.remove("dealAnim");
        el.style.animationDelay = "";
        el.style.transitionDelay = "";
        // keep AI fade classes removed as well
        el.classList.remove("dealInit", "dealIn");
      }
      isDealing = false;
      lastTurnPlayerId = game.players[game.currentPlayerIndex]?.id || null;
      markHumanAction();
    }, totalMs);
    lastTurnPlayerId = game.players[game.currentPlayerIndex]?.id || null;
    markHumanAction(); // start the 8s timer baseline if it's your turn
  }

  autoNextToggle.addEventListener("change", syncSettings);
  pairCountInput.addEventListener("input", syncSettings);
  pairCountNum.addEventListener("input", () => {
    const min = Number(pairCountInput.min || 1);
    const max = Number(pairCountInput.max || 999);
    const step = Number(pairCountInput.step || 1);
    const pc = clampToStep(Number(pairCountNum.value), min, max, step);
    pairCountInput.value = String(pc);
    syncSettings();
  });
  pairCountNum.addEventListener("change", () => {
    // Normalize on blur/enter
    const min = Number(pairCountInput.min || 1);
    const max = Number(pairCountInput.max || 999);
    const step = Number(pairCountInput.step || 1);
    const pc = clampToStep(Number(pairCountNum.value), min, max, step);
    pairCountNum.value = String(pc);
    pairCountInput.value = String(pc);
    syncSettings();
  });

  btnStart.addEventListener("click", startNewGame);
  btnRestart.addEventListener("click", () => {
    $("#game").classList.add("hidden");
    $("#setup").classList.remove("hidden");
    $("#message").innerHTML = "";
    game = null;
    selected = [];
    window.clearTimeout(hintT);
    hintT = null;
    window.clearTimeout(runAiLoop._t);
    runAiLoop._t = null;
    endOverlay.classList.add("hidden");
    updateTuneButtonState();
  });

  btnPlayAgain.addEventListener("click", () => {
    startNewGame();
  });

  btnBackToSetup.addEventListener("click", () => {
    btnRestart.click();
  });

  btnTune.addEventListener("click", () => {
    if (btnTune.disabled) return;
    tunerPanel.classList.toggle("hidden");
  });
  btnTuneClose.addEventListener("click", () => {
    tunerPanel.classList.add("hidden");
  });
  btnTuneReset.addEventListener("click", () => {
    layout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
    saveLayout(layout);
    applyLayout(layout);
    buildTunerUI(layout);
  });

  btnTuneImport.addEventListener("click", () => {
    const example = JSON.stringify(layout, null, 2);
    const raw = window.prompt("ç²˜è´´å¸ƒå±€ JSONï¼ˆä¼šè¦†ç›–å½“å‰å¸ƒå±€ï¼‰ï¼š", example);
    if (!raw) return;
    try {
      const parsed = JSON.parse(raw);
      const required = ["top", "left", "right", "bottom", "center"];
      for (const k of required) {
        if (!parsed[k]) throw new Error("missing " + k);
        for (const p of ["left", "top", "width", "height"]) {
          if (typeof parsed[k][p] !== "number") throw new Error(`invalid ${k}.${p}`);
        }
      }
      if (parsed.buttons) {
        // Optional
        for (const key of ["hint", "match", "endturn"]) {
          if (parsed.buttons[key]) {
            if (typeof parsed.buttons[key].x !== "number") throw new Error(`invalid buttons.${key}.x`);
            if (typeof parsed.buttons[key].y !== "number") throw new Error(`invalid buttons.${key}.y`);
          }
        }
      }
      layout = parsed;
      if (!layout.buttons) layout.buttons = JSON.parse(JSON.stringify(DEFAULT_LAYOUT.buttons));
      saveLayout(layout);
      applyLayout(layout);
      buildTunerUI(layout);
    } catch (e) {
      alert("å¯¼å…¥å¤±è´¥ï¼šJSON æ ¼å¼æˆ–å­—æ®µä¸å¯¹ã€‚");
    }
  });
  btnTuneCopy.addEventListener("click", async () => {
    const text = JSON.stringify(layout, null, 2);
    try {
      await navigator.clipboard.writeText(text);
      alert("å‚æ•°å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼");
    } catch {
      // Fallback: prompt copy
      const copied = window.prompt("å¤åˆ¶ä¸‹é¢çš„å‚æ•°ï¼ˆCmd+Cï¼‰ï¼š", text);
      if (copied !== null) {
        alert("è¯·æ‰‹åŠ¨å¤åˆ¶ä¸Šé¢çš„å‚æ•°");
      }
    }
  });

  function syncSelectionUi() {
    const isHumanTurn = game && !game.gameOver && game.players[game.currentPlayerIndex].kind === "human";
    const canTry = isHumanTurn && selected.length === 2;
    btnTryMatch.disabled = !canTry;
    btnClearSelect.disabled = !isHumanTurn || selected.length === 0;
  }

  function renderSelectionHighlights() {
    const cards = Array.from($("#pBottomHand").querySelectorAll(".faceCard"));
    for (const el of cards) {
      const id = el.dataset.cardId;
      el.classList.toggle("selected", selected.includes(id));
    }
  }

  function clearSelection() {
    selected = [];
    renderSelectionHighlights();
    syncSelectionUi();
  }

  // ä¸Šå®¶æ‰‹ç‰ŒåŠ¨ç”»ï¼šç›´æ¥æ‰“å¼€æŠ½ç‰Œç•Œé¢ï¼ˆæ— åŠ¨ç”»ï¼‰
  function animateUpstreamRotateAndOpen(fromIdx) {
    openDrawOverlay(fromIdx);
  }

  function openDrawOverlay(fromIdx) {
    console.log(">>> openDrawOverlay è¢«è°ƒç”¨, fromIdx:", fromIdx);

    if (!game || game.gameOver) {
      console.log(">>> æ¸¸æˆä¸å­˜åœ¨æˆ–å·²ç»“æŸ");
      return;
    }
    advancePastOutPlayers();
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.out || current.kind !== "human") {
      console.log(">>> å½“å‰ç©å®¶ä¸æ˜¯äººç±»æˆ–å·²å‡ºå±€");
      return;
    }
    if (game.turnHasDrawn) {
      console.log(">>> æœ¬å›åˆå·²ç»æŠ½è¿‡ç‰Œäº†");
      return;
    }
    const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
    if (fromIdx !== upstreamIdx) {
      console.log(">>> fromIdx ä¸æ˜¯ä¸Šå®¶:", fromIdx, "!=", upstreamIdx);
      return;
    }
    const target = game.players[fromIdx];
    if (!target || target.out || target.hand.length === 0) {
      console.log(">>> ç›®æ ‡ç©å®¶ä¸å­˜åœ¨æˆ–å·²å‡ºå±€æˆ–æ— ç‰Œ");
      return;
    }

    console.log(">>> å‡†å¤‡è°ƒç”¨ ensureHumanCanMatch");

    // åœ¨æ˜¾ç¤ºæŠ½ç‰Œç•Œé¢å‰ï¼Œæ ¹æ®è¿ç»­æœªåŒ¹é…æ¬¡æ•°å†³å®šæ˜¯å¦ä½œå¼Šæ¢ç‰Œï¼ˆç¬é—´å®Œæˆï¼Œæ— åŠ¨ç”»ï¼‰
    try {
      window.Game.ensureHumanCanMatch(game);
      console.log(">>> ensureHumanCanMatch è°ƒç”¨å®Œæˆ");
    } catch (e) {
      console.error(">>> ensureHumanCanMatch error:", e);
    }

    console.log(">>> æ˜¾ç¤ºæŠ½ç‰Œç•Œé¢");
    drawOverlay.classList.remove("hidden");
    // Restore content visibility (in case it was hidden during animation)
    if (drawOverlayInner) drawOverlayInner.style.opacity = "";
    drawRow.innerHTML = "";
    drawScroll.classList.add("hidden");
    drawThumb.style.setProperty("--thumbW", "100%");
    drawThumb.style.setProperty("--thumbX", "0px");

    // Clamp overlay width to the background table so cards never exceed table edges.
    try {
      const tableBg = document.querySelector(".tableBg");
      if (tableBg && drawOverlayInner) {
        const rect = tableBg.getBoundingClientRect();
        const w = Math.max(320, Math.floor(rect.width));
        drawOverlayInner.style.width = `${w}px`;
        // Also align overlay vertically to the tableBg center (prevents the row looking "too low").
        const tableCy = rect.top + rect.height / 2;
        const viewCy = window.innerHeight / 2;
        const dy = tableCy - viewCy;
        drawOverlayInner.style.transform = `translateY(${Math.round(dy)}px)`;
      }
    } catch {
      // ignore
    }

    // No auto-sizing: drawBack uses fixed CSS size; row can scroll horizontally if needed.
    // Ensure the first card is fully visible by default.
    try {
      drawRow.scrollLeft = 0;
    } catch {
      // ignore
    }

    // ç¦ç”¨è¿‡æ¸¡ghostå¡ç‰ŒåŠ¨ç”»ï¼ˆç›´æ¥æ‰“å¼€æŠ½ç‰Œç•Œé¢ï¼Œæ— è¿‡æ¸¡ï¼‰
    // if (!suppressDrawOverlayGhost) { ... } å·²åˆ é™¤

    // Thumb animation: start as full bar, then shrink to correct width in sync with the "spread" timeline.
    // If the user interacts (wheel/drag), we will instantly finish this animation for max smoothness.
    try { if (drawThumbAnimRaf != null) window.cancelAnimationFrame(drawThumbAnimRaf); } catch { /* ignore */ }
    drawThumbAnimRaf = null;
    drawThumbFinalWPercent = 100;
    drawThumb.style.setProperty("--thumbDur", `0ms`);
    drawThumb.style.setProperty("--thumbW", "100%");
    drawThumb.style.setProperty("--thumbX", "0px");

    for (let i = 0; i < target.hand.length; i++) {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "drawBack";
      b.dataset.fromPlayerIndex = String(fromIdx);
      b.dataset.drawIndex = String(i);
      // "ç å¼€" feel: start overlapped then spread to normal positions.
      b.style.setProperty("--preX", `${-i * 26}px`);
      b.addEventListener("click", () => {
        if (!game || game.gameOver) return;
        advancePastOutPlayers();
        const cur = game.players[game.currentPlayerIndex];
        if (!cur || cur.out || cur.kind !== "human") {
          closeDrawOverlay();
          renderAll(game, settings);
          runAiLoop(game, settings);
          return;
        }
        if (game.turnHasDrawn) return;
        markHumanAction();

        // å®æ—¶æ›¿æ¢æœºåˆ¶ï¼šæ ¹æ®è¿ç»­æœªåŒ¹é…æ¬¡æ•°è°ƒæ•´æ¦‚ç‡ï¼ˆä¸è€ƒè™‘ A/B å¹³è¡¡ï¼‰
        let replaceProbability = 0;
        if (game.humanFirstDrawInGame) {
          replaceProbability = 0.7; // ç¬¬1æ¬¡ï¼š70%
        } else if (game.humanConsecutiveNoMatch === 0) {
          replaceProbability = 0.6; // 60%ï¼ˆä»40%æé«˜ï¼‰
        } else if (game.humanConsecutiveNoMatch === 1) {
          replaceProbability = 0.8; // 80%ï¼ˆä»60%æé«˜ï¼‰
        } else if (game.humanConsecutiveNoMatch >= 2) {
          replaceProbability = 0.95; // 95%ï¼ˆä»85%æé«˜ï¼‰
        }

        const replaceRoll = Math.random();
        const shouldReplace = replaceRoll <= replaceProbability;
        console.log(`[å®æ—¶æ›¿æ¢] consecutiveNoMatch:${game.humanConsecutiveNoMatch} æ¦‚ç‡:${(replaceProbability * 100).toFixed(0)}% éª°å­:${(replaceRoll * 100).toFixed(0)}% è§¦å‘:${shouldReplace}`);

        if (shouldReplace) {
          const drawnCard = target.hand[i];
          const human = game.players[0];

          // æ£€æŸ¥è¿™å¼ ç‰Œæ˜¯å¦å¯ä»¥ä¸ç©å®¶æ‰‹ç‰ŒåŒ¹é…
          const canMatch = drawnCard && drawnCard.pairId &&
            human.hand.some(c => c && c.pairId === drawnCard.pairId && c !== drawnCard);

          if (!canMatch && drawnCard && drawnCard.type !== "joker") {
            console.log(`[å®æ—¶æ›¿æ¢] ç¬¬${i}å¼ ç‰Œä¸å¯åŒ¹é…ï¼Œå¯»æ‰¾æ›¿æ¢...`);

            // ä»å…¶ä»–AIæ‰‹ä¸­æ‰¾ä¸€å¼ å¯åŒ¹é…çš„ç‰Œï¼Œä¼˜å…ˆé€‰æ‹©èƒ½å¹³è¡¡A/Bçš„ç‰Œ
            const humanPairIds = new Set();
            for (const c of human.hand) {
              if (c && c.pairId && c.type !== "joker") {
                humanPairIds.add(c.pairId);
              }
            }

            // è®¡ç®—ç©å®¶æ‰‹ç‰ŒA/Bä¸å¹³è¡¡åº¦
            let aCount = 0, bCount = 0;
            for (const c of human.hand) {
              if (!c || c.type === "joker" || !c.side) continue;
              if (c.side === "A") aCount++;
              else if (c.side === "B") bCount++;
            }
            const diff = aCount - bCount;
            const needSide = diff > 0 ? "B" : (diff < 0 ? "A" : null);
            console.log(`[å¹³è¡¡] ç©å®¶æ‰‹ç‰Œ A:${aCount} B:${bCount} å·®å¼‚:${diff} éœ€è¦:${needSide || "å‡è¡¡"}`);

            // æ”¶é›†æ‰€æœ‰å€™é€‰ç‰Œå¹¶æŒ‰ä¼˜å…ˆçº§æ’åº
            const candidates = [];
            for (let pi = 0; pi < game.players.length; pi++) {
              if (pi === 0 || pi === fromIdx) continue;
              const donor = game.players[pi];
              if (donor.out || donor.hand.length === 0) continue;

              for (let ci = 0; ci < donor.hand.length; ci++) {
                const c = donor.hand[ci];
                if (c && c.pairId && c.type !== "joker" && humanPairIds.has(c.pairId)) {
                  // ä¼˜å…ˆçº§ï¼šèƒ½å¹³è¡¡A/Bçš„ç‰Œä¼˜å…ˆçº§é«˜
                  const priority = (needSide && c.side === needSide) ? 10 : 1;
                  candidates.push({ pi, ci, card: c, priority });
                }
              }
            }

            let replacementFound = false;
            if (candidates.length > 0) {
              // æŒ‰ä¼˜å…ˆçº§æ’åºï¼Œä¼˜å…ˆé€‰æ‹©èƒ½å¹³è¡¡çš„ç‰Œ
              candidates.sort((a, b) => b.priority - a.priority);
              const chosen = candidates[0];

              // ç¬é—´äº¤æ¢
              const temp = target.hand[i];
              target.hand[i] = chosen.card;
              game.players[chosen.pi].hand[chosen.ci] = temp;
              console.log(`[å®æ—¶æ›¿æ¢] æˆåŠŸï¼æ¢å…¥ ${chosen.card.side} ä¾§ç‰Œ ${chosen.card.pairId}ï¼ˆä¼˜å…ˆçº§:${chosen.priority}ï¼‰`);
              replacementFound = true;
            }

            if (!replacementFound) {
              console.log(`[å®æ—¶æ›¿æ¢] æœªæ‰¾åˆ°å¯æ›¿æ¢çš„ç‰Œï¼ˆå…¶ä»–AIæ‰‹é‡Œä¹Ÿæ²¡æœ‰å¯åŒ¹é…çš„äº†ï¼‰`);
            }
          } else {
            console.log(`[å®æ—¶æ›¿æ¢] ç¬¬${i}å¼ ç‰Œå·²å¯åŒ¹é…æˆ–æ˜¯JOKERï¼Œæ— éœ€æ›¿æ¢`);
          }
        } else {
          console.log(`[å®æ—¶æ›¿æ¢] æœªè§¦å‘ï¼ˆè¿æ°”ä¸å¥½ï¼‰`);
        }

        // Get the card that will be drawn (peek before actual draw)
        const drawnCard = target.hand[i];
        const isJoker = drawnCard && drawnCard.type === "joker";

        // ğŸ†• åŸåœ°ç¿»è½¬åŠ¨ç”»ï¼šå¡èƒŒ â†’ æ­£é¢ï¼ˆä¸å…‹éš†ï¼Œç›´æ¥ä¿®æ”¹å½“å‰æŒ‰é’®ï¼‰
        // å°†æŒ‰é’®æ”¹é€ æˆåŒé¢å¡ç»“æ„
        b.disabled = true; // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
        b.style.transformStyle = "preserve-3d";
        b.style.transition = "none"; // æ¸…é™¤ CSS è¿‡æ¸¡

        // åˆ›å»ºæ­£é¢ï¼ˆå¡ç‰Œå†…å®¹ï¼‰- 0degæ—¶å¯è§
        const frontFace = document.createElement("div");
        frontFace.className = `faceCard ${isJoker ? "joker imgCard" : "imgCard"}`;
        frontFace.style.width = "100%";
        frontFace.style.height = "100%";
        frontFace.style.position = "absolute";
        frontFace.style.left = "0";
        frontFace.style.top = "0";
        frontFace.style.backfaceVisibility = "hidden";
        frontFace.style.WebkitBackfaceVisibility = "hidden";
        frontFace.style.transform = "rotateY(0deg)";
        frontFace.style.margin = "0";
        frontFace.style.padding = "10px";
        frontFace.style.boxSizing = "border-box";

        // åˆ›å»ºèƒŒé¢ï¼ˆå¡èƒŒï¼‰- 180degæ—¶å¯è§
        const backFace = document.createElement("div");
        backFace.className = "miniBack";
        backFace.style.width = "100%";
        backFace.style.height = "100%";
        backFace.style.position = "absolute";
        backFace.style.left = "0";
        backFace.style.top = "0";
        backFace.style.backfaceVisibility = "hidden";
        backFace.style.WebkitBackfaceVisibility = "hidden";
        backFace.style.transform = "rotateY(180deg)";

        if (isJoker) {
          frontFace.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
            </div>
          `;
        } else if (drawnCard) {
          frontFace.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" draggable="false" /></div>
            </div>
          `;
        }

        // æ¸…ç©ºæŒ‰é’®å†…å®¹ï¼Œæ·»åŠ åŒé¢ç»“æ„
        b.innerHTML = "";
        b.appendChild(frontFace);
        b.appendChild(backFace);

        // åˆå§‹çŠ¶æ€ï¼šæ˜¾ç¤ºèƒŒé¢ï¼ˆ180degï¼‰
        b.style.transform = "rotateY(180deg)";

        // ç¿»è½¬åŠ¨ç”»ï¼š180deg â†’ 360degï¼ˆæ˜¾ç¤ºæ­£é¢ï¼‰
        const flipAnim = b.animate(
          [
            { transform: "rotateY(180deg)" },
            { transform: "rotateY(360deg)" }
          ],
          { duration: 360, easing: "cubic-bezier(0.4, 0, 0.2, 1)", fill: "forwards" }
        );

        flipAnim.onfinish = () => {
          console.log("[ç¿»è½¬å®Œæˆ] å¼€å§‹è·å–å¡ç‰Œä½ç½®...");
          // ğŸ†• ç¿»è½¬å®Œæˆåï¼Œè·å–å½“å‰å¡ç‰Œçš„å®é™…ä½ç½®ä½œä¸ºé£è¡Œèµ·ç‚¹
          const cardRect = b.getBoundingClientRect();
          const cardStartX = cardRect.left + cardRect.width / 2;
          const cardStartY = cardRect.top + cardRect.height / 2;
          console.log("[ç¿»è½¬å®Œæˆ] å¡ç‰Œä½ç½®:", { x: cardStartX, y: cardStartY });

          // å…³é—­æŠ½ç‰Œç•Œé¢
          console.log("[ç¿»è½¬å®Œæˆ] å…³é—­æŠ½ç‰Œç•Œé¢...");
          closeDrawOverlay();

          if (isJoker) {
            console.log("[ç¿»è½¬å®Œæˆ] æ£€æµ‹åˆ°Jokerï¼Œå¯åŠ¨JokeråŠ¨ç”»");
            // Joker: fly to center, reveal, then to hand
            animateJokerDrawReveal(fromIdx, 0, () => {
              // Execute actual draw after animation completes
              window.Game.drawCard(game, fromIdx, i);
              clearSelection();
              renderAll(game, settings);
            });
          } else {
            console.log("[ç¿»è½¬å®Œæˆ] æ™®é€šå¡ç‰Œï¼Œå¯åŠ¨é£è¡ŒåŠ¨ç”»", { drawnCard, cardStartX, cardStartY });
            // Normal card: fly directly to hand (ä»ç¿»è½¬åçš„å®é™…ä½ç½®å¼€å§‹)
            // ç©å®¶æŠ½ç‰Œï¼Œç›®æ ‡æ˜¯ç´¢å¼•0ï¼ˆäººç±»ç©å®¶ï¼‰
            animateDrawCardFlyFromPoint(cardStartX, cardStartY, 0, drawnCard, () => {
              console.log("[é£è¡Œå®Œæˆ] æ‰§è¡ŒdrawCard...");
              // Execute actual draw
              window.Game.drawCard(game, fromIdx, i);
              clearSelection();
              renderAll(game, settings);
              console.log("[é£è¡Œå®Œæˆ] renderAllå®Œæˆ");
            });
          }
        };
      });
      drawRow.appendChild(b);
      // stagger in
      window.setTimeout(() => {
        b.classList.add("in");

        // è°ƒè¯•ï¼šæ‰“å°ç¬¬ä¸€å¼ å¡çš„ä¸­å¿ƒç‚¹ä½ç½®
        if (i === 0) {
          window.setTimeout(() => {
            const rect = b.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            console.log('æŠ½1å¡ç‰Œä¸­å¿ƒç‚¹ä½ç½®:', { x: centerX, y: centerY, rect });
          }, 500); // ç­‰å¾…å±•å¼€åŠ¨ç”»å®Œæˆ
        }
      }, 30 + i * 18);
    }

    // Align behavior:
    // - If cards fit in the row, center them (so 1 card sits in the middle).
    // - If overflow, left-align and keep first card fully visible.
    window.requestAnimationFrame(() => {
      try {
        // need a second frame for layout to settle after images/styles
        window.requestAnimationFrame(() => {
          // IMPORTANT: don't rely on scrollWidth here because entry transforms can distort the visual layout
          // and make it *look* like scrolling does nothing. Compute deterministically.
          const nCards = target.hand.length;
          const CARD_W = 140;
          const GAP = 12;
          const PAD = 6; // .drawRow padding left/right
          const contentW = nCards * CARD_W + Math.max(0, nCards - 1) * GAP;
          const avail = Math.max(0, drawRow.clientWidth - PAD * 2);
          const fits = contentW <= avail + 1;

          drawRow.style.justifyContent = fits ? "center" : "flex-start";
          drawRow.scrollLeft = 0;

          // Custom scrollbar: only show when overflow.
          try {
            if (!fits) {
              drawScroll.classList.remove("hidden");
              // Thumb width ratio based on deterministic widths.
              const scrollW = Math.max(avail, contentW);
              const ratio = avail / scrollW;
              const w = Math.max(10, Math.min(100, Math.floor(ratio * 1000) / 10)); // %
              drawThumbFinalWPercent = w;
              // Animate thumb shrinking in sync with the spread.
              // Spread timeline: last card starts at (30 + (n-1)*18) then transitions for ~420ms.
              const total = 30 + Math.max(0, nCards - 1) * 18 + 420;
              const start = performance.now();
              const easeOut = (t) => 1 - Math.pow(1 - t, 3); // close to the feel we use elsewhere
              try { if (drawThumbAnimRaf != null) window.cancelAnimationFrame(drawThumbAnimRaf); } catch { /* ignore */ }
              drawThumbAnimRaf = null;
              const step = (now) => {
                const p01 = Math.max(0, Math.min(1, (now - start) / Math.max(1, total)));
                const e = easeOut(p01);
                const cur = 100 + (drawThumbFinalWPercent - 100) * e;
                drawThumb.style.setProperty("--thumbW", `${cur}%`);
                if (p01 < 1) drawThumbAnimRaf = window.requestAnimationFrame(step);
                else {
                  drawThumbAnimRaf = null;
                  drawThumb.style.setProperty("--thumbW", `${drawThumbFinalWPercent}%`);
                }
              };
              drawThumbAnimRaf = window.requestAnimationFrame(step);
              if (typeof recalcDrawScrollSoon === "function") recalcDrawScrollSoon();
            } else {
              drawScroll.classList.add("hidden");
              if (typeof recalcDrawScrollSoon === "function") recalcDrawScrollSoon();
            }
          } catch {
            // ignore
          }
        });
      } catch {
        // ignore
      }
    });
  }

  function closeDrawOverlay() {
    drawOverlay.classList.add("hidden");
    drawRow.innerHTML = "";
    drawScroll.classList.add("hidden");
    if (typeof recalcDrawScrollSoon === "function") recalcDrawScrollSoon();
    if (drawOverlayInner) {
      drawOverlayInner.style.width = "";
      drawOverlayInner.style.transform = "";
      drawOverlayInner.style.opacity = "";
    }
    // Reset background styles
    drawOverlay.style.background = "";
    drawOverlay.style.backdropFilter = "";
  }

  drawOverlay.addEventListener("click", (e) => {
    if (e.target === drawOverlay) closeDrawOverlay();
  });
  btnDrawClose.addEventListener("click", closeDrawOverlay);

  // Draw overlay: keep custom scrollbar perfectly in sync with drawRow.scrollLeft (and allow dragging).
  // Rebuilt model (for maximum smoothness):
  // - Thumb movement drives scrollLeft directly (1px thumb -> proportional scrollLeft).
  // - ScrollLeft (wheel/touchpad) updates thumb position.
  // - While the entry "spread" is animating, thumb starts full-width then shrinks; first user interaction
  //   instantly finishes both the spread and the thumb shrink animation to avoid any jitter.
  (() => {
    const ROW_PAD_X = 6; // .drawRow padding left/right
    const CARD_W = 140;  // .drawBack width
    const GAP = 12;      // .drawRow gap

    const st = {
      rafSync: null,
      rafRecalc: null,
      dragging: false,
      // cached geometry
      maxScroll: 0,
      trackW: 0,
      thumbWPercent: 100,
      thumbWPx: 0,
      thumbXMax: 0,
      // thumb position cache (px on track)
      thumbX: 0,
      // drag state
      spid: null,
      startClientX: 0,
      startThumbX: 0,
    };

    function clamp01(x) {
      return Math.max(0, Math.min(1, x));
    }
    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function readThumbWPercent() {
      // Prefer the CSS variable we set (e.g. "23.4%"), not offsetWidth (layout read).
      try {
        const raw = getComputedStyle(drawThumb).getPropertyValue("--thumbW").trim();
        if (!raw) return 100;
        const s = raw.endsWith("%") ? raw.slice(0, -1) : raw;
        const n = Number.parseFloat(s);
        if (!Number.isFinite(n)) return 100;
        return Math.max(1, Math.min(100, n));
      } catch {
        return 100;
      }
    }

    function recalc() {
      try {
        if (drawScroll.classList.contains("hidden")) {
          st.maxScroll = 0;
          st.trackW = 0;
          st.thumbXMax = 0;
          return;
        }

        st.trackW = drawScroll.clientWidth;
        st.thumbWPercent = readThumbWPercent();
        st.thumbWPx = st.trackW * (st.thumbWPercent / 100);
        st.thumbXMax = Math.max(0, st.trackW - st.thumbWPx);

        // Use deterministic geometry during entry transforms (more stable), but fall back to real scrollWidth
        // when it's larger (after spread has finished).
        const nCards = drawRow ? drawRow.children.length : 0;
        const avail = Math.max(0, drawRow.clientWidth - ROW_PAD_X * 2);
        const contentW = nCards * CARD_W + Math.max(0, nCards - 1) * GAP;
        const detMax = Math.max(0, contentW - avail);
        const realMax = Math.max(0, drawRow.scrollWidth - drawRow.clientWidth);
        st.maxScroll = Math.max(detMax, realMax);

        // Keep cached thumbX inside bounds after geometry changes.
        st.thumbX = clamp(st.thumbX, 0, st.thumbXMax);
      } catch {
        // ignore
      }
    }

    function setThumbX(x) {
      st.thumbX = clamp(x, 0, st.thumbXMax);
      drawThumb.style.setProperty("--thumbX", `${st.thumbX}px`);
    }

    function setThumbFromScrollLeft(scrollLeft) {
      try {
        if (drawScroll.classList.contains("hidden")) return;
        const max = Math.max(1, st.maxScroll);
        const p = clamp01(scrollLeft / max);
        setThumbX(p * st.thumbXMax);
      } catch {
        // ignore
      }
    }

    function ensureInstantSpread() {
      // Entry uses transforms (visual-only). If user starts scrolling/dragging,
      // finish the spread immediately so scroll feedback is visible.
      try { drawRow.classList.add("instant"); } catch { /* ignore */ }
      // Also instantly finish thumb width animation if it's running.
      try {
        if (drawThumbAnimRaf != null) {
          window.cancelAnimationFrame(drawThumbAnimRaf);
          drawThumbAnimRaf = null;
        }
        if (Number.isFinite(drawThumbFinalWPercent)) {
          drawThumb.style.setProperty("--thumbW", `${drawThumbFinalWPercent}%`);
        }
      } catch { /* ignore */ }
    }

    function scheduleRecalc() {
      if (st.rafRecalc != null) return;
      st.rafRecalc = window.requestAnimationFrame(() => {
        st.rafRecalc = null;
        recalc();
        setThumbFromScrollLeft(drawRow.scrollLeft);
      });
    }

    function scheduleSync() {
      if (st.rafSync != null) return;
      st.rafSync = window.requestAnimationFrame(() => {
        st.rafSync = null;
        if (st.dragging) return; // drag path drives thumb directly (more responsive)
        setThumbFromScrollLeft(drawRow.scrollLeft);
      });
    }

    // Init once.
    scheduleRecalc();
    // Expose to open/close overlay code (so showing/hiding the bar always refreshes metrics).
    recalcDrawScrollSoon = scheduleRecalc;

    drawRow.addEventListener("scroll", () => scheduleSync(), { passive: true });
    drawRow.addEventListener("wheel", () => ensureInstantSpread(), { passive: true });

    // Recalc on size changes (overlay width changes / viewport resize).
    try {
      const ro = new ResizeObserver(() => scheduleRecalc());
      ro.observe(drawRow);
      ro.observe(drawScroll);
    } catch {
      window.addEventListener("resize", () => scheduleRecalc(), { passive: true });
    }

    function beginDrag(e) {
      if (drawScroll.classList.contains("hidden")) return;
      if (!drawRow) return;
      // Only primary button for mouse
      if (e.button != null && e.button !== 0) return;

      ensureInstantSpread();
      recalc();
      if (st.maxScroll <= 0 || st.thumbXMax <= 0) return;

      st.spid = e.pointerId;
      st.startClientX = e.clientX;
      st.startThumbX = st.thumbX;
      st.dragging = true;

      try { drawScroll.setPointerCapture(st.spid); } catch { /* ignore */ }
      e.preventDefault();

      // If user clicked the track (not the thumb), jump so the thumb centers around the click.
      const isThumb = e.target === drawThumb || (e.target && e.target.closest && e.target.closest("#drawThumb"));
      if (!isThumb) {
        const trackRect = drawScroll.getBoundingClientRect();
        const clickX = e.clientX - trackRect.left;
        const thumbCenterX = st.thumbX + st.thumbWPx / 2;
        const dx = clickX - thumbCenterX;
        setThumbX(st.thumbX + dx);
        // Drive scroll immediately.
        const p = st.thumbXMax <= 0 ? 0 : st.thumbX / st.thumbXMax;
        drawRow.scrollLeft = p * st.maxScroll;
        // rebase after jump
        st.startClientX = e.clientX;
        st.startThumbX = st.thumbX;
      }
    }

    function moveDrag(e) {
      if (st.spid == null || e.pointerId !== st.spid) return;
      if (st.maxScroll <= 0) return;
      // Use coalesced events for smoother-than-1px mouse steps where available.
      const evs = typeof e.getCoalescedEvents === "function" ? e.getCoalescedEvents() : [e];
      let lastX = st.startThumbX;
      for (const ev of evs) {
        const dx = ev.clientX - st.startClientX;
        lastX = st.startThumbX + dx;
      }
      setThumbX(lastX);
      const p = st.thumbXMax <= 0 ? 0 : st.thumbX / st.thumbXMax;
      drawRow.scrollLeft = p * st.maxScroll;
      e.preventDefault();
    }

    function endDrag(e) {
      if (st.spid == null || e.pointerId !== st.spid) return;
      try { drawScroll.releasePointerCapture(st.spid); } catch { /* ignore */ }
      st.spid = null;
      st.dragging = false;
      scheduleSync();
    }

    drawScroll.addEventListener("pointerdown", beginDrag);
    drawScroll.addEventListener("pointermove", moveDrag);
    drawScroll.addEventListener("pointerup", endDrag);
    drawScroll.addEventListener("pointercancel", endDrag);
  })();

  // Single-card drag (2D) with asymmetric caps + damping:
  // - Horizontal: max 200px (left/right)
  // - Vertical: only upward, max 400px; cannot drag downward
  // - Damping increases near caps; once hitting a cap, lock until release.
  const bottomHandEl = $("#pBottomHand");
  let cardPointerId = null;
  let cardEl = null;
  let cardLastX = 0;
  let cardLastY = 0;
  let cardLastT = 0;
  let cardDx = 0;
  let cardDy = 0;
  let cardVx = 0;
  let cardVy = 0;
  let cardS = 1;
  let cardDragged = false;
  let cardDownAt = 0;
  const CARD_DRAG_CAP_X_PX = 200;
  const CARD_DRAG_CAP_UP_PX = 300;
  const CARD_DRAG_DAMP_P = 2.5; // exponent for ease-out damping increase (slightly softer near the end)
  const CARD_DRAG_SCALE_BASE = 1.0;
  const CARD_DRAG_SCALE_EXTRA = 0.3; // additional scale near caps (ease-out) - max 1.3x
  const EDGE_DAMP_RADIUS_PX = 220; // within this distance to table edge, damping ramps to max
  const DAMP_START_FRAC = 1 / 3; // start damping after 1/3 of the pull-to-cap distance
  let cardLocked = false; // once reached lock point, stop reacting until release
  let springRaf = null;
  // No hover-lift; click selection handles the lift.

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }
  function projectToDragRegion(dx, dy) {
    // dy: only upward (negative), cannot go downward (positive)
    const ndy = clamp(dy, -CARD_DRAG_CAP_UP_PX, 0);
    const ndx = dx;
    if (CARD_DRAG_CAP_X_PX <= 0 || CARD_DRAG_CAP_UP_PX <= 0) {
      return { dx: 0, dy: 0, hit: true };
    }

    // Elliptical boundary (smooth arc):
    // (x/CAP_X)^2 + (y/CAP_UP)^2 <= 1, with y = -dy (upward distance)
    let tx = ndx / CARD_DRAG_CAP_X_PX;
    let ty = Math.max(0, -ndy) / CARD_DRAG_CAP_UP_PX;
    const r2 = tx * tx + ty * ty;
    if (r2 <= 1) return { dx: ndx, dy: ndy, hit: false };
    const r = Math.sqrt(r2) || 1;
    tx /= r;
    ty /= r;
    const x2 = tx * CARD_DRAG_CAP_X_PX;
    const y2 = -ty * CARD_DRAG_CAP_UP_PX;
    return { dx: x2, dy: y2, hit: true };
  }
  function dragFrac(dx, dy) {
    // 0..1 based on radial distance inside the ellipse.
    if (CARD_DRAG_CAP_X_PX <= 0 || CARD_DRAG_CAP_UP_PX <= 0) return 1;
    const tx = dx / CARD_DRAG_CAP_X_PX;
    const ty = Math.max(0, -dy) / CARD_DRAG_CAP_UP_PX;
    return clamp(Math.sqrt(tx * tx + ty * ty), 0, 1);
  }
  const tableBgEl = document.querySelector(".tableBg");
  function edgeFracFromPointer(clientX, clientY) {
    // 0..1: 0 means far from edge, 1 means at/over the edge of table background.
    // This is used to force max damping when the mouse reaches the background edge.
    if (!tableBgEl) return 0;
    const r = tableBgEl.getBoundingClientRect();
    const dx = Math.max(r.left - clientX, 0, clientX - r.right);
    const dy = Math.max(r.top - clientY, 0, clientY - r.bottom);
    // If pointer is outside, treat as edge (max damping).
    if (dx > 0 || dy > 0) return 1;
    const toLeft = clientX - r.left;
    const toRight = r.right - clientX;
    const toTop = clientY - r.top;
    const toBottom = r.bottom - clientY;
    const minDist = Math.max(0, Math.min(toLeft, toRight, toTop, toBottom));
    const t = 1 - clamp(minDist / EDGE_DAMP_RADIUS_PX, 0, 1);
    return t;
  }
  function setCardOffset(el, dx, dy) {
    el.style.setProperty("--dx", `${dx}px`);
    el.style.setProperty("--dy", `${dy}px`);
  }
  function setCardScale(el, s) {
    el.style.setProperty("--s", `${s}`);
  }
  function easeOutPow(t, p) {
    const x = clamp(t, 0, 1);
    return 1 - Math.pow(1 - x, p);
  }
  function easeInPow(t, p) {
    const x = clamp(t, 0, 1);
    return Math.pow(x, p);
  }
  function combinedFrac(frac, edgeFrac) {
    // Avoid "instant big -> small -> big" at drag start when the hand is physically near the table edge:
    // only let edge-based damping contribute once the card is actually pulled out.
    // Weight edge influence by pull fraction so it's ~0 near origin and increases smoothly.
    const f = clamp(frac, 0, 1);
    const e = clamp(edgeFrac, 0, 1);
    const w = easeOutPow(f, 1.4); // 0 -> 1 as pull increases (out curve)
    return Math.max(f, e * w);
  }
  function dampDriver(frac) {
    // Gate the damping so it doesn't start too early:
    // below DAMP_START_FRAC => 0, then ramps 0..1 afterwards.
    const x = clamp(frac, 0, 1);
    const t0 = clamp(DAMP_START_FRAC, 0, 0.95);
    if (x <= t0) return 0;
    return clamp((x - t0) / (1 - t0), 0, 1);
  }

  function stopSpring() {
    if (springRaf) {
      cancelAnimationFrame(springRaf);
      springRaf = null;
    }
  }

  function startSpringBack(el, x0, y0, vx0, vy0, s0) {
    stopSpring();
    if (!el) return;

    // Hard spring snapback with landing bounce on impact
    let x = x0;
    let y = y0;
    const VMAX = 1200; // px/s
    let vx = clamp(vx0, -VMAX, VMAX) * 0.5;
    let vy = clamp(vy0, -VMAX, VMAX) * 0.5;
    let sStart = typeof s0 === "number" && Number.isFinite(s0) ? s0 : 1;
    let tAcc = 0;
    let last = performance.now();
    const startDist = Math.max(1, Math.hypot(x0, y0));
    const v0 = Math.hypot(vx, vy);

    // Hard spring: high omega, critically damped
    const omega = clamp(35 + startDist / 160, 35, 52); // rad/s - fast, hard spring
    const zeta = clamp(1.0 + v0 / 18000, 0.98, 1.15); // critically damped
    const k = omega * omega;
    const c = 2 * zeta * omega;

    el.classList.add("springing");
    el.classList.remove("snapBack");
    el.classList.remove("overshoot");

    // Landing bounce parameters
    const BOUNCE_COEF = 0.28; // coefficient of restitution (energy preserved on bounce)
    const BOUNCE_GRAVITY = 4800; // px/s^2
    const BOUNCE_MIN_VY = 60; // px/s - minimum velocity to trigger bounce

    const step = (now) => {
      let dt = clamp((now - last) / 1000, 0.001, 0.034);
      last = now;
      tAcc += dt;

      // Semi-implicit Euler
      const px = x;
      const py = y;
      const ax = -k * x - c * vx;
      const ay = -k * y - c * vy;
      vx += ax * dt;
      vy += ay * dt;
      x += vx * dt;
      y += vy * dt;

      // X-axis: hard stop at zero
      if ((px > 0 && x <= 0) || (px < 0 && x >= 0)) {
        x = 0;
        vx = 0;
      }

      // Y-axis: detect landing and trigger bounce
      if (py < 0 && y >= 0 && vy > 0) {
        // Just crossed zero from above with downward velocity
        const impactVy = Math.abs(vy);
        x = 0;
        y = 0;
        vx = 0;
        vy = 0;

        // Start landing bounce if impact velocity is significant
        if (impactVy >= BOUNCE_MIN_VY) {
          const bounceVy = -impactVy * BOUNCE_COEF; // upward velocity after bounce
          let by = 0;
          let bvy = bounceVy;
          let lastB = performance.now();

          const bounceStep = (nowB) => {
            const dtB = clamp((nowB - lastB) / 1000, 0.001, 0.034);
            lastB = nowB;
            bvy += BOUNCE_GRAVITY * dtB;
            by += bvy * dtB;

            // Bounce finished when back at ground moving downward
            if (by >= 0 && bvy >= 0) {
              setCardOffset(el, 0, 0);
              setCardScale(el, 1);
              el.classList.remove("springing");
              springRaf = null;
              return;
            }

            setCardOffset(el, 0, by);
            setCardScale(el, 1);
            springRaf = requestAnimationFrame(bounceStep);
          };
          springRaf = requestAnimationFrame(bounceStep);
          return;
        } else {
          // Impact too soft, just stop
          setCardOffset(el, 0, 0);
          setCardScale(el, 1);
          el.classList.remove("springing");
          springRaf = null;
          return;
        }
      }

      setCardOffset(el, x, y);
      // Scale follows ease-in curve (accelerating shrink)
      const scaleT = clamp(1 - Math.exp(-8 * tAcc), 0, 1);
      const s = 1 + (sStart - 1) * (1 - easeInPow(scaleT, 2.0));
      setCardScale(el, s);

      // Check if settled near origin with low velocity
      const settled = Math.hypot(x, y) < 0.5 && Math.hypot(vx, vy) < 18;
      if (settled) {
        setCardOffset(el, 0, 0);
        setCardScale(el, 1);
        el.classList.remove("springing");
        springRaf = null;
        return;
      }

      springRaf = requestAnimationFrame(step);
    };
    springRaf = requestAnimationFrame(step);
  }

  bottomHandEl.addEventListener("pointerdown", (e) => {
    if (isDealing) return;
    if (e.button != null && e.button !== 0) return;
    const target = e.target.closest(".faceCard");
    if (!target) return;
    cardPointerId = e.pointerId;
    cardEl = target;
    // Ensure snapback easing only applies on release (not during drag).
    cardEl.classList.remove("snapBack");
    cardEl.classList.remove("overshoot");
    cardEl.classList.remove("springing");
    stopSpring();
    cardLastX = e.clientX;
    cardLastY = e.clientY;
    cardLastT = performance.now();
    cardDx = 0;
    cardDy = 0;
    cardVx = 0;
    cardVy = 0;
    cardS = CARD_DRAG_SCALE_BASE;
    cardDragged = false;
    cardDownAt = Date.now();
    cardLocked = false;
    cardEl.classList.add("dragging");
    setCardOffset(cardEl, 0, 0);
    setCardScale(cardEl, cardS);
    try { cardEl.setPointerCapture(cardPointerId); } catch { /* ignore */ }
  });

  bottomHandEl.addEventListener("pointermove", (e) => {
    if (isDealing) return;
    if (cardPointerId == null || e.pointerId !== cardPointerId) return;
    if (!cardEl) return;
    if (cardLocked) return;
    const tNow = performance.now();
    const dt = clamp((tNow - cardLastT) / 1000, 0.001, 0.05);
    cardLastT = tNow;
    const ddx0 = e.clientX - cardLastX;
    const ddy0 = e.clientY - cardLastY;
    cardLastX = e.clientX;
    cardLastY = e.clientY;

    const prevDx = cardDx;
    const prevDy = cardDy;

    const oldFrac = dragFrac(cardDx, cardDy);
    const edgeFrac = edgeFracFromPointer(e.clientX, e.clientY);
    const oldCombined = combinedFrac(oldFrac, edgeFrac);
    const oldD = dampDriver(oldCombined);
    // Target offset if perfectly following the pointer
    let ddx = ddx0;
    let ddy = ddy0;
    let nextDx = cardDx + ddx;
    let nextDy = cardDy + ddy;
    // Apply "no downward" immediately for intent detection (downward movement shouldn't help push outward)
    if (nextDy > 0) nextDy = 0;
    let nextFrac = dragFrac(nextDx, nextDy);
    const nextCombined = combinedFrac(nextFrac, edgeFrac);
    const nextD = dampDriver(nextCombined);

    // Damping: apply whenever we are NOT moving inward (i.e., not getting farther from caps).
    // Joystick feel: resist radial (outward) motion much more than tangential (around-the-edge) motion.
    // This prevents the "pause / straight line" feel when sliding left/right at a given height.
    if (nextD >= oldD) {
      // Combined damping driver: either card approaching its drag caps, OR pointer approaching table edge.
      // When mouse reaches the table edge, edgeFrac -> 1 => strength -> 1 (max damping).
      const strength = easeOutPow(oldD, CARD_DRAG_DAMP_P);
      const radialGain = 1 - strength; // strongest resistance
      // Tangential (left/right) should remain smooth, but when pulled upward "high enough",
      // increase tangential damping so the arc stays small (avoid the "can draw a circle" feel).
      let tanGain = 1 - strength * 0.35; // base tangential damping near edge

      // Work in normalized ellipse-space so the boundary is a circle:
      // vx = dx/CAP_X, vy = (-dy)/CAP_UP
      const capX = CARD_DRAG_CAP_X_PX;
      const capY = CARD_DRAG_CAP_UP_PX;
      if (capX > 0 && capY > 0) {
        const ux0 = cardDx / capX;
        const uy0 = Math.max(0, -cardDy) / capY;
        const un = Math.hypot(ux0, uy0);
        if (un > 1e-4) {
          const ux = ux0 / un;
          const uy = uy0 / un;

          // Height-dependent tangential damping:
          // - below ~35% upward pull: almost unchanged
          // - above that: tangential gets increasingly "sticky" so sliding left/right produces only a small arc
          const upFrac = clamp(uy0, 0, 1); // 0..1 upward fraction
          const tUp = clamp((upFrac - 0.35) / (1 - 0.35), 0, 1);
          // Up to ~55% additional tangential damping at max upward pull.
          tanGain *= 1 - 0.55 * tUp;

          let dvx = ddx0 / capX;
          let dvy = -ddy0 / capY;

          // Decompose dv into radial/tangential components.
          const dr = dvx * ux + dvy * uy;
          const tvx = dvx - dr * ux;
          const tvy = dvy - dr * uy;

          // Only resist radial-outward component (dr > 0). Inward dr stays responsive.
          const dr2 = dr > 0 ? dr * radialGain : dr;
          dvx = dr2 * ux + tvx * tanGain;
          dvy = dr2 * uy + tvy * tanGain;

          ddx = dvx * capX;
          ddy = -dvy * capY;
        } else {
          // Near origin: fall back to uniform damping.
          const gain = 1 - strength;
          ddx = ddx0 * gain;
          ddy = ddy0 * gain;
        }
      } else {
        const gain = 1 - strength;
        ddx = ddx0 * gain;
        ddy = ddy0 * gain;
      }

      nextDx = cardDx + ddx;
      nextDy = cardDy + ddy;
      if (nextDy > 0) nextDy = 0;
      nextFrac = dragFrac(nextDx, nextDy);
    }

    // Clamp to a smooth arc (ellipse). Do NOT lock; keep motion continuous along the boundary (no "pause").
    const proj = projectToDragRegion(nextDx, nextDy);
    nextDx = proj.dx;
    nextDy = proj.dy;

    cardDx = nextDx;
    cardDy = nextDy;

    // Scale follows the same ease-out "damping strength" rhythm.
    const curFrac = dragFrac(cardDx, cardDy);
    const curCombined = combinedFrac(curFrac, edgeFrac);
    const curD = dampDriver(curCombined);
    const curStrength = easeOutPow(curD, CARD_DRAG_DAMP_P);
    cardS = CARD_DRAG_SCALE_BASE + CARD_DRAG_SCALE_EXTRA * curStrength;

    // Velocity estimate (for physical release). Smooth a bit to reduce noise.
    const instVx = (cardDx - prevDx) / dt;
    const instVy = (cardDy - prevDy) / dt;
    cardVx = cardVx * 0.65 + instVx * 0.35;
    cardVy = cardVy * 0.65 + instVy * 0.35;

    if (!cardDragged) {
      const moved = Math.hypot(cardDx, cardDy) > 6 && Date.now() - cardDownAt > 40;
      if (moved) cardDragged = true;
    }
    setCardOffset(cardEl, cardDx, cardDy);
    setCardScale(cardEl, cardS);
  });

  function endCardPointer(e) {
    if (cardPointerId == null || e.pointerId !== cardPointerId) return;
    const el = cardEl;
    const lastDx = cardDx;
    const lastDy = cardDy;
    const lastVx = cardVx;
    const lastVy = cardVy;
    const lastS = cardS;
    const dragDist = Math.hypot(lastDx, lastDy);
    cardPointerId = null;
    cardEl = null;

    if (el) {
      el.classList.remove("dragging");
      // Only spring back if we actually dragged (or moved meaningfully).
      const moved = Math.hypot(lastDx, lastDy) > 1.5 || cardDragged;
      if (moved) {
        startSpringBack(el, lastDx, lastDy, lastVx, lastVy, lastS);
      } else {
        // No movement: don't run spring animation (prevents "return then pop" on click).
        setCardOffset(el, 0, 0);
        setCardScale(el, 1);
        el.classList.remove("springing");
        el.classList.remove("overshoot");
      }
      try { el.releasePointerCapture(e.pointerId); } catch { /* ignore */ }
    }
    // If it was a drag, suppress click selection.
    if (cardDragged) suppressHandClickUntil = Date.now() + 220;

    cardDragged = false;
    cardLocked = false;
    cardVx = 0;
    cardVy = 0;
    cardS = 1;
  }
  bottomHandEl.addEventListener("pointerup", endCardPointer);
  bottomHandEl.addEventListener("pointercancel", endCardPointer);

  // Click your cards to select (on table)
  bottomHandEl.addEventListener("click", (e) => {
    if (isDealing) return;
    if (Date.now() < suppressHandClickUntil) return;
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;
    const c = e.target.closest(".faceCard");
    if (!c) return;
    const id = c.dataset.cardId;
    if (!id) return;
    markHumanAction();
    if (selected.includes(id)) selected = selected.filter((x) => x !== id);
    else selected = selected.length >= 2 ? [selected[1], id] : [...selected, id];
    renderSelectionHighlights();
    syncSelectionUi();
  });

  // UI image buttons
  // Prevent image/element drag (fixes mobile/desktop "can drag" and hit-testing weirdness)
  for (const el of [btnHintImg, btnMatchImg, btnEndTurnImg]) {
    el.addEventListener("dragstart", (e) => e.preventDefault());
    const img = el.querySelector("img");
    if (img) img.addEventListener("dragstart", (e) => e.preventDefault());
  }

  // Prevent native HTML drag on card images (otherwise non-joker image cards may bypass our 50px lift cap).
  bottomHandEl.addEventListener(
    "dragstart",
    (e) => {
      const t = e.target;
      if (t && t.closest && t.closest(".faceCard")) e.preventDefault();
    },
    { capture: true }
  );

  btnHintImg.addEventListener("click", () => {
    if (isDealing) return;
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;
    markHumanAction();

    // Toggle hint: if already showing hint (2 cards selected), clear them; otherwise show hint
    if (selected.length === 2) {
      // Check if the current selection is a valid pair (hint result)
      const pair = window.Game.findAnyPairInHand(game.players[0].hand);
      const isHintPair = pair &&
        ((selected[0] === pair[0].id && selected[1] === pair[1].id) ||
         (selected[0] === pair[1].id && selected[1] === pair[0].id));

      if (isHintPair) {
        // Clear hint: deselect cards and return them to original position
        clearSelection();
        return;
      }
    }

    // Show hint: select the matching pair
    maybeShowHint();
  });

  btnMatchImg.addEventListener("click", () => {
    if (isDealing) return;
    // same as "åŒ¹é…å‡ºç‰Œ"
    btnTryMatch.click();
  });

  btnEndTurnImg.addEventListener("click", () => {
    if (isDealing) return;
    btnEndTurn.click();
  });

  // Click upstream backs to draw
  document.addEventListener("click", (e) => {
    const b = e.target.closest(".seatHand[data-from-player-index]");
    if (!b) return;
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (current.kind !== "human") return;
    const fromIdx = Number(b.dataset.fromPlayerIndex);
    markHumanAction();

    // ç›´æ¥æ‰“å¼€æŠ½ç‰Œç•Œé¢ï¼ˆæ— åŠ¨ç”»ï¼‰
    animateUpstreamRotateAndOpen(fromIdx);
  });

  btnTryMatch.addEventListener("click", () => {
    if (!game || game.gameOver) return;
    advancePastOutPlayers();
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.out || current.kind !== "human") return;
    if (selected.length !== 2) return;
    markHumanAction();
    const [a, b] = selected;

    // Animate the two selected cards to discard pile if it matches.
    const aEl = $("#pBottomHand").querySelector(`.faceCard[data-card-id="${CSS.escape(a)}"]`);
    const bEl = $("#pBottomHand").querySelector(`.faceCard[data-card-id="${CSS.escape(b)}"]`);
    const res = window.Game.tryDiscardPairByCardIds(game, 0, a, b);
    if (res.ok) {
      const bottomHandEl = $("#pBottomHand");

      // è·å–æ‰€æœ‰å‰©ä½™æ‰‹ç‰Œï¼ˆä¸åŒ…æ‹¬å³å°†é£èµ°çš„ä¸¤å¼ ï¼‰
      const allCards = Array.from(bottomHandEl.querySelectorAll(".faceCard"));
      const remainingCards = allCards.filter(el => el !== aEl && el !== bEl);

      // æ ‡è®°æ‰‹ç‰ŒåŒºåŸŸæ­£åœ¨åšè‡ªé€‚åº”åŠ¨ç”»
      bottomHandEl.dataset.adjusting = "true";

      // è®¡ç®—æ–°çš„å¸ƒå±€ä½ç½®ï¼ˆæ‰‹ç‰Œæ•°é‡å‡2ï¼‰
      const newN = remainingCards.length;
      const newCenter = (newN - 1) / 2;
      const maxFanWidth = 920;
      const newSpread = Math.min(62, maxFanWidth / Math.max(1, newN - 1));

      // ç«‹å³ä¸ºå‰©ä½™æ‰‹ç‰Œæ·»åŠ transitionï¼Œå¹¶æ›´æ–°å®ƒä»¬çš„ä½ç½®ï¼ˆå¡«è¡¥ç©ºç¼ºï¼‰
      remainingCards.forEach((card, newIdx) => {
        const newD = newIdx - newCenter;
        const newX = newD * newSpread;
        const newRot = newD * 0.9;
        const newY = Math.abs(newD) * 0.8;

        // æ·»åŠ å¹³æ»‘è¿‡æ¸¡
        card.style.transition = "transform 420ms cubic-bezier(0.22, 1, 0.36, 1)";

        // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿transitionç”Ÿæ•ˆ
        requestAnimationFrame(() => {
          card.style.setProperty("--x", `${newX}px`);
          card.style.setProperty("--rot", `${newRot}deg`);
          card.style.setProperty("--y", `${newY}px`);
        });
      });

      // å¯åŠ¨å‡ºç‰Œé£è¡ŒåŠ¨ç”»ï¼ˆåŒæ—¶è¿›è¡Œï¼‰
      if (aEl) flyToDiscard(aEl);
      if (bEl) flyToDiscard(bEl);

      // ç­‰å¾…è‡ªé€‚åº”åŠ¨ç”»å®Œæˆåï¼Œæ¸…é™¤æ ‡è®°å¹¶é‡æ–°æ¸²æŸ“ï¼ˆæ¸…ç†transitionç­‰ï¼‰
      setTimeout(() => {
        bottomHandEl.dataset.adjusting = "";
        renderSeats(game);
        renderDiscardPile(game);
        renderAction(game, settings);
        showLastEvent(game, settings);
      }, 500); // ç•¥é•¿äºè‡ªé€‚åº”åŠ¨ç”»æ—¶é•¿ï¼ˆ420msï¼‰

      clearSelection();
    } else {
      // é…å¯¹å¤±è´¥ï¼Œæ­£å¸¸æ›´æ–°
      renderAll(game, settings);
    }
    // If the human just went out, immediately pass the turn.
    if (!game.gameOver && game.players[game.currentPlayerIndex]?.out) {
      closeDrawOverlay();
      window.Game.advanceTurn(game);
      renderAll(game, settings);
      runAiLoop(game, settings);
    }
  });

  btnClearSelect.addEventListener("click", () => {
    markHumanAction();
    clearSelection();
  });

  btnEndTurn.addEventListener("click", () => {
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (current.kind !== "human") return;
    const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
    const canDrawUpstream = window.Game.canDrawFrom(game, upstreamIdx);
    if (!game.turnHasDrawn && canDrawUpstream) return;
    markHumanAction();
    clearSelection();
    closeDrawOverlay();
    window.Game.advanceTurn(game);
    renderAll(game, settings);
    runAiLoop(game, settings);
  });

  syncSettings();

  // When AI advances and it becomes the human's turn, start the 8s timer baseline.
  const _renderAll = renderAll;
  renderAll = function patchedRenderAll(g, s) {
    _renderAll(g, s);
    if (!g) return;
    if (g.gameOver) {
      window.clearTimeout(hintT);
      hintT = null;
      window.clearTimeout(runAiLoop._t);
      runAiLoop._t = null;
      clearHintHighlight();

      const loser = window.Game.findJokerHolder(g.players);
      const youLose = loser && loser.id === g.players[0].id;
      endTitle.textContent = youLose ? "ä½ è¾“äº†" : "ä½ èµ¢äº†";
      endSubtitle.textContent = loser ? `${loser.name} æœ€åæ‹¿ç€ JOKERã€‚` : "æ¸¸æˆç»“æŸã€‚";
      endOverlay.classList.remove("hidden");
      return;
    }
    const pid = g.players[g.currentPlayerIndex]?.id || null;
    if (pid !== lastTurnPlayerId) {
      lastTurnPlayerId = pid;
      if (g.players[g.currentPlayerIndex]?.kind === "human") {
        markHumanAction();
      } else {
        // not human turn: stop hints
        window.clearTimeout(hintT);
        hintT = null;
        clearHintHighlight();
        // ensure AI loop always starts when it's AI's turn (prevents "stuck after end turn")
        if (s.aiPaceMs < 1e6) {
          try {
            runAiLoop(g, s);
          } catch {
            // ignore
          }
        }
      }
    } else {
      // same turn: if user is idle and we newly have a pair (e.g., after draw), ensure a timer exists
      scheduleHintFromNow();
    }
  };
}

window.initUi = initUi;

