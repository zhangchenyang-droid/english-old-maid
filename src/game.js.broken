/* Core game logic (no DOM). No ES modules so file:// works. */

function createRng(seedString = "") {
  // Mulberry32 PRNG from string seed (deterministic shuffles if needed).
  let h = 1779033703 ^ seedString.length;
  for (let i = 0; i < seedString.length; i++) {
    h = Math.imul(h ^ seedString.charCodeAt(i), 3432918353);
    h = (h << 13) | (h >>> 19);
  }
  let a = (h >>> 0) || 1;
  return function rand() {
    a |= 0;
    a = (a + 0x6d2b79f5) | 0;
    let t = Math.imul(a ^ (a >>> 15), 1 | a);
    t = (t + Math.imul(t ^ (t >>> 7), 61 | t)) ^ t;
    return ((t ^ (t >>> 14)) >>> 0) / 4294967296;
  };
}

function shuffleInPlace(arr, rand = Math.random) {
  for (let i = arr.length - 1; i > 0; i--) {
    const j = Math.floor(rand() * (i + 1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
  return arr;
}

function buildDeckFromImagePairs(pairs) {
  const deck = [];
  for (const p of pairs) {
    const pairId = p.key;
    deck.push({
      id: `${pairId}_A`,
      type: "img",
      pairId,
      side: "A",
      imgSrc: p.A,
    });
    deck.push({
      id: `${pairId}_B`,
      type: "img",
      pairId,
      side: "B",
      imgSrc: p.B,
    });
  }
  // One unmatchable joker card (Old Maid)
  deck.push({
    id: "joker",
    type: "joker",
    pairId: null,
    side: null,
  });
  return deck;
}

function extractJoker(deck) {
  let joker = null;
  const rest = [];
  for (const c of deck) {
    if (c && c.type === "joker" && !joker) joker = c;
    else rest.push(c);
  }
  if (!joker) joker = { id: "joker", type: "joker", pairId: null, side: null };
  return { joker, rest };
}

// ========== ğŸ†• è™šæ‹ŸAIæ‰‹ç‰Œç³»ç»Ÿ - è¾…åŠ©å‡½æ•° ==========

// è·å–æ‰€æœ‰å¯ç”¨çš„ pairId åˆ—è¡¨
// ========== æ ¸å¿ƒæ¸¸æˆå‡½æ•° ==========

function buildPlayers(playerCount) {
  return Array.from({ length: playerCount }).map((_, i) => ({
    id: `p${i + 1}`,
    name: i === 0 ? "ä½ " : `AI${i}`,
    kind: i === 0 ? "human" : "ai",
    hand: [],
    out: false,
  }));
}

// å®Œå…¨é‡å†™çš„ initialDeal å‡½æ•°

function initialDeal(deck, playerCount, rand = Math.random) {
  const players = buildPlayers(playerCount);
  shuffleInPlace(deck, rand);

  const CARDS_PER_PLAYER = 12;
  const A_CARDS_PER_PLAYER = 6;
  const B_CARDS_PER_PLAYER = 6;

  const humanMatchablePairs = 2 + Math.floor(rand() * 3);
  const aiMatchablePairs = humanMatchablePairs - 1;

  console.log(`[å‘ç‰Œ] ç©å®¶å¯é…å¯¹:${humanMatchablePairs}å¯¹ï¼ŒAIå¯é…å¯¹:${aiMatchablePairs}å¯¹`);

  const pairGroups = new Map();
  for (const card of deck) {
    if (!card.pairId) continue;
    if (!pairGroups.has(card.pairId)) pairGroups.set(card.pairId, []);
    pairGroups.get(card.pairId).push(card);
  }

  const allPairIds = Array.from(pairGroups.keys());
  shuffleInPlace(allPairIds, rand);

  const playerHas = players.map(() => new Set());

  for (let p = 0; p < playerCount; p++) {
    const targetMatchablePairs = p === 0 ? humanMatchablePairs : aiMatchablePairs;
    const matchablePairIds = [];

    for (const pairId of allPairIds) {
      if (matchablePairIds.length >= targetMatchablePairs) break;
      let alreadyUsed = false;
      for (let otherP = 0; otherP < p; otherP++) {
        if (playerHas[otherP].has(pairId)) {
          alreadyUsed = true;
          break;
        }
      }
      if (!alreadyUsed) {
        matchablePairIds.push(pairId);
        playerHas[p].add(pairId);
      }
    }

    for (const pairId of matchablePairIds) {
      const cards = pairGroups.get(pairId);
      const cardA = cards.find(c => c.side === 'A');
      const cardB = cards.find(c => c.side === 'B');
      if (cardA && cardB) players[p].hand.push(cardA, cardB);
    }

    const currentA = players[p].hand.filter(c => c.side === 'A').length;
    const currentB = players[p].hand.filter(c => c.side === 'B').length;
    const needA = A_CARDS_PER_PLAYER - currentA;
    const needB = B_CARDS_PER_PLAYER - currentB;

    let addedA = 0;
    for (const pairId of allPairIds) {
      if (addedA >= needA) break;
      if (playerHas[p].has(pairId)) continue;
      const cards = pairGroups.get(pairId);
      const cardA = cards.find(c => c.side === 'A');
      if (cardA) {
        players[p].hand.push(cardA);
        playerHas[p].add(pairId);
        addedA++;
      }
    }

    let addedB = 0;
    for (const pairId of allPairIds) {
      if (addedB >= needB) break;
      if (playerHas[p].has(pairId)) continue;
      const cards = pairGroups.get(pairId);
      const cardB = cards.find(c => c.side === 'B');
      if (cardB) {
        players[p].hand.push(cardB);
        playerHas[p].add(pairId);
        addedB++;
      }
    }

    console.log(`[å‘ç‰Œ] ${players[p].name}: ${players[p].hand.length}å¼  (A:${players[p].hand.filter(c=>c.side==='A').length} B:${players[p].hand.filter(c=>c.side==='B').length})ï¼Œç›®æ ‡å¯æ¶ˆé™¤:${targetMatchablePairs}å¯¹`);
  }

  console.log("=== å‘ç‰Œç»“æœæ£€æŸ¥ ===");
  for (let p = 0; p < playerCount; p++) {
    const aCount = players[p].hand.filter(c => c.side === 'A').length;
    const bCount = players[p].hand.filter(c => c.side === 'B').length;
    const total = players[p].hand.length;

    const pairIdCount = new Map();
    players[p].hand.forEach(c => {
      if (!pairIdCount.has(c.pairId)) pairIdCount.set(c.pairId, { A: 0, B: 0 });
      pairIdCount.get(c.pairId)[c.side]++;
    });
    let actualPairs = 0;
    for (const [pairId, count] of pairIdCount.entries()) {
      if (count.A > 0 && count.B > 0) actualPairs++;
    }

    console.log(`${players[p].name}: ${total}å¼  (A:${aCount} B:${bCount}) å®é™…å¯é…å¯¹:${actualPairs}å¯¹ ${total === 12 ? 'âœ“' : 'âŒ'}`);
  }
  console.log("==================");

  for (const p of players) {
    shuffleInPlace(p.hand, rand);
  }

  for (const p of players) {
    p.out = p.hand.length === 0;
  }

  return players;
}

function countSidesInHand(hand) {
  let a = 0;
  let b = 0;
  for (const c of hand) {
    if (!c || c.type === "joker" || !c.side) continue;
    if (c.side === "A") a++;
    else if (c.side === "B") b++;
  }
  return { a, b };
}

  function pickHumanPairsCount() {
    // roundMode 0: ç¬¬ä¸€æŠŠ - 2åˆ°3å¯¹èµ·æ‰‹ï¼ˆé™ä½ä¼˜åŠ¿ï¼‰
    if (roundMode === 0) {
      return rand() < 0.6 ? 2 : 3; // 60%æ¦‚ç‡2å¯¹ï¼Œ40%æ¦‚ç‡3å¯¹
    }
    // roundMode 1: ç¬¬äºŒæŠŠ - 1åˆ°2å¯¹èµ·æ‰‹ï¼ˆæ›´æœ‰æŒ‘æˆ˜ï¼‰
    if (roundMode === 1) {
      return rand() < 0.5 ? 1 : 2; // 50%æ¦‚ç‡1å¯¹ï¼Œ50%æ¦‚ç‡2å¯¹
    }
    // roundMode 2: ç¬¬ä¸‰æŠŠ - æ­£å¸¸éšæœºåˆ†å¸ƒ
    const r = rand();
    // æ–°æ¦‚ç‡ï¼š2å¯¹(10%), 3å¯¹(20%), 4å¯¹(50%), 5å¯¹(15%), 6å¯¹å…¨æ¶ˆ(5%)
    if (r < 0.05) return 6; // 5% å…¨æ¶ˆ
    if (r < 0.10) return 2; // 5% (ç´¯ç§¯10%)
    if (r < 0.30) return 3; // 20% (ç´¯ç§¯30%)
    if (r < 0.45) return 5; // 15% (ç´¯ç§¯45%)
    return 4; // 55% (å‰©ä½™)
  }

  // AIé…å¯¹æ•°å·²åºŸå¼ƒï¼ŒAIé€šè¿‡éšæœºå‘ç‰Œè‡ªç„¶å½¢æˆé…å¯¹ï¼ˆä¸å†äººä¸ºæ§åˆ¶ï¼‰

  const humanPairsTarget = pickHumanPairsCount();
  const humanSingles = targetNonJoker[humanIdx] - humanPairsTarget * 2; // 0,4,6,8
  if (humanSingles < 0 || humanSingles % 2 !== 0) {
    throw new Error("Invalid human pair distribution.");
  }

  // Human gets exactly N full pairs.
  for (let k = 0; k < humanPairsTarget; k++) {
    const next = pairObjs.pop();
    if (!next) throw new Error("Not enough pairs for human full pairs.");
    players[humanIdx].hand.push(next.A, next.B);
  }

  // Human fills the rest with singles: keep A:B == 1:1 and ensure these singles never form a complete pair.
  const singlesHalf = humanSingles / 2;
  const looseA = [];
  const looseB = [];
  for (let k = 0; k < singlesHalf; k++) {
    const next = pairObjs.pop();
    if (!next) throw new Error("Not enough pairs for human singles.");
    players[humanIdx].hand.push(next.A);
    looseB.push(next.B);
  }
  for (let k = 0; k < singlesHalf; k++) {
    const next = pairObjs.pop();
    if (!next) throw new Error("Not enough pairs for human singles.");
    players[humanIdx].hand.push(next.B);
    looseA.push(next.A);
  }

  // Build side pools for the remaining cards (including leftovers from split pairs).
  const poolA = looseA.slice();
  const poolB = looseB.slice();
  for (const p of pairObjs) {
    poolA.push(p.A);
    poolB.push(p.B);
  }
  shuffleInPlace(poolA, rand);
  shuffleInPlace(poolB, rand);

  // Deal to AIs by side counts (keeps A:B=1:1 automatically).
  // We'll deal first, then apply pair formation logic after.
  for (const pi of [ai12, ai10a, ai10b]) {
    const half = targetNonJoker[pi] / 2;
    for (let k = 0; k < half; k++) {
      const c = poolA.pop();
      if (!c) throw new Error("PoolA exhausted.");
      players[pi].hand.push(c);
    }
    for (let k = 0; k < half; k++) {
      const c = poolB.pop();
      if (!c) throw new Error("PoolB exhausted.");
      players[pi].hand.push(c);
    }
  }

  // Post-deal: for roundMode 0/1, AI players already have random distribution
  // The initial random deal already gives AIs varied pair counts naturally
  // We don't need extra manipulation - just accept what was dealt

  // Shuffle each hand for randomness and sanity-check.
  for (let pi = 0; pi < playerCount; pi++) {
    shuffleInPlace(players[pi].hand, rand);
    players[pi].out = players[pi].hand.length === 0;
    const nonJoker = players[pi].hand.filter((c) => c.type !== "joker");
    const { a, b } = countSidesInHand(nonJoker);
    if (a !== b) throw new Error("Constrained deal failed: A/B not 1:1.");
  }

  // Sanity: human complete pairs should match target (allow some variance for balance)
  const actualHumanPairs = countCompletePairsInHand(players[humanIdx].hand);
  if (Math.abs(actualHumanPairs - humanPairsTarget) > 1) {
    throw new Error(`Constrained deal: human pairs mismatch (expected ${humanPairsTarget}, got ${actualHumanPairs}).`);
  }

  return players;
}

// âŒ å·²åˆ é™¤ï¼šbalanceHandSides() - AIè™šæ‹ŸåŒ–åä¸éœ€è¦å¹³è¡¡æœºåˆ¶

// âŒ å·²åˆ é™¤ï¼šrebalanceSinglePlayer() - AIè™šæ‹ŸåŒ–åä¸éœ€è¦å¹³è¡¡æœºåˆ¶

function countCompletePairsInHand(hand) {
  const byKey = new Map(); // pairId -> {A:boolean,B:boolean}
  for (const c of hand) {
    if (!c || !c.pairId || c.type === "joker") continue;
    if (!byKey.has(c.pairId)) byKey.set(c.pairId, { A: false, B: false });
    const s = byKey.get(c.pairId);
    if (c.side === "A") s.A = true;
    if (c.side === "B") s.B = true;
  }
  let count = 0;
  for (const s of byKey.values()) if (s.A && s.B) count++;
  return count;
}

// âŒ å·²åˆ é™¤ï¼šensureHumanHasAtLeastNPairs() - AIè™šæ‹ŸåŒ–åä¸éœ€è¦ä¿è¯èµ·æ‰‹é…å¯¹æ•°

function discardAllPairsInPlace(hand) {
  const byPair = new Map();
  for (let i = 0; i < hand.length; i++) {
    const c = hand[i];
    if (!c.pairId) continue;
    if (!byPair.has(c.pairId)) byPair.set(c.pairId, []);
    byPair.get(c.pairId).push(i);
  }

  // Remove pairs; each pairId has at most 2 cards globally, but be safe.
  const indicesToRemove = [];
  for (const [pairId, idxs] of byPair.entries()) {
    if (idxs.length >= 2) {
      // remove in pairs of 2
      for (let k = 0; k + 1 < idxs.length; k += 2) {
        indicesToRemove.push(idxs[k], idxs[k + 1]);
      }
    }
  }
  if (indicesToRemove.length === 0) return [];

  indicesToRemove.sort((a, b) => b - a);
  const removed = [];
  for (const idx of indicesToRemove) {
    removed.push(hand.splice(idx, 1)[0]);
  }
  return removed;
}

function findMatchIndex(hand, pairId) {
  if (!pairId) return -1;
  for (let i = 0; i < hand.length; i++) {
    if (hand[i].pairId === pairId) return i;
  }
  return -1;
}

function nextActivePlayerIndex(players, startIdx) {
  const n = players.length;
  for (let step = 1; step <= n; step++) {
    const idx = (startIdx + step) % n;
    if (!players[idx].out) return idx;
  }
  return -1;
}

function prevActivePlayerIndex(players, startIdx) {
  const n = players.length;
  for (let step = 1; step <= n; step++) {
    const idx = (startIdx - step + n) % n;
    if (!players[idx].out) return idx;
  }
  return -1;
}

function countNonJokerCards(players) {
  let c = 0;
  for (const p of players) {
    for (const card of p.hand) if (card.type !== "joker") c++;
  }
  return c;
}

function findJokerHolder(players) {
  for (const p of players) {
    if (p.hand.some((c) => c.type === "joker")) return p;
  }
  return null;
}

function dealPendingJokerToPlayer(game, playerIndex) {
  if (!game || game.gameOver) return game;
  if (!game.jokerPending) return game;
  const p = game.players[playerIndex];
  if (!p) return game;
  p.hand.push(game.jokerPending);
  p.out = p.hand.length === 0;
  game.lastEvent = { type: "joker_deal", playerId: p.id, playerIndex };
  game.jokerPending = null;
  return game;
}

// å…¨å±€æ¸¸æˆå±€æ•°è¿½è¸ªï¼ˆå¾ªç¯ï¼šç¬¬1æŠŠå¿…èµ¢ï¼Œç¬¬2æŠŠå·®ä¸€å¼ èµ¢ï¼Œç¬¬3æŠŠæç¬‘ç‹å¡å¾ªç¯ï¼‰
if (!window.__GAME_ROUND_TRACKER__) {
  window.__GAME_ROUND_TRACKER__ = {
    currentLevel: 1, // å½“å‰å…³å¡ï¼š1=ç¬¬ä¸€å…³, 2=ç¬¬äºŒå…³, 3=ç¬¬ä¸‰å…³
    roundNumber: 0,  // å†…éƒ¨ä½¿ç”¨ï¼š0=ç¬¬ä¸€æŠŠ(å¿…èµ¢), 1=ç¬¬äºŒæŠŠ(å·®ä¸€å¼ ), 2=ç¬¬ä¸‰æŠŠ(æç¬‘)
  };
}

function createGame({ pairs, playerCount, seed = "" }) {
  const rand = seed ? createRng(seed) : Math.random;
  const { joker, rest } = extractJoker(buildDeckFromImagePairs(pairs));

  // ä½¿ç”¨ç®€å•éšæœºå‘ç‰Œï¼ˆåˆ é™¤æ‰€æœ‰ç‰¹æ®Šç­–åˆ’é€»è¾‘ï¼‰
  const players = initialDeal(rest, playerCount, rand);

  // Choose first non-out player; if all out (unlikely), pick 0.
  let currentPlayerIndex = players.findIndex((p) => !p.out);
  if (currentPlayerIndex < 0) currentPlayerIndex = 0;

  const roundMode = window.__GAME_ROUND_TRACKER__.roundNumber % 3;

  const game = {
    players,
    currentPlayerIndex,
    lastEvent: null,
    gameOver: false,
    winnerText: null,
    discardPile: [],
    turnHasDrawn: false,
    jokerPending: joker,  // æš‚æ—¶ä¿ç•™ï¼Œç¨ååˆ é™¤
    humanDrawAttempts: 0,  // ğŸ†• ç©å®¶è¿ç»­æœªåŒ¹é…æ¬¡æ•°ï¼ˆ0/1/2+ï¼‰
    roundMode,
  };

  // é€’å¢å±€æ•°
  window.__GAME_ROUND_TRACKER__.roundNumber++;

  return game;
}

function getNextPlayerIndex(game) {
  return nextActivePlayerIndex(game.players, game.currentPlayerIndex);
}

function getUpstreamPlayerIndex(game) {
  // ä¸Šå®¶ï¼šå›åˆé¡ºåºä¸­çš„å‰ä¸€ä½ï¼ˆé€†æ—¶é’ˆï¼‰
  return prevActivePlayerIndex(game.players, game.currentPlayerIndex);
}

function canDrawFrom(game, targetPlayerIndex) {
  const target = game.players[targetPlayerIndex];
  return target && !target.out && target.hand.length > 0;
}

function drawCard(game, targetPlayerIndex, cardIndexInTargetHand) {
  if (game.gameOver) return game;

  const current = game.players[game.currentPlayerIndex];
  const target = game.players[targetPlayerIndex];
  if (!current || current.out) throw new Error("Current player is out.");
  if (!target || target.out) throw new Error("Target player is out.");
  if (target.hand.length === 0) throw new Error("Target has no cards.");
  if (
    cardIndexInTargetHand < 0 ||
    cardIndexInTargetHand >= target.hand.length
  ) {
    throw new Error("Invalid card index.");
  }

  const drawn = target.hand.splice(cardIndexInTargetHand, 1)[0];
  current.hand.push(drawn);
  game.turnHasDrawn = true;

  const hasPotentialMatch =
    !!drawn.pairId &&
    current.hand.some((c) => c !== drawn && c.pairId === drawn.pairId);

  // æ›´æ–°äººç±»ç©å®¶çš„è¿ç»­æœªåŒ¹é…è®¡æ•°å™¨ï¼ˆæ¦‚ç‡åŒ¹é…æœºå™¨å°†åœ¨UIå±‚ä½¿ç”¨æ­¤æ•°æ®ï¼‰
  if (current.kind === "human") {
    game.humanFirstDrawInGame = false;
    if (hasPotentialMatch) {
      game.humanConsecutiveNoMatch = 0;
    } else {
      game.humanConsecutiveNoMatch++;
    }
  }

  // Update out flags
  current.out = current.hand.length === 0;
  target.out = target.hand.length === 0;

  // End condition: no non-joker cards remain
  if (countNonJokerCards(game.players) === 0) {
    game.gameOver = true;
    const loser = findJokerHolder(game.players);
    const currentLevel = window.__GAME_ROUND_TRACKER__.currentLevel;

    if (loser && loser.kind === "human") {
      game.winnerText = `ç¬¬${currentLevel}å…³å¤±è´¥ï¼šä½ æ‰‹é‡Œç•™ç€"ç‹å…«ç‰Œ"ï¼`;
      game.levelResult = "lose";
    } else {
      game.winnerText = `ğŸ‰ ç¬¬${currentLevel}å…³é€šè¿‡ï¼`;
      game.levelResult = "win";
    }
  }

  game.lastEvent = {
    type: "draw",
    currentPlayerId: current.id,
    targetPlayerId: target.id,
    drawn,
    hasPotentialMatch,
  };

  return game;
}

function tryDiscardPairByCardIds(game, playerIndex, cardIdA, cardIdB) {
  if (game.gameOver) return { ok: false, reason: "game_over" };
  const player = game.players[playerIndex];
  if (!player || player.out) return { ok: false, reason: "player_out" };
  if (cardIdA === cardIdB) return { ok: false, reason: "same_card" };

  const a = player.hand.find((c) => c.id === cardIdA);
  const b = player.hand.find((c) => c.id === cardIdB);
  if (!a || !b) return { ok: false, reason: "not_found" };
  if (!a.pairId || !b.pairId) return { ok: false, reason: "joker_or_invalid" };
  if (a.pairId !== b.pairId) {
    game.lastEvent = { type: "mismatch", playerId: player.id, cardIds: [cardIdA, cardIdB] };
    return { ok: false, reason: "mismatch" };
  }
  // Must be A <-> B
  if (!a.side || !b.side || a.side === b.side) {
    game.lastEvent = { type: "mismatch", playerId: player.id, cardIds: [cardIdA, cardIdB] };
    return { ok: false, reason: "same_side" };
  }

  // Remove cards
  const removed = [];
  for (const cid of [cardIdA, cardIdB]) {
    const idx = player.hand.findIndex((c) => c.id === cid);
    if (idx >= 0) removed.push(player.hand.splice(idx, 1)[0]);
  }
  game.discardPile.push(...removed);

  const wasOut = player.out;
  player.out = player.hand.length === 0;

  const pairId = a.pairId;
  game.lastEvent = { type: "discard_pair", playerId: player.id, pairId, cards: removed };

  // ğŸ”„ é‡ç½®æ­»å¾ªç¯è®¡æ•°å™¨ï¼ˆå‡ºç‰Œ=æœ‰è¿›å±•ï¼‰
  game.noProgressTurns = 0;

  if (countNonJokerCards(game.players) === 0) {
    game.gameOver = true;
    const loser = findJokerHolder(game.players);
    const currentLevel = window.__GAME_ROUND_TRACKER__.currentLevel;

    if (loser && loser.kind === "human") {
      game.winnerText = `ç¬¬${currentLevel}å…³å¤±è´¥ï¼šä½ æ‰‹é‡Œç•™ç€"ç‹å…«ç‰Œ"ï¼`;
      game.levelResult = "lose";
    } else {
      game.winnerText = `ğŸ‰ ç¬¬${currentLevel}å…³é€šè¿‡ï¼`;
      game.levelResult = "win";
    }
  }

  return { ok: true };
}

function findAnyPairInHand(hand) {
  const byKey = new Map(); // pairId -> {A?,B?}
  for (const c of hand) {
    if (!c.pairId) continue;
    if (!byKey.has(c.pairId)) byKey.set(c.pairId, { A: null, B: null });
    const slot = byKey.get(c.pairId);
    if (c.side === "A") slot.A = c;
    if (c.side === "B") slot.B = c;
  }
  for (const slot of byKey.values()) {
    if (slot.A && slot.B) return [slot.A, slot.B];
  }
  return null;
}

function advanceTurn(game) {
  if (game.gameOver) return game;

  // ğŸ†• æ£€æŸ¥ç©å®¶æ˜¯å¦å‡ºå®Œç‰Œï¼ˆç«‹å³ç»“æŸæ¸¸æˆï¼‰
  const humanPlayer = game.players[0];
  if (humanPlayer && humanPlayer.hand.length === 0) {
    game.gameOver = true;
    game.winnerText = "ğŸ‰ æ­å–œä½ è·èƒœï¼æ‰‹ç‰Œå…¨éƒ¨å‡ºå®Œï¼";
    game.winner = humanPlayer;
    return game;
  }

  const nextIdx = nextActivePlayerIndex(game.players, game.currentPlayerIndex);
  if (nextIdx < 0) {
    game.gameOver = true;
    game.winnerText = "æ¸¸æˆç»“æŸ";
    return game;
  }
  game.currentPlayerIndex = nextIdx;
  game.turnHasDrawn = false;
  game.lastEvent = { type: "turn", currentPlayerId: game.players[nextIdx].id };
  return game;
}

// è®¡ç®—æ‰‹ç‰Œçš„A/Bä¾§æ•°é‡å·®å¼‚
function getHandSideImbalance(hand) {
  let aCount = 0;
  let bCount = 0;
  for (const c of hand) {
    if (!c || c.type === "joker" || !c.side) continue;
    if (c.side === "A") aCount++;
    else if (c.side === "B") bCount++;
  }
  return { aCount, bCount, diff: aCount - bCount };
}

// æ£€æŸ¥ä¸Šå®¶æ‰‹ç‰Œä¸­æ˜¯å¦æœ‰å¯ä»¥ä¸å½“å‰ç©å®¶åŒ¹é…çš„ç‰Œ
function upstreamHasMatchableCard(game) {
  const humanIdx = 0;
  const human = game.players[humanIdx];
  if (!human || human.out) return false;

  const upstreamIdx = prevActivePlayerIndex(game.players, humanIdx);
  if (upstreamIdx < 0) return false;
  const upstream = game.players[upstreamIdx];
  if (!upstream || upstream.out || upstream.hand.length === 0) return false;

  // æ”¶é›†äººç±»æ‰‹ç‰Œä¸­æ‰€æœ‰çš„ pairId
  const humanPairIds = new Set();
  for (const c of human.hand) {
    if (c && c.pairId && c.type !== "joker") {
      humanPairIds.add(c.pairId);
    }
  }

  // æ£€æŸ¥ä¸Šå®¶æ˜¯å¦æœ‰ä»»ä½•åŒ¹é…çš„ pairId
  for (const c of upstream.hand) {
    if (c && c.pairId && c.type !== "joker" && humanPairIds.has(c.pairId)) {
      return true;
    }
  }

  return false;
}

// ä½œå¼Šæ¢ç‰Œï¼šä»å…¶ä»–AIæ‰‹ç‰Œä¸­æ‰¾ä¸€å¼ å¯åŒ¹é…çš„ç‰Œï¼Œä¸ä¸Šå®¶æ‰‹ç‰Œäº¤æ¢ï¼ˆç¬é—´å®Œæˆï¼Œæ— åŠ¨ç”»ï¼‰
// ä¼˜å…ˆé€‰æ‹©èƒ½å¹³è¡¡ç©å®¶æ‰‹ç‰ŒA/Bæ¯”ä¾‹çš„ç‰Œ
// ä½œå¼Šæ¢ç‰Œå‡½æ•° - å·²å®Œå…¨ç¦ç”¨
function cheatSwapToUpstream(game) {
  console.log(`[cheatSwapToUpstream] å·²ç¦ç”¨ï¼Œæ— ä½œå¼Š`);
  return false;
}

// åœ¨äººç±»ç©å®¶å³å°†æŠ½ç‰Œå‰è°ƒç”¨ï¼šJOKERæ•™å­¦æœºåˆ¶
function ensureHumanCanMatch(game) {
  console.log("=== ensureHumanCanMatch è¢«è°ƒç”¨ ===");

  if (game.gameOver) return;

  const humanIdx = 0;
  const human = game.players[humanIdx];
  if (!human || human.out || human.kind !== "human") return;

  console.log(`ç©å®¶çŠ¶æ€: roundMode=${game.roundMode}, firstDraw=${game.humanFirstDrawInGame}, consecutiveNoMatch=${game.humanConsecutiveNoMatch}`);

  // ç¬¬ä¸€æŠŠç‰¹æ®Šï¼šJOKERæ•™å­¦æœºåˆ¶ï¼ˆ30%æ¦‚ç‡ï¼Œä»…ç¬¬ä¸€æ¬¡æŠ½ç‰Œï¼‰
  if (game.roundMode === 0 && !game.humanDrawnJokerInRound0 && game.humanFirstDrawInGame) {
    if (Math.random() < 0.3) {
      console.log("[æ•™å­¦] å°è¯•è§¦å‘JOKERæ•™å­¦");
      const upstreamIdx = prevActivePlayerIndex(game.players, humanIdx);
      if (upstreamIdx >= 0) {
        const upstream = game.players[upstreamIdx];

        // æ‰¾JOKERåœ¨å“ª
        let jokerHolderIdx = -1;
        let jokerCardIdx = -1;
        for (let pi = 1; pi < game.players.length; pi++) {
          const idx = game.players[pi].hand.findIndex((c) => c && c.type === "joker");
          if (idx >= 0) {
            jokerHolderIdx = pi;
            jokerCardIdx = idx;
            break;
          }
        }

        // æŠŠJOKERæ¢åˆ°ä¸Šå®¶
        if (jokerHolderIdx >= 0 && jokerHolderIdx !== upstreamIdx && upstream.hand.length > 0) {
          const jokerCard = game.players[jokerHolderIdx].hand[jokerCardIdx];
          const swapIdx = Math.floor(Math.random() * upstream.hand.length);
          game.players[jokerHolderIdx].hand[jokerCardIdx] = upstream.hand[swapIdx];
          upstream.hand[swapIdx] = jokerCard;
          game.humanDrawnJokerInRound0 = true;
          console.log("[æ•™å­¦] JOKERæ•™å­¦æˆåŠŸ");
          return;
        }
      }
    }
  }

  console.log(`[ensureHumanCanMatch] æ— ç‰¹æ®Šæ“ä½œ`);
}

// AIå®Œå…¨éšæœºæŠ½ç‰Œï¼ˆä¸è€ƒè™‘ A/B å¹³è¡¡ï¼Œé¿å…æ¸¸æˆå¤ªç®€å•ï¼‰
function getAiDrawIndex(game, aiPlayerIdx, targetPlayerIdx) {
  if (!game || game.gameOver) return -1;

  const target = game.players[targetPlayerIdx];
  if (!target || target.out || target.hand.length === 0) return -1;

  // å®Œå…¨éšæœºé€‰æ‹©
  return Math.floor(Math.random() * target.hand.length);
}

// æ ¹æ®AIæ‰‹ç‰Œæ•°é‡è®¡ç®—æŠ½ç‰Œå»¶è¿Ÿæ—¶é—´ï¼ˆå¢åŠ ç´§å¼ æ„Ÿï¼‰
function getAiDrawDelay(game, aiPlayerIdx) {
  const ai = game.players[aiPlayerIdx];
  if (!ai || ai.out) return 400; // é»˜è®¤å»¶è¿Ÿ

  const handCount = ai.hand.length;

  if (handCount >= 3) {
    // 3å¼ åŠä»¥ä¸Šï¼š0.3ç§’åˆ°0.7ç§’
    return 300 + Math.random() * 400;
  } else if (handCount === 2) {
    // 2å¼ ï¼š0.6ç§’åˆ°1ç§’
    return 600 + Math.random() * 400;
  } else if (handCount === 1) {
    // 1å¼ ï¼š0.8ç§’åˆ°1.4ç§’
    return 800 + Math.random() * 600;
  }

  return 400; // é»˜è®¤
}

// âŒ å·²åˆ é™¤ï¼švalidateGlobalPairIntegrity() - AIè™šæ‹ŸåŒ–åä¸éœ€è¦å…¨å±€é…å¯¹éªŒè¯

// âŒ å·²åˆ é™¤ï¼šfinalTwoPlayersCheck() - AIè™šæ‹ŸåŒ–åä¸éœ€è¦æœ€ç»ˆä¸¤äººæ£€æŸ¥

// âŒ å·²åˆ é™¤ï¼šfixUnmatchableCards() - AIè™šæ‹ŸåŒ–åä¸éœ€è¦ä¿®å¤ä¸å¯é…å¯¹çš„ç‰Œ

// æ£€æŸ¥æ¯ä¸ªç©å®¶çš„ A/B å¹³è¡¡çŠ¶æ€
function checkAllPlayersBalance(game) {
  console.log("=== ç©å®¶ A/B å¹³è¡¡æ£€æŸ¥ ===");
  for (let i = 0; i < game.players.length; i++) {
    const p = game.players[i];
    let aCount = 0, bCount = 0;
    for (const c of p.hand) {
      if (!c || c.type === "joker" || !c.side) continue;
      if (c.side === "A") aCount++;
      else if (c.side === "B") bCount++;
    }
    const diff = aCount - bCount;
    const status = Math.abs(diff) <= 1 ? "âœ…" : "âŒ";
    console.log(`${status} ${p.name}: A=${aCount} B=${bCount} å·®å¼‚=${diff} (æ‰‹ç‰Œ${p.hand.length}å¼ )`);
  }
  console.log("======================");
}

// Expose API on window for non-module usage.
window.Game = {
  createRng,
  shuffleInPlace,
  buildDeckFromImagePairs,
  initialDeal,
  dealConstrained22Pairs,
  dealPendingJokerToPlayer,
  discardAllPairsInPlace,
  findMatchIndex,
  nextActivePlayerIndex,
  prevActivePlayerIndex,
  countNonJokerCards,
  findJokerHolder,
  createGame,
  getNextPlayerIndex,
  getUpstreamPlayerIndex,
  canDrawFrom,
  drawCard,
  tryDiscardPairByCardIds,
  findAnyPairInHand,
  advanceTurn,
  upstreamHasMatchableCard,
  cheatSwapToUpstream,
  ensureHumanCanMatch,
  getAiDrawIndex,
  getAiDrawDelay,
  checkAllPlayersBalance,
};

