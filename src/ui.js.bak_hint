/* UI layer (DOM). No ES modules so file:// works. */

// Basic polyfills / diagnostics for mobile browsers
if (!window.CSS) window.CSS = {};
if (typeof window.CSS.escape !== "function") {
  window.CSS.escape = function (value) {
    // Minimal escape for use in attribute selectors.
    return String(value).replace(/[^a-zA-Z0-9_\-]/g, "\\$&");
  };
}

function showFatalError(err) {
  try {
    const msg = (err && (err.stack || err.message)) ? String(err.stack || err.message) : String(err);
    const box = document.createElement("div");
    box.style.position = "fixed";
    box.style.inset = "12px";
    box.style.zIndex = "20000";
    box.style.background = "rgba(0,0,0,0.78)";
    box.style.color = "white";
    box.style.padding = "12px";
    box.style.borderRadius = "14px";
    box.style.overflow = "auto";
    box.style.fontSize = "12px";
    box.style.whiteSpace = "pre-wrap";
    box.innerText = "é¡µé¢å‘ç”Ÿé”™è¯¯ï¼ˆè¯·æˆªå›¾å‘æˆ‘ï¼‰ï¼š\n\n" + msg;
    box.addEventListener("click", () => box.remove());
    document.body.appendChild(box);
  } catch {
    // ignore
  }
}

window.addEventListener("error", (e) => showFatalError(e.error || e.message || e), { passive: true });
window.addEventListener("unhandledrejection", (e) => showFatalError(e.reason || e), { passive: true });

function $(sel) {
  const el = document.querySelector(sel);
  if (!el) throw new Error(`Missing element: ${sel}`);
  return el;
}

function escapeHtml(s) {
  return String(s)
    .replaceAll("&", "&amp;")
    .replaceAll("<", "&lt;")
    .replaceAll(">", "&gt;")
    .replaceAll('"', "&quot;")
    .replaceAll("'", "&#039;");
}

function seatEls() {
  return {
    top: { name: $("#pTopName"), count: $("#pTopCount"), hand: $("#pTopHand") },
    left: { name: $("#pLeftName"), count: $("#pLeftCount"), hand: $("#pLeftHand") },
    right: { name: $("#pRightName"), count: $("#pRightCount"), hand: $("#pRightHand") },
    bottom: { name: $("#pBottomName"), count: $("#pBottomCount"), hand: $("#pBottomHand") },
  };
}

function renderSeats(game, opts = {}) {
  // ğŸ¯ æ¸²æŸ“å‰æ£€æŸ¥ï¼šå¦‚æœå‰©ä½™ä¸¤äººï¼Œè§¦å‘æœ€ç»ˆæ£€æŸ¥
  const activePlayers = game.players.filter(p => !p.out);
  if (activePlayers.length === 2 && !game.finalCheckDone) {
    console.log("[renderSeats] æ£€æµ‹åˆ°å‰©ä½™ä¸¤äººï¼Œè§¦å‘æœ€ç»ˆé…å¯¹æ£€æŸ¥...");
    if (window.Game && window.Game.finalTwoPlayersCheck) {
      window.Game.finalTwoPlayersCheck(game);
      game.finalCheckDone = true; // æ ‡è®°å·²æ£€æŸ¥ï¼Œé¿å…é‡å¤
    }
  }

  const dealMode = !!opts.deal;
  const animateExpand = !!opts.animateExpand; // new option: animate card repositioning
  // Fixed mapping: 0 bottom(you), 1 right, 2 top, 3 left.
  const map = seatEls();
  const seatByIdx = {
    0: map.bottom,
    1: map.right,
    2: map.top,
    3: map.left,
  };

  for (let i = 0; i < game.players.length; i++) {
    const p = game.players[i];
    const s = seatByIdx[i];
    if (!s) continue;
    s.name.innerHTML = `${escapeHtml(p.name)} ${p.kind === "ai" ? "<span class=\"pill\">AI</span>" : "<span class=\"pill\">ç©å®¶</span>"}`;

    // ğŸ†• æ˜¾ç¤ºå‰©ä½™æ‰‹ç‰Œæ•°é‡
    if (p.out) {
      s.count.textContent = "å·²å‡ºå®Œ";
    } else {
      // æ‰€æœ‰ç©å®¶ï¼šä»…æ˜¾ç¤ºå‰©ä½™æ‰‹ç‰Œæ•°é‡
      s.count.textContent = `${p.hand.length}`;
    }
  }

  // Render AI hands as backs only; human hand face-up.
  for (let i = 0; i < game.players.length; i++) {
    const p = game.players[i];
    const s = seatByIdx[i];

    // è·³è¿‡æ­£åœ¨åšè‡ªé€‚åº”è°ƒæ•´åŠ¨ç”»çš„æ‰‹ç‰ŒåŒºåŸŸ
    if (s.hand.dataset.adjusting === "true") {
      console.log(`[renderSeats] è·³è¿‡ç©å®¶${i}çš„æ‰‹ç‰Œæ¸²æŸ“ï¼Œæ­£åœ¨åšè‡ªé€‚åº”åŠ¨ç”»`);
      continue;
    }

    s.hand.innerHTML = "";
    if (i === 0) {
      // You: show face-up cards (selectable on table)
      const n = p.hand.length;
      const center = (n - 1) / 2;
      for (let idx = 0; idx < n; idx++) {
        const card = p.hand[idx];
        const div = document.createElement("div");
        div.className = `faceCard ${card.type === "joker" ? "joker imgCard" : ""} ${card.type === "img" ? "imgCard" : ""}`;
        div.dataset.cardId = card.id;
        if (dealMode) div.dataset.dealIndex = String(idx);

        // Fan layout (more readable: larger spacing between cards)
        // Cap overall width to avoid spilling off the bottom plank.
        const maxFanWidth = 920; // px (wider so text/images aren't covered)
        const spread = Math.min(62, maxFanWidth / Math.max(1, n - 1));
        const d = idx - center;
        div.style.setProperty("--x", `${d * spread}px`);
        div.style.setProperty("--rot", `${d * 0.9}deg`);
        div.style.setProperty("--y", `${Math.abs(d) * 0.8}px`);
        div.style.zIndex = String(100 + idx);

        // Add expand animation class when joker is dealt
        if (animateExpand) {
          div.style.transition = "transform 300ms cubic-bezier(0.22, 1, 0.36, 1)";
        }

        if (card.type === "joker") {
          div.dataset.corner = "";
          div.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
            </div>
          `;
        } else {
          div.dataset.corner = "";
          div.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="${escapeHtml(card.imgSrc)}" alt="card" draggable="false" /></div>
            </div>
          `;
        }
        s.hand.appendChild(div);
      }
    } else {
      // AI: show backs only. If it's your turn and this AI is upstream, render full clickable backs.
      const isHumanTurn = game.players[game.currentPlayerIndex].kind === "human";
      const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
      const isUpstreamForDraw = isHumanTurn && upstreamIdx === i && !game.turnHasDrawn;
      // Render as a pile like the reference: top zone piles sideways, left/right piles vertical.
      // ä½¿ç”¨çœŸå®æ‰‹ç‰Œæ•°é‡
      const showN = p.hand.length;
      const cCenter = (showN - 1) / 2;
      // Make the upstream pile clickable (tap pile -> open overlay).
      if (isUpstreamForDraw) s.hand.dataset.fromPlayerIndex = String(i);
      else s.hand.removeAttribute("data-from-player-index");

      for (let k = 0; k < showN; k++) {
        const b = document.createElement("div");
        b.className = "miniBack";
        if (dealMode) b.dataset.dealIndex = String(k);
        b.textContent = "";
        const d = k - cCenter;
        let sx = 0;
        let sy = 0;
        let srot = 0;
        if (i === 2) {
          // top player: pile spreads to the left (as in reference)
          sx = d * 12;
          sy = d * 0.3;
          srot = 0;
        } else {
          // left/right: pile spreads downward
          sx = d * 0.3;
          sy = d * 9;
          // rotate 90Â° around each card's center for side players
          srot = i === 1 || i === 3 ? 90 : 0;
        }
        b.style.setProperty("--sx", `${sx}px`);
        b.style.setProperty("--sy", `${sy}px`);
        b.style.setProperty("--srot", `${srot}deg`);
        b.style.transitionDelay = `0ms`;
        b.style.zIndex = String(10 + k);

        // Add expand animation when joker is dealt
        if (animateExpand) {
          b.style.transition = "left 300ms cubic-bezier(0.22, 1, 0.36, 1), top 300ms cubic-bezier(0.22, 1, 0.36, 1)";
        }

        s.hand.appendChild(b);
      }
    }
  }
}

// è®¡ç®—ä¸‹ä¸€å¼ å¡ç‰Œåœ¨å¼ƒç‰Œå †ä¸­çš„ z-indexï¼ˆå’Œ renderDiscardPile å®Œå…¨ä¸€è‡´çš„é€»è¾‘ï¼‰
function getDiscardPileZIndex(game) {
  if (!game || !game.discardPile) {
    return { leftZ: 10, rightZ: 100 };
  }

  const pairs = [];
  for (let i = 0; i < game.discardPile.length; i += 2) {
    pairs.push([game.discardPile[i], game.discardPile[i + 1]]);
  }
  const leftPile = pairs.map((p) => p[0]).filter(Boolean);
  const rightPile = pairs.map((p) => p[1]).filter(Boolean);

  return {
    leftZ: 10 + leftPile.length,   // ä¸‹ä¸€å¼ å·¦å¡çš„ z-index
    rightZ: 100 + rightPile.length  // ä¸‹ä¸€å¼ å³å¡çš„ z-index
  };
}

function renderDiscardPile(game) {
  const pile = $("#discardPile");
  const count = $("#discardCount");
  count.textContent = `å…± ${game.discardPile.length} å¼ `;
  pile.innerHTML = "";

  // Two-pile discard: each discarded *pair* becomes (leftPileCard, rightPileCard).http://127.0.0.1:8000/english-old-maid/assets/animal_cards/4_2_A.png
  // Next discard covers the previous (stacking), instead of spreading around.
  function hash01(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h >>> 0) % 10000) / 10000;
  }
  function rotJitter(cardId, idx) {
    return (hash01(`${cardId}|${idx}`) - 0.5) * 8; // -4..4 deg
  }

  const pairs = [];
  for (let i = 0; i < game.discardPile.length; i += 2) {
    pairs.push([game.discardPile[i], game.discardPile[i + 1]]);
  }
  const leftPile = pairs.map((p) => p[0]).filter(Boolean);
  const rightPile = pairs.map((p) => p[1]).filter(Boolean);

  const MAX_DEPTH = 18; // render last N layers for perf; older still exist logically
  const leftShown = leftPile.slice(-MAX_DEPTH);
  const rightShown = rightPile.slice(-MAX_DEPTH);

  function renderCardFaceUp(c, xPercent, yPercent, z) {
    const div = document.createElement("div");
    const isJoker = c.type === "joker";
    div.className = `discardCard ${isJoker ? "joker" : "imgDiscard"}`;
    div.style.left = `${xPercent}%`;
    div.style.top = `${yPercent}%`;
    const rotation = rotJitter(c.id, z);
    div.style.transform = `translate(-50%, -50%) rotate(${rotation}deg)`;
    div.style.zIndex = String(z);
    console.log(`[æ¸²æŸ“å¼ƒç‰Œ] cardId=${c.id}, z=${z}, rotation=${rotation.toFixed(2)}Â°`);

    if (isJoker) {
      div.dataset.corner = "";
      div.innerHTML = `
        <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
      `;
    } else {
      div.dataset.corner = "";
      div.innerHTML = `
        <div class="imgWrap"><img class="cardImg" src="${escapeHtml(c.imgSrc)}" alt="card" draggable="false" /></div>
      `;
    }

    pile.appendChild(div);
  }

  // Left pile center and right pile center inside the discard zone
  const leftX = 28;
  const rightX = 72;
  const baseY = 52;

  // Render bottom-to-top so newer cards cover older ones.
  for (let i = 0; i < leftShown.length; i++) {
    const c = leftShown[i];
    renderCardFaceUp(c, leftX, baseY, 10 + i);
  }
  for (let i = 0; i < rightShown.length; i++) {
    const c = rightShown[i];
    renderCardFaceUp(c, rightX, baseY, 100 + i);
  }
}

// no TTS in standard card mode

function flyToDiscard(fromEl) {
  const pile = $("#discardPile");
  const from = fromEl.getBoundingClientRect();
  const to = pile.getBoundingClientRect();

  // ä¸å…‹éš†ï¼Œç›´æ¥æ“ä½œåŸå§‹å¡ç‰Œå…ƒç´ 
  fromEl.classList.add("flyingCard");
  fromEl.style.position = "fixed";
  fromEl.style.left = `${from.left}px`;
  fromEl.style.top = `${from.top}px`;
  fromEl.style.width = `${from.width}px`;
  fromEl.style.height = `${from.height}px`;
  fromEl.style.margin = "0";
  fromEl.style.zIndex = "10000";
  fromEl.style.pointerEvents = "none";

  // è·å– .tableBg ä¸­å¿ƒç‚¹
  const tableBg = document.querySelector('.tableBg');
  const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
  const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
  const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

  // Determine target position based on card suffix (_A -> left, _B -> right)
  const cardId = fromEl.dataset.cardId || "";
  const isACard = cardId.includes("_A");
  const isBCard = cardId.includes("_B");

  // Calculate target position (matching renderDiscardPile positions)
  const leftX = 0.28;
  const rightX = 0.72;
  const targetXPercent = isACard ? leftX : (isBCard ? rightX : 0.5);

  const startX = from.left + from.width / 2;
  const startY = from.top + from.height / 2;
  const targetX = to.left + to.width * targetXPercent;
  const targetY = to.top + to.height * 0.52;

  // Calculate scale to match discardCard size (92px base width)
  const discardScale = getComputedStyle(document.documentElement).getPropertyValue('--scale-discard-pile') || "1";
  const targetWidth = 92 * parseFloat(discardScale);
  const scaleTarget = targetWidth / from.width;

  // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆä½¿ç”¨å’Œ renderDiscardPile å®Œå…¨ç›¸åŒçš„é€»è¾‘ï¼‰
  const { leftZ, rightZ } = window.game ? getDiscardPileZIndex(window.game) : { leftZ: 1, rightZ: 1 };
  const targetZ = isACard ? leftZ : (isBCard ? rightZ : leftZ);

  function hash01(str) {
    let h = 2166136261;
    for (let i = 0; i < str.length; i++) {
      h ^= str.charCodeAt(i);
      h = Math.imul(h, 16777619);
    }
    return ((h >>> 0) % 10000) / 10000;
  }
  const targetRotation = (hash01(`${cardId}|${targetZ}`) - 0.5) * 8;
  console.log(`[ç©å®¶å‡ºç‰Œ] cardId=${cardId}, targetZ=${targetZ}, rotation=${targetRotation.toFixed(2)}Â°`);

  // å¼§çº¿æ§åˆ¶ç‚¹ï¼šå›´ç»• .tableBg ä¸­å¿ƒ
  const midX = (startX + targetX) / 2;
  const midY = (startY + targetY) / 2;
  const toCenterX = centerX - midX;
  const toCenterY = centerY - midY;

  const dist = Math.sqrt(Math.pow(targetX - startX, 2) + Math.pow(targetY - startY, 2));
  const arcHeight = Math.min(80, dist * 0.3);
  const controlX = midX + toCenterX * 0.2;
  const controlY = midY + toCenterY * 0.2 - arcHeight;

  const steps = 30;
  const keyframes = [];
  const overshootDist = dist * 0.04;

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    let easeT, overshoot;

    if (t <= 0.68) {
      const t1 = t / 0.68;
      easeT = 1 - Math.pow(1 - t1, 2.5);
      overshoot = 1.04;
    } else {
      const t2 = (t - 0.68) / 0.32;
      const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
      easeT = 1.04 - 0.04 * easeT2;
      overshoot = easeT;
    }

    // è´å¡å°”æ›²çº¿è½¨è¿¹
    const arcT = Math.min(easeT, 1.0);
    const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*targetX;
    const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*targetY;

    const dirX = targetX - startX;
    const dirY = targetY - startY;
    const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
    const normX = dirLen > 0 ? dirX / dirLen : 0;
    const normY = dirLen > 0 ? dirY / dirLen : 0;
    const overshootAmount = (overshoot - 1.0) * overshootDist;

    const x = baseX + normX * overshootAmount;
    const y = baseY + normY * overshootAmount;

    const currentScale = 1 + (scaleTarget - 1) * Math.min(easeT, 1.0);
    const currentRotation = targetRotation * Math.min(easeT, 1.0);
    const opacity = 1 - 0.05 * Math.min(easeT, 1.0);

    keyframes.push({
      left: `${x}px`,
      top: `${y}px`,
      transform: `translate(-50%, -50%) scale(${currentScale}) rotate(${currentRotation}deg)`,
      opacity: opacity,
      offset: t
    });
  }

  const anim = fromEl.animate(keyframes, {
    duration: 520,
    easing: "linear"
  });

  anim.onfinish = () => {
    fromEl.remove();
  };

  return anim; // è¿”å›åŠ¨ç”»å¯¹è±¡ï¼Œæ–¹ä¾¿å¤–éƒ¨ç›‘å¬
}

function seatHandElByPlayerIndex(idx) {
  // Fixed mapping: 0 bottom(you), 1 right, 2 top, 3 left.
  if (idx === 0) return $("#pBottomHand");
  if (idx === 1) return $("#pRightHand");
  if (idx === 2) return $("#pTopHand");
  return $("#pLeftHand");
}

function flyFromRectToRect(fromRect, toRect, cardEl, playerIndex, onComplete) {
  // Handle both old (4 params) and new (5 params) signatures
  if (typeof playerIndex === 'function') {
    onComplete = playerIndex;
    playerIndex = 0; // default to player
  }

  // ä¸å…‹éš†ï¼Œç›´æ¥æ“ä½œåŸå§‹å¡ç‰Œå…ƒç´ 
  // å˜æˆ fixed å®šä½ï¼Œè„±ç¦»æ–‡æ¡£æµ
  cardEl.style.position = "fixed";
  cardEl.style.left = `${fromRect.left}px`;
  cardEl.style.top = `${fromRect.top}px`;
  cardEl.style.width = `${fromRect.width}px`;
  cardEl.style.height = `${fromRect.height}px`;
  cardEl.style.margin = "0";
  cardEl.style.zIndex = "10000";
  cardEl.style.pointerEvents = "none";

  // è·å– .tableBg ä¸­å¿ƒç‚¹ï¼ˆä½œä¸ºå¼§çº¿çš„å‚è€ƒç‚¹ï¼‰
  const tableBg = document.querySelector('.tableBg');
  const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
  const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
  const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

  const startX = fromRect.left + fromRect.width / 2;
  const startY = fromRect.top + fromRect.height / 2;
  const endX = toRect.left + toRect.width / 2;
  const endY = toRect.top + toRect.height / 2;

  // Calculate scale to match target card size
  const targetScale = toRect.width / fromRect.width;

  // å¼§çº¿æ§åˆ¶ç‚¹ï¼šå›´ç»• .tableBg ä¸­å¿ƒç‚¹
  // æ§åˆ¶ç‚¹ä½äºèµ·ç‚¹å’Œç»ˆç‚¹ä¹‹é—´ï¼Œä½†åå‘ä¸­å¿ƒ
  const midX = (startX + endX) / 2;
  const midY = (startY + endY) / 2;
  const toCenterX = centerX - midX;
  const toCenterY = centerY - midY;

  // å¼§çº¿é«˜åº¦ï¼šæ ¹æ®è·ç¦»å’Œä½ç½®åŠ¨æ€è°ƒæ•´
  const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
  const arcHeight = Math.min(200, dist * 0.4);
  const controlX = midX + toCenterX * 0.3; // 30% åå‘ä¸­å¿ƒ
  const controlY = midY + toCenterY * 0.3 - arcHeight; // åŠ ä¸Šå¼§çº¿é«˜åº¦

  // Determine rotation based on target player
  let targetRotation = 0;
  if (playerIndex === 3) targetRotation = 90;        // Left AI
  else if (playerIndex === 1) targetRotation = -90;  // Right AI
  else if (playerIndex === 2) targetRotation = -180; // Top AI
  else targetRotation = 0;                            // Player (bottom)

  const keyframes = [];
  const steps = 30;
  const overshootRatio = 0.05;
  const overshootDist = dist * overshootRatio;

  for (let i = 0; i <= steps; i++) {
    const t = i / steps;
    let easeT, overshoot;

    // Two-phase animation: approach with overshoot, then settle
    if (t <= 0.72) {
      const t1 = t / 0.72;
      easeT = 1 - Math.pow(1 - t1, 3);
      overshoot = 1.05;
    } else {
      const t2 = (t - 0.72) / 0.28;
      const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
      easeT = 1.05 - 0.05 * easeT2;
      overshoot = easeT;
    }

    // è´å¡å°”æ›²çº¿è½¨è¿¹ï¼ˆå›´ç»•ä¸­å¿ƒç‚¹çš„å¼§çº¿ï¼‰
    const baseX = (1-easeT)*(1-easeT)*startX + 2*(1-easeT)*easeT*controlX + easeT*easeT*endX;
    const baseY = (1-easeT)*(1-easeT)*startY + 2*(1-easeT)*easeT*controlY + easeT*easeT*endY;

    // æ·»åŠ è¿‡å†²
    const dirX = endX - startX;
    const dirY = endY - startY;
    const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
    const normX = dirLen > 0 ? dirX / dirLen : 0;
    const normY = dirLen > 0 ? dirY / dirLen : 0;
    const overshootAmount = (overshoot - 1.0) * overshootDist;
    const x = baseX + normX * overshootAmount;
    const y = baseY + normY * overshootAmount;

    const currentScale = 1 + (targetScale - 1) * Math.min(easeT, 1.0);
    const currentRotation = targetRotation * Math.min(easeT, 1.0);
    const flipRotation = playerIndex === 0 ? 0 : Math.min(easeT, 1.0) * 180;

    keyframes.push({
      left: `${x}px`,
      top: `${y}px`,
      transform: `translate(-50%, -50%) scale(${currentScale}) rotate(${currentRotation}deg) rotateY(${flipRotation}deg)`,
      opacity: 1 - 0.05 * Math.min(easeT, 1.0)
    });
  }

  cardEl.animate(keyframes, {
    duration: 560,
    easing: "linear"
  }).onfinish = () => {
    cardEl.remove();
    if (onComplete) onComplete();
  };
}

// Animate card draw with flying card (source -> target player hand)
// Physics-based arc trajectory with proper rotation and overshoot
function animateDrawCardFly(fromPlayerIdx, toPlayerIdx, drawnCard, onComplete) {
  console.log(`[animateDrawCardFly] è¢«è°ƒç”¨: from=${fromPlayerIdx} to=${toPlayerIdx}`, drawnCard);
  try {
    const fromHandEl = seatHandElByPlayerIndex(fromPlayerIdx);
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);
    console.log(`[animateDrawCardFly] fromHandEl:`, fromHandEl, "toHandEl:", toHandEl);
    if (!fromHandEl || !toHandEl) {
      console.log(`[animateDrawCardFly] å…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡åŠ¨ç”»`);
      if (onComplete) onComplete();
      return;
    }

    const fromRect = fromHandEl.getBoundingClientRect();
    console.log(`[animateDrawCardFly] fromRect:`, fromRect);
    const toRect = toHandEl.getBoundingClientRect();

    // è·å– .tableBg ä¸­å¿ƒç‚¹ä½œä¸ºå¼§çº¿å‚è€ƒ
    const tableBg = document.querySelector('.tableBg');
    const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
    const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
    const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

    // ğŸ”§ ä»å®é™…å¡ç‰Œä½ç½®è®¡ç®—èµ·ç‚¹ï¼Œè€Œä¸æ˜¯å®¹å™¨ä¸­å¿ƒ
    // è·å–æºæ‰‹ç‰Œçš„æœ€åä¸€å¼ å¡ç‰Œï¼ˆDOM é¡ºåºæœ€åï¼Œz-index æœ€é«˜ï¼Œè§†è§‰ä¸Šæœ€å‰é¢ä¸è¢«é®æŒ¡ï¼‰
    const allFromCards = fromHandEl.querySelectorAll('.miniBack, .faceCard');
    const topFromCard = allFromCards.length > 0 ? allFromCards[allFromCards.length - 1] : null;
    let startX, startY;

    if (topFromCard) {
      // å¦‚æœæœ‰å¡ç‰Œï¼Œä»æœ€åä¸€å¼ å¡ç‰Œï¼ˆæœ€ä¸Šå±‚ï¼‰çš„ä¸­å¿ƒå¼€å§‹
      const cardRect = topFromCard.getBoundingClientRect();
      startX = cardRect.left + cardRect.width / 2;
      startY = cardRect.top + cardRect.height / 2;
      console.log(`[animateDrawCardFly] ä½¿ç”¨æœ€åä¸€å¼ å¡ï¼ˆæœ€ä¸Šå±‚ï¼‰ä½œä¸ºèµ·ç‚¹:`, cardRect);
    } else {
      // å¦‚æœæ²¡æœ‰å¡ç‰Œï¼ˆæ‰‹ç‰Œä¸ºç©ºï¼‰ï¼Œä½¿ç”¨å®¹å™¨ä¸­å¿ƒ + zoneé«˜åº¦ä¼°ç®—
      const zoneRect = fromHandEl.parentElement.getBoundingClientRect();
      startX = fromRect.left + fromRect.width / 2;
      startY = zoneRect.top + zoneRect.height / 2;
      console.log(`[animateDrawCardFly] æºæ‰‹ç‰Œæ— å¡ç‰Œï¼Œä½¿ç”¨zoneä¸­å¿ƒä¼°ç®—:`, zoneRect);
    }

    // è®¡ç®—ç»ˆç‚¹ï¼šæ ¹æ®ç›®æ ‡ç©å®¶ç±»å‹é€‰æ‹©ä¸åŒçš„è®¡ç®—æ–¹å¼
    console.log(`[animateDrawCardFly] æ£€æŸ¥ window.game:`, window.game);
    const toPlayer = (window.game && window.game.players) ? window.game.players[toPlayerIdx] : null;
    console.log(`[animateDrawCardFly] toPlayer:`, toPlayer);

    let endX, endY;

    if (toPlayerIdx === 0) {
      // ç©å®¶æ‰‹ç‰Œï¼šé£åˆ°æ‰‡å½¢æ’åˆ—çš„æœ€åä¸€å¼ 
      const futureHandCount = toPlayer ? toPlayer.hand.length + 1 : 1;
      const center = (futureHandCount - 1) / 2;
      const lastCardIndex = futureHandCount - 1;
      const d = lastCardIndex - center;
      const spread = Math.min(62, 920 / Math.max(1, futureHandCount - 1));

      endX = toRect.left + toRect.width / 2 + d * spread;
      endY = toRect.top + 18 + 62 + Math.abs(d) * 0.8;
    } else {
      // AI æ‰‹ç‰Œï¼šé£åˆ°æœ€åä¸€å¼ å¡çš„ä¸­å¿ƒï¼ˆDOM é¡ºåºæœ€åä¸€ä¸ªï¼Œz-index æœ€é«˜ï¼Œè§†è§‰ä¸Šæœ€å‰é¢ä¸è¢«é®æŒ¡ï¼‰
      const allCards = toHandEl.querySelectorAll('.miniBack');
      const topCard = allCards.length > 0 ? allCards[allCards.length - 1] : null;
      if (topCard) {
        const cardRect = topCard.getBoundingClientRect();
        let targetX = cardRect.left + cardRect.width / 2;
        let targetY = cardRect.top + cardRect.height / 2;

        // å‘å±å¹•ä¸­å¿ƒåç§»15%çš„è·ç¦»ï¼Œè®©å¡ç‰Œä¸é£å¾—å¤ªè¿œ
        const offsetRatio = 0.15;
        const towardCenterX = (centerX - targetX) * offsetRatio;
        const towardCenterY = (centerY - targetY) * offsetRatio;

        // é¢å¤–å‘ä¸Šåç§»ï¼Œé¿å…æ•´ä½“åä¸‹
        const upwardOffset = 20; // å‘ä¸Šåç§»20px

        endX = targetX + towardCenterX;
        endY = targetY + towardCenterY - upwardOffset;
        console.log(`[animateDrawCardFly] ä½¿ç”¨æœ€åä¸€å¼ å¡ï¼ˆæœ€ä¸Šå±‚ï¼‰ä½ç½®, å‘ä¸­å¿ƒåç§»15%, å‘ä¸Šåç§»${upwardOffset}px, z-index=${topCard.style.zIndex}, ä¸­å¿ƒ:(${endX.toFixed(1)}, ${endY.toFixed(1)})`);
      } else {
        // å¦‚æœæ²¡æœ‰å¡ç‰Œï¼Œä½¿ç”¨æ‰‹ç‰ŒåŒºåŸŸä¸­å¿ƒ
        endX = toRect.left + toRect.width / 2;
        endY = toRect.top + toRect.height / 2;
        console.log(`[animateDrawCardFly] æ— å¡ç‰Œï¼Œä½¿ç”¨åŒºåŸŸä¸­å¿ƒ`);
      }
    }

    console.log(`[animateDrawCardFly] æœ€ç»ˆç»ˆç‚¹ä½ç½®: (${endX}, ${endY})`);

    // ç¡®å®šç›®æ ‡ç©å®¶æ‰‹ç‰Œçš„å®é™…å¡ç‰Œå°ºå¯¸ï¼ˆç”¨äºç¼©æ”¾ï¼‰
    let targetCardWidth, targetCardHeight;
    if (toPlayerIdx === 0) {
      // ç©å®¶æ‰‹ç‰Œï¼ˆåº•éƒ¨ï¼‰
      const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 0.85;
      targetCardWidth = 86 * scalePlayer;
      targetCardHeight = 124 * scalePlayer;
    } else if (toPlayerIdx === 2) {
      // AIä¸Šå®¶
      const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1.29;
      targetCardWidth = 52 * scaleTop;
      targetCardHeight = 72 * scaleTop;
    } else {
      // AIå·¦å³å®¶
      const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1.25;
      targetCardWidth = 64 * scaleSide;
      targetCardHeight = 89 * scaleSide;
    }

    // åˆ›å»ºé£è¡Œå¡ç‰Œï¼ˆåŒé¢ç»“æ„ï¼šæ­£é¢+èƒŒé¢ï¼‰
    const showFace = fromPlayerIdx === 0; // ä»äººç±»ç©å®¶æ‰‹ä¸­æŠ½å‡ºæ—¶æ˜¾ç¤ºæ­£é¢

    // ç¿»è½¬å®¹å™¨
    const flipContainer = document.createElement("div");
    flipContainer.style.width = "86px";
    flipContainer.style.height = "124px";
    flipContainer.style.position = "fixed";
    flipContainer.style.transformStyle = "preserve-3d";
    flipContainer.style.perspective = "1000px";
    flipContainer.style.left = `${startX - 43}px`;
    flipContainer.style.top = `${startY - 62}px`;
    flipContainer.style.zIndex = "10005";
    flipContainer.style.pointerEvents = "none";

    // èƒŒé¢ç‰Œ
    const backCard = document.createElement("div");
    backCard.className = "miniBack";
    backCard.style.width = "86px";
    backCard.style.height = "124px";
    backCard.style.position = "absolute";
    backCard.style.backfaceVisibility = "hidden";
    backCard.style.transform = "rotateY(0deg)";

    // æ­£é¢ç‰Œ
    const frontCard = document.createElement("div");
    frontCard.className = `faceCard ${drawnCard && drawnCard.type === "joker" ? "joker imgCard" : ""} ${drawnCard && drawnCard.type === "img" ? "imgCard" : ""}`;
    frontCard.style.width = "86px";
    frontCard.style.height = "124px";
    frontCard.style.position = "absolute";
    frontCard.style.backfaceVisibility = "hidden";
    frontCard.style.transform = "rotateY(180deg)";

    if (drawnCard) {
      if (drawnCard.type === "joker") {
        frontCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
          </div>
        `;
      } else {
        frontCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" draggable="false" /></div>
          </div>
        `;
      }
    }

    flipContainer.appendChild(backCard);
    flipContainer.appendChild(frontCard);
    document.body.appendChild(flipContainer);
    console.log(`[animateDrawCardFly] å¡ç‰Œå…ƒç´ å·²æ·»åŠ åˆ°body, èµ·ç‚¹:(${startX}, ${startY}) ç»ˆç‚¹:(${endX}, ${endY})`);

    // è®¡ç®—å¼§çº¿æ§åˆ¶ç‚¹ï¼ˆå›´ç»• .tableBg ä¸­å¿ƒï¼‰
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const toCenterX = centerX - midX;
    const toCenterY = centerY - midY;

    const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    const arcHeight = Math.min(200, dist * 0.4); // å¼§çº¿é«˜åº¦
    const controlX = midX + toCenterX * 0.3;
    const controlY = midY + toCenterY * 0.3 - arcHeight;

    // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦
    let targetRotZ = 0;
    if (toPlayerIdx === 3) targetRotZ = 90;        // å·¦ä¾§AI
    else if (toPlayerIdx === 1) targetRotZ = -90;  // å³ä¾§AI
    else if (toPlayerIdx === 2) targetRotZ = 180;  // ä¸Šæ–¹AI
    else targetRotZ = 0;                            // ç©å®¶ï¼ˆåº•éƒ¨ï¼‰

    // è®¡ç®—ç›®æ ‡ç¼©æ”¾
    const targetScale = targetCardWidth / 86;

    // ç”Ÿæˆå…³é”®å¸§ï¼ˆè´å¡å°”æ›²çº¿ + è¿‡å†²ï¼‰
    const steps = 30;
    const keyframes = [];
    const overshootDist = dist * 0.05; // 5% è¿‡å†²

    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      let easeT, overshoot;

      // ä¸¤é˜¶æ®µç¼“åŠ¨ï¼šåŠ é€Ÿæ¥è¿‘ï¼ˆ68%ï¼‰+ è¿‡å†²å›è½ï¼ˆ32%ï¼‰
      if (t <= 0.72) {
        const t1 = t / 0.72;
        easeT = 1 - Math.pow(1 - t1, 3); // ease-out
        overshoot = 1.05; // 5% è¿‡å†²
      } else {
        const t2 = (t - 0.72) / 0.28;
        const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
        easeT = 1.05 - 0.05 * easeT2; // ä» 1.05 å›åˆ° 1.0
        overshoot = easeT;
      }

      // è´å¡å°”æ›²çº¿è½¨è¿¹ï¼ˆäºŒæ¬¡ï¼‰
      const arcT = Math.min(easeT, 1.0);
      const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*endX;
      const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*endY;

      // æ·»åŠ è¿‡å†²ï¼ˆæ²¿è¿åŠ¨æ–¹å‘ï¼‰
      const dirX = endX - startX;
      const dirY = endY - startY;
      const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
      const normX = dirLen > 0 ? dirX / dirLen : 0;
      const normY = dirLen > 0 ? dirY / dirLen : 0;
      const overshootAmount = (overshoot - 1.0) * overshootDist;

      const x = baseX + normX * overshootAmount;
      const y = baseY + normY * overshootAmount;

      // å¹³æ»‘ç¼©æ”¾
      const currentScale = 1 + (targetScale - 1) * Math.min(arcT, 1.0);

      // Zè½´æ—‹è½¬ï¼ˆå¯¹é½ç›®æ ‡ç©å®¶æ‰‹ç‰Œæ–¹å‘ï¼‰
      const currentRotZ = targetRotZ * Math.min(arcT, 1.0);

      // Yè½´ç¿»è½¬ï¼ˆä»äººç±»æ‰‹ä¸­æŠ½å‡ºæ—¶ï¼šæ­£é¢â†’èƒŒé¢ï¼›ä»AIæ‰‹ä¸­æŠ½åˆ°äººç±»æ‰‹ä¸­ï¼šèƒŒé¢â†’æ­£é¢ï¼‰
      let flipRotY = 0;
      if (showFace) {
        // ä»äººç±»æ‰‹ä¸­æŠ½å‡ºï¼šæ­£é¢(0deg) â†’ èƒŒé¢(180deg)
        flipRotY = Math.min(arcT, 1.0) * 180;
      } else if (toPlayerIdx === 0) {
        // æŠ½åˆ°äººç±»æ‰‹ä¸­ï¼šèƒŒé¢(0deg) â†’ æ­£é¢(180deg)
        flipRotY = Math.min(arcT, 1.0) * 180;
      }
      // AIä¹‹é—´æŠ½ç‰Œï¼šä¸ç¿»è½¬ï¼Œä¿æŒèƒŒé¢

      // æ·¡å‡ºæ•ˆæœ
      const opacity = 1 - 0.05 * Math.min(arcT, 1.0);

      keyframes.push({
        left: `${x - 43}px`,
        top: `${y - 62}px`,
        transform: `scale(${currentScale}) rotateZ(${currentRotZ}deg) rotateY(${flipRotY}deg)`,
        opacity: opacity,
        offset: t
      });
    }

    // æ‰§è¡ŒåŠ¨ç”»
    console.log(`[animateDrawCardFly] å¼€å§‹æ‰§è¡ŒåŠ¨ç”», keyframesæ•°é‡:`, keyframes.length);
    const anim = flipContainer.animate(keyframes, {
      duration: 560,
      easing: "linear", // ç¼“åŠ¨å·²åœ¨å…³é”®å¸§ä¸­æ‰‹åŠ¨å®ç°
      fill: "forwards"  // ä¿æŒæœ€ç»ˆçŠ¶æ€ï¼Œé¿å…è·³å›åˆå§‹ä½ç½®
    });
    console.log(`[animateDrawCardFly] åŠ¨ç”»å¯¹è±¡åˆ›å»ºå®Œæˆ, playState:`, anim.playState);

    anim.onfinish = () => {
      console.log(`[animateDrawCardFly] åŠ¨ç”»å®Œæˆ`);
      flipContainer.remove();
      if (onComplete) onComplete();
    };
  } catch (e) {
    console.error("âŒâŒâŒ animateDrawCardFly å‘ç”Ÿé”™è¯¯:", e);
    console.error("é”™è¯¯å †æ ˆ:", e.stack);
    if (onComplete) onComplete();
  }
}

// Animate card draw from a specific point (used when drawing from overlay)
// startX/startY: the actual pixel position where the card currently is
function animateDrawCardFlyFromPoint(startX, startY, toPlayerIdx, drawnCard, onComplete) {
  console.log("[animateDrawCardFlyFromPoint] å¼€å§‹", { startX, startY, toPlayerIdx, drawnCard });
  try {
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);
    console.log("[animateDrawCardFlyFromPoint] toHandEl:", toHandEl);
    if (!toHandEl) {
      console.log("[animateDrawCardFlyFromPoint] é”™è¯¯ï¼šæ‰¾ä¸åˆ°ç›®æ ‡æ‰‹ç‰Œå…ƒç´ ");
      if (onComplete) onComplete();
      return;
    }

    const toRect = toHandEl.getBoundingClientRect();

    // è·å– .tableBg ä¸­å¿ƒç‚¹ä½œä¸ºå¼§çº¿å‚è€ƒ
    const tableBg = document.querySelector('.tableBg');
    const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
    const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
    const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

    // ç»ˆç‚¹ï¼ˆä¸­å¿ƒåæ ‡ï¼‰
    const endX = toRect.left + toRect.width / 2;
    const endY = toRect.top + toRect.height / 2;

    // ç¡®å®šç›®æ ‡ç©å®¶æ‰‹ç‰Œçš„å®é™…å¡ç‰Œå°ºå¯¸ï¼ˆç”¨äºç¼©æ”¾ï¼‰
    let targetCardWidth, targetCardHeight;
    if (toPlayerIdx === 0) {
      // ç©å®¶æ‰‹ç‰Œï¼ˆåº•éƒ¨ï¼‰
      const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 0.85;
      targetCardWidth = 86 * scalePlayer;
      targetCardHeight = 124 * scalePlayer;
    } else if (toPlayerIdx === 2) {
      // AIä¸Šå®¶
      const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1.29;
      targetCardWidth = 52 * scaleTop;
      targetCardHeight = 72 * scaleTop;
    } else {
      // AIå·¦å³å®¶
      const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1.25;
      targetCardWidth = 64 * scaleSide;
      targetCardHeight = 89 * scaleSide;
    }

    // åˆ›å»ºé£è¡Œå¡ç‰Œï¼ˆå·²ç»æ˜¯æ­£é¢äº†ï¼Œå› ä¸ºåœ¨æŠ½ç‰Œç•Œé¢å·²ç»ç¿»è½¬è¿‡äº†ï¼‰
    const flyingCard = document.createElement("div");
    flyingCard.className = `faceCard ${drawnCard && drawnCard.type === "joker" ? "joker imgCard" : ""} ${drawnCard && drawnCard.type === "img" ? "imgCard" : ""}`;
    flyingCard.style.width = "140px"; // æŠ½ç‰Œç•Œé¢å¡ç‰Œå°ºå¯¸
    flyingCard.style.height = "196px";
    flyingCard.style.position = "fixed";
    flyingCard.style.left = `${startX - 70}px`;
    flyingCard.style.top = `${startY - 98}px`;
    flyingCard.style.zIndex = "10005";
    flyingCard.style.pointerEvents = "none";

    if (drawnCard) {
      if (drawnCard.type === "joker") {
        flyingCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
          </div>
        `;
      } else {
        flyingCard.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" draggable="false" /></div>
          </div>
        `;
      }
    }

    document.body.appendChild(flyingCard);

    // è®¡ç®—å¼§çº¿æ§åˆ¶ç‚¹ï¼ˆå›´ç»• .tableBg ä¸­å¿ƒï¼‰
    const midX = (startX + endX) / 2;
    const midY = (startY + endY) / 2;
    const toCenterX = centerX - midX;
    const toCenterY = centerY - midY;

    const dist = Math.sqrt(Math.pow(endX - startX, 2) + Math.pow(endY - startY, 2));
    const arcHeight = Math.min(200, dist * 0.4); // å¼§çº¿é«˜åº¦
    const controlX = midX + toCenterX * 0.3;
    const controlY = midY + toCenterY * 0.3 - arcHeight;

    // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆç©å®¶æ‰‹ç‰Œä¸æ—‹è½¬ï¼Œä¿æŒ0åº¦ï¼‰
    const targetRotZ = 0; // ç©å®¶æ‰‹ç‰Œå§‹ç»ˆæ˜¯0åº¦

    // è®¡ç®—ç›®æ ‡ç¼©æ”¾ï¼ˆä»æŠ½ç‰Œç•Œé¢140pxç¼©æ”¾åˆ°ç©å®¶æ‰‹ç‰Œå°ºå¯¸ï¼‰
    const targetScale = targetCardWidth / 140;

    // ç”Ÿæˆå…³é”®å¸§ï¼ˆè´å¡å°”æ›²çº¿ + è¿‡å†²ï¼‰
    const steps = 30;
    const keyframes = [];
    const overshootDist = dist * 0.05; // 5% è¿‡å†²

    for (let i = 0; i <= steps; i++) {
      const t = i / steps;
      let easeT, overshoot;

      // ä¸¤é˜¶æ®µç¼“åŠ¨ï¼šåŠ é€Ÿæ¥è¿‘ï¼ˆ68%ï¼‰+ è¿‡å†²å›è½ï¼ˆ32%ï¼‰
      if (t <= 0.72) {
        const t1 = t / 0.72;
        easeT = 1 - Math.pow(1 - t1, 3); // ease-out
        overshoot = 1.05; // 5% è¿‡å†²
      } else {
        const t2 = (t - 0.72) / 0.28;
        const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
        easeT = 1.05 - 0.05 * easeT2; // ä» 1.05 å›åˆ° 1.0
        overshoot = easeT;
      }

      // è´å¡å°”æ›²çº¿è½¨è¿¹ï¼ˆäºŒæ¬¡ï¼‰
      const arcT = Math.min(easeT, 1.0);
      const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*endX;
      const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*endY;

      // æ·»åŠ è¿‡å†²ï¼ˆæ²¿è¿åŠ¨æ–¹å‘ï¼‰
      const dirX = endX - startX;
      const dirY = endY - startY;
      const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
      const normX = dirLen > 0 ? dirX / dirLen : 0;
      const normY = dirLen > 0 ? dirY / dirLen : 0;
      const overshootAmount = (overshoot - 1.0) * overshootDist;

      const x = baseX + normX * overshootAmount;
      const y = baseY + normY * overshootAmount;

      // å¹³æ»‘ç¼©æ”¾
      const currentScale = 1 + (targetScale - 1) * Math.min(arcT, 1.0);

      // æ·¡å‡ºæ•ˆæœ
      const opacity = 1 - 0.05 * Math.min(arcT, 1.0);

      keyframes.push({
        left: `${x - 70}px`,
        top: `${y - 98}px`,
        transform: `scale(${currentScale})`,
        opacity: opacity,
        offset: t
      });
    }

    // æ‰§è¡ŒåŠ¨ç”»
    console.log("[animateDrawCardFlyFromPoint] å¼€å§‹åŠ¨ç”», keyframesæ•°é‡:", keyframes.length);
    const anim = flyingCard.animate(keyframes, {
      duration: 560,
      easing: "linear" // ç¼“åŠ¨å·²åœ¨å…³é”®å¸§ä¸­æ‰‹åŠ¨å®ç°
    });

    anim.onfinish = () => {
      console.log("[animateDrawCardFlyFromPoint] åŠ¨ç”»å®Œæˆï¼Œç§»é™¤å¡ç‰Œå¹¶è°ƒç”¨å›è°ƒ");
      flyingCard.remove();
      if (onComplete) {
        console.log("[animateDrawCardFlyFromPoint] è°ƒç”¨ onComplete");
        onComplete();
      } else {
        console.log("[animateDrawCardFlyFromPoint] è­¦å‘Šï¼šonComplete ä¸ºç©º");
      }
    };
  } catch (e) {
    console.error("animateDrawCardFlyFromPoint error:", e);
    if (onComplete) onComplete();
  }
}

// Animate AI discard pair: show two face-up cards flying from AI hand to discard pile
// Uses physics-based arc trajectory with overshoot and settle-back
// AI discard pair: simplified animation like player's flyToDiscard
function animateAiDiscardPair(playerIdx, card1, card2, fromRectOverride, onComplete) {
  // Handle parameter: if 4th param is function, no fromRectOverride provided
  if (typeof fromRectOverride === 'function') {
    onComplete = fromRectOverride;
    fromRectOverride = null;
  }

  console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] AI${playerIdx} å¼€å§‹ç®€åŒ–å‡ºç‰ŒåŠ¨ç”»`);
  try {
    const fromHandEl = seatHandElByPlayerIndex(playerIdx);
    const discardPile = document.getElementById("discardPile");
    if (!fromHandEl || !discardPile) {
      console.log(`[AIå‡ºç‰ŒåŠ¨ç”»] å…ƒç´ æœªæ‰¾åˆ°ï¼Œè·³è¿‡åŠ¨ç”»`);
      if (onComplete) onComplete();
      return;
    }

    const fromRect = fromRectOverride || fromHandEl.getBoundingClientRect();
    const toRect = discardPile.getBoundingClientRect();

    // å­¦ä¹ ç©å®¶ï¼šåœ¨åŠ¨ç”»å¼€å§‹å‰ï¼Œå¹³æ»‘è°ƒæ•´å‰©ä½™AIæ‰‹ç‰Œä½ç½®ï¼ˆå¡«è¡¥ç©ºç¼ºï¼‰
    const aiPlayer = window.game?.players?.[playerIdx];
    if (aiPlayer) {
      const currentN = aiPlayer.hand.length; // å½“å‰æ‰‹ç‰Œæ•°é‡
      const newN = currentN - 2; // å‡ºç‰Œåçš„æ•°é‡ï¼ˆå³å°†å‡2ï¼‰
      const allBackCards = Array.from(fromHandEl.querySelectorAll('.miniBack'));

      // æ ‡è®°æ‰‹ç‰ŒåŒºåŸŸæ­£åœ¨åšè‡ªé€‚åº”åŠ¨ç”»ï¼Œé˜²æ­¢ renderSeats é‡æ–°æ¸²æŸ“
      fromHandEl.dataset.adjusting = "true";

      // è®¡ç®—æ–°çš„å¸ƒå±€å‚æ•°
      const newCenter = (newN - 1) / 2;

      allBackCards.forEach((backCard, k) => {
        const d = k - newCenter;
        let sx = 0;
        let sy = 0;
        let srot = 0;

        if (playerIdx === 2) {
          // Top player: æ¨ªå‘å±•å¼€
          sx = d * 12;
          sy = d * 0.3;
          srot = 0;
        } else {
          // Left/Right: çºµå‘å±•å¼€
          sx = d * 0.3;
          sy = d * 9;
          srot = playerIdx === 1 || playerIdx === 3 ? 90 : 0;
        }

        // æ·»åŠ transitionå¹¶æ›´æ–°ä½ç½®ï¼ˆå­¦ä¹ ç©å®¶çš„ 420ms cubic-bezierï¼‰
        backCard.style.transition = "left 420ms cubic-bezier(0.22, 1, 0.36, 1), top 420ms cubic-bezier(0.22, 1, 0.36, 1), transform 420ms cubic-bezier(0.22, 1, 0.36, 1)";

        requestAnimationFrame(() => {
          backCard.style.setProperty("--sx", `${sx}px`);
          backCard.style.setProperty("--sy", `${sy}px`);
          backCard.style.setProperty("--srot", `${srot}deg`);
        });
      });

      // ç­‰å¾…å‡ºç‰ŒåŠ¨ç”»å®Œæˆåå†æ¸…é™¤æ ‡è®°ï¼ˆ520ms + 50ms bufferï¼‰
      setTimeout(() => {
        fromHandEl.dataset.adjusting = "";
      }, 570);
    }

    // Sort cards: _A to left pile, _B to right pile
    let leftCard, rightCard;
    if (card1.imgSrc && card1.imgSrc.includes("_A.")) {
      leftCard = card1;
      rightCard = card2;
    } else if (card2.imgSrc && card2.imgSrc.includes("_A.")) {
      leftCard = card2;
      rightCard = card1;
    } else {
      leftCard = card1;
      rightCard = card2;
    }

    const cards = [leftCard, rightCard];
    let completed = 0;

    // Hash function for consistent rotation angles
    function hash01(str) {
      let h = 2166136261;
      for (let i = 0; i < str.length; i++) {
        h ^= str.charCodeAt(i);
        h = Math.imul(h, 16777619);
      }
      return ((h >>> 0) % 10000) / 10000;
    }

    // Calculate z-index for each card (ä½¿ç”¨å’Œ renderDiscardPile å®Œå…¨ç›¸åŒçš„é€»è¾‘)
    const { leftZ, rightZ } = window.game ? getDiscardPileZIndex(window.game) : { leftZ: 1, rightZ: 1 };

    cards.forEach((card, index) => {
      // é£è¡Œå¡ç‰Œä½¿ç”¨å¼ƒç‰Œå †çš„åŸºç¡€å¤§å°ï¼ˆ92x132ï¼‰ï¼Œç¡®ä¿å®Œç¾åŒ¹é…
      const flyingCardWidth = 92;
      const flyingCardHeight = 132;

      // å¤–å±‚å®¹å™¨ï¼šè´Ÿè´£ä½ç½®å’Œç§»åŠ¨
      const outerContainer = document.createElement("div");
      outerContainer.style.width = flyingCardWidth + "px";
      outerContainer.style.height = flyingCardHeight + "px";
      outerContainer.style.position = "fixed";
      outerContainer.style.zIndex = "10000";
      outerContainer.style.pointerEvents = "none";

      // å†…å±‚ç¿»è½¬å®¹å™¨ï¼šä¸“é—¨è´Ÿè´£ Y è½´ç¿»è½¬
      const flipContainer = document.createElement("div");
      flipContainer.style.width = "100%";
      flipContainer.style.height = "100%";
      flipContainer.style.transformStyle = "preserve-3d";
      flipContainer.style.position = "relative";

      // åˆ›å»ºèƒŒé¢å…ƒç´ 
      const backFace = document.createElement("div");
      backFace.className = "miniBack";
      backFace.style.width = flyingCardWidth + "px";
      backFace.style.height = flyingCardHeight + "px";
      backFace.style.position = "absolute";
      backFace.style.left = "0";
      backFace.style.top = "0";
      backFace.style.backfaceVisibility = "hidden";
      backFace.style.transform = "rotateY(0deg)";

      // åˆ›å»ºæ­£é¢å…ƒç´ ï¼ˆåˆå§‹ä¸ºç©ºèƒŒæ™¯ï¼Œ90Â° æ—¶å¡«å……ï¼‰
      const frontFace = document.createElement("div");
      frontFace.style.width = flyingCardWidth + "px";
      frontFace.style.height = flyingCardHeight + "px";
      frontFace.style.position = "absolute";
      frontFace.style.left = "0";
      frontFace.style.top = "0";
      frontFace.style.backfaceVisibility = "hidden";
      frontFace.style.transform = "rotateY(180deg)";
      // åˆå§‹æ˜¾ç¤ºä¸€ä¸ªç©ºçš„å¡ç‰ŒèƒŒæ™¯ï¼Œé¿å…å®Œå…¨é€æ˜
      frontFace.style.background = "rgba(255,255,255,0.1)";
      frontFace.style.border = "1px solid rgba(0,0,0,0.16)";
      frontFace.style.borderRadius = "10px";

      flipContainer.appendChild(backFace);
      flipContainer.appendChild(frontFace);
      outerContainer.appendChild(flipContainer);

      // Staggered start position
      const startOffsetX = (index - 0.5) * 40;
      const startOffsetY = index * -8;

      // èµ·ç‚¹ï¼šæ‰‹ç‰ŒåŒºåŸŸä¸­å¿ƒ
      const startX = fromRect.left + fromRect.width / 2 + startOffsetX;
      const startY = fromRect.top + fromRect.height / 2 + startOffsetY;

      outerContainer.style.left = `${startX}px`;
      outerContainer.style.top = `${startY}px`;
      document.body.appendChild(outerContainer);

      // ç›®æ ‡ä½ç½®ï¼š28% (left) / 72% (right)
      const targetXPercent = index === 0 ? 0.28 : 0.72;
      const targetX = toRect.left + toRect.width * targetXPercent;
      const targetY = toRect.top + toRect.height * 0.52;

      // ç›®æ ‡ç¼©æ”¾ï¼ˆé£è¡Œå¡ç‰Œåˆå§‹å¤§å°æ˜¯ 92x132ï¼Œç¼©æ”¾åˆ°å¼ƒç‰Œå †å¤§å°ï¼‰
      const discardScale = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-discard-pile') || "0.82");
      const scaleTarget = discardScale; // ä» 92 ç¼©æ”¾åˆ° 92*scaleï¼Œç›´æ¥ç”¨ scale å³å¯

      // ç›®æ ‡æ—‹è½¬è§’åº¦ï¼ˆå’Œå¼ƒç‰Œå †ä¸€è‡´ï¼‰
      const zIndex = index === 0 ? leftZ : rightZ;
      const targetRotation = (hash01(`${card.id}|${zIndex}`) - 0.5) * 8;
      console.log(`[AIå‡ºç‰Œ] Card${index} cardId=${card.id}, targetZ=${zIndex}, rotation=${targetRotation.toFixed(2)}Â°`);

      // è·å– .tableBg ä¸­å¿ƒç‚¹
      const tableBg = document.querySelector('.tableBg');
      const tableBgRect = tableBg ? tableBg.getBoundingClientRect() : null;
      const centerX = tableBgRect ? tableBgRect.left + tableBgRect.width / 2 : window.innerWidth / 2;
      const centerY = tableBgRect ? tableBgRect.top + tableBgRect.height / 2 : window.innerHeight / 2;

      // å¼§çº¿æ§åˆ¶ç‚¹ï¼šå›´ç»• .tableBg ä¸­å¿ƒ
      const midX = (startX + targetX) / 2;
      const midY = (startY + targetY) / 2;
      const toCenterX = centerX - midX;
      const toCenterY = centerY - midY;

      const dist = Math.sqrt(Math.pow(targetX - startX, 2) + Math.pow(targetY - startY, 2));
      const arcHeight = Math.min(80, dist * 0.3);
      const controlX = midX + toCenterX * 0.2;
      const controlY = midY + toCenterY * 0.2 - arcHeight;

      const steps = 30;
      const outerKeyframes = []; // å¤–å±‚ï¼šä½ç½®ã€ç¼©æ”¾ã€æ—‹è½¬
      const flipKeyframes = [];  // å†…å±‚ï¼šYè½´ç¿»è½¬
      const overshootDist = dist * 0.04;

      for (let i = 0; i <= steps; i++) {
        const t = i / steps;
        let easeT, overshoot;

        if (t <= 0.68) {
          const t1 = t / 0.68;
          easeT = 1 - Math.pow(1 - t1, 2.5);
          overshoot = 1.04;
        } else {
          const t2 = (t - 0.68) / 0.32;
          const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
          easeT = 1.04 - 0.04 * easeT2;
          overshoot = easeT;
        }

        // è´å¡å°”æ›²çº¿è½¨è¿¹
        const arcT = Math.min(easeT, 1.0);
        const baseX = (1-arcT)*(1-arcT)*startX + 2*(1-arcT)*arcT*controlX + arcT*arcT*targetX;
        const baseY = (1-arcT)*(1-arcT)*startY + 2*(1-arcT)*arcT*controlY + arcT*arcT*targetY;

        const dirX = targetX - startX;
        const dirY = targetY - startY;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        const normX = dirLen > 0 ? dirX / dirLen : 0;
        const normY = dirLen > 0 ? dirY / dirLen : 0;
        const overshootAmount = (overshoot - 1.0) * overshootDist;

        const x = baseX + normX * overshootAmount;
        const y = baseY + normY * overshootAmount;

        const currentScale = 1 + (scaleTarget - 1) * Math.min(easeT, 1.0);
        const currentRotation = targetRotation * Math.min(easeT, 1.0);

        // Yè½´ç¿»è½¬ï¼š0Â° â†’ 180Â°ï¼ˆèƒŒé¢ç¿»åˆ°æ­£é¢ï¼‰
        const flipRotation = Math.min(easeT, 1.0) * 180;

        // å¤–å±‚å®¹å™¨å…³é”®å¸§ï¼šä½ç½®ã€ç¼©æ”¾ã€Zè½´æ—‹è½¬
        outerKeyframes.push({
          left: `${x}px`,
          top: `${y}px`,
          transform: `translate(-50%, -50%) scale(${currentScale}) rotate(${currentRotation}deg)`,
          opacity: 1, // ä¿æŒå®Œå…¨ä¸é€æ˜ï¼Œé¿å…è½åœ°æ—¶é—ªçƒ
          offset: t
        });

        // å†…å±‚å®¹å™¨å…³é”®å¸§ï¼šYè½´ç¿»è½¬
        flipKeyframes.push({
          transform: `rotateY(${flipRotation}deg)`,
          offset: t
        });
      }

      // å¤–å±‚å®¹å™¨åŠ¨ç”»ï¼šä½ç½®ç§»åŠ¨
      const outerAnim = outerContainer.animate(outerKeyframes, {
        duration: 520,
        easing: "linear"
      });

      // å†…å±‚å®¹å™¨åŠ¨ç”»ï¼šç¿»è½¬
      const flipAnim = flipContainer.animate(flipKeyframes, {
        duration: 520,
        easing: "linear"
      });

      // åœ¨ 90Â° æ—¶å¡«å……æ­£é¢å†…å®¹
      let flipped = false;
      const checkFlip = () => {
        if (flipped || flipAnim.playState === 'finished') return;
        const currentTime = flipAnim.currentTime || 0;
        const progress = currentTime / 520; // 0.0 - 1.0

        // è®¡ç®—å½“å‰çš„ç¿»è½¬è§’åº¦
        let easeT;
        if (progress <= 0.68) {
          const t1 = progress / 0.68;
          easeT = 1 - Math.pow(1 - t1, 2.5);
        } else {
          easeT = 1.0;
        }
        const currentFlipRotation = Math.min(easeT, 1.0) * 180;

        // å½“æ—‹è½¬åˆ° 90Â° æ—¶ï¼Œå¡«å……æ­£é¢å†…å®¹
        if (currentFlipRotation >= 90 && !flipped) {
          flipped = true;
          console.log(`[AIå‡ºç‰Œç¿»è½¬] Card${index} åˆ°è¾¾90Â°ï¼Œå¡«å……æ­£é¢å†…å®¹`);

          // å¡«å……æ­£é¢å¡ç‰Œçš„æ ·å¼å’Œå†…å®¹
          frontFace.className = `faceCard ${card.type === "img" ? "imgCard" : ""}`;
          frontFace.dataset.corner = "";

          // é‡æ–°è®¾ç½®å…³é”®çš„ inline styleï¼ˆç¡®ä¿ä¸è¢« CSS è¦†ç›–ï¼‰
          frontFace.style.width = flyingCardWidth + "px";
          frontFace.style.height = flyingCardHeight + "px";
          frontFace.style.position = "absolute";
          frontFace.style.left = "0";
          frontFace.style.top = "0";
          frontFace.style.backfaceVisibility = "hidden";
          frontFace.style.transform = "rotateY(180deg)";

          frontFace.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="${escapeHtml(card.imgSrc)}" alt="card" draggable="false" /></div>
            </div>
          `;
        } else {
          requestAnimationFrame(checkFlip);
        }
      };
      requestAnimationFrame(checkFlip);

      outerAnim.onfinish = () => {
        // ç«‹å³ç§»é™¤é£è¡Œå…ƒç´ ï¼ˆrenderDiscardPile ä¼šæ— ç¼æ¥ç®¡æ˜¾ç¤ºï¼‰
        outerContainer.remove();
        completed++;
        if (completed === cards.length && onComplete) {
          onComplete();
        }
      };
    });
  } catch (e) {
    console.error("âŒ animateAiDiscardPair é”™è¯¯:", e);
    if (onComplete) onComplete();
  }
}

// AIç‰ˆæœ¬çš„JokeræŠ½ç‰ŒåŠ¨ç”»ï¼šä»æºç©å®¶æ‰‹ç‰Œé£åˆ°å±å¹•ä¸­é—´äº®ç›¸ï¼Œç„¶åé£å‘ç›®æ ‡AIæ‰‹ç‰Œ
function animateAiJokerDraw(fromPlayerIdx, toPlayerIdx, drawnCard, onComplete) {
  console.log("[AI JokeråŠ¨ç”»] å¼€å§‹", { fromPlayerIdx, toPlayerIdx });
  try {
    const fromHandEl = seatHandElByPlayerIndex(fromPlayerIdx);
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);

    if (!fromHandEl || !toHandEl) {
      console.log("[AI JokeråŠ¨ç”»] é”™è¯¯ï¼šæ‰¾ä¸åˆ°æ‰‹ç‰Œå…ƒç´ ");
      if (onComplete) onComplete();
      return;
    }

    // è®¡ç®—èµ·ç‚¹ï¼šä½¿ç”¨æºæ‰‹ç‰Œçš„æœ€åä¸€å¼ å¡ä½ç½®ï¼ˆz-index æœ€é«˜ï¼Œè§†è§‰ä¸Šæœ€å‰é¢ä¸è¢«é®æŒ¡ï¼‰
    const allFromCards = fromHandEl.querySelectorAll('.miniBack, .faceCard');
    const topFromCard = allFromCards.length > 0 ? allFromCards[allFromCards.length - 1] : null;
    let startX, startY;

    if (topFromCard) {
      const cardRect = topFromCard.getBoundingClientRect();
      startX = cardRect.left + cardRect.width / 2;
      startY = cardRect.top + cardRect.height / 2;
    } else {
      const fromRect = fromHandEl.getBoundingClientRect();
      startX = fromRect.left + fromRect.width / 2;
      startY = fromRect.top + fromRect.height / 2;
    }

    // å±å¹•ä¸­å¿ƒç‚¹ï¼ˆäº®ç›¸ä½ç½®ï¼‰
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // è®¡ç®—ç»ˆç‚¹ï¼šç›®æ ‡AIæ‰‹ç‰Œçš„æœ€åä¸€å¼ å¡ä½ç½®ï¼ˆz-index æœ€é«˜ï¼Œè§†è§‰ä¸Šæœ€å‰é¢ä¸è¢«é®æŒ¡ï¼‰
    const toPlayer = window.game?.players?.[toPlayerIdx];
    const futureHandCount = toPlayer ? toPlayer.hand.length + 1 : 1;

    let endX, endY;
    const allToCards = toHandEl.querySelectorAll('.miniBack');
    const topCard = allToCards.length > 0 ? allToCards[allToCards.length - 1] : null;
    if (topCard) {
      const cardRect = topCard.getBoundingClientRect();
      let targetX = cardRect.left + cardRect.width / 2;
      let targetY = cardRect.top + cardRect.height / 2;

      // å‘å±å¹•ä¸­å¿ƒåç§»15%çš„è·ç¦»ï¼Œè®©å¡ç‰Œä¸é£å¾—å¤ªè¿œ
      const offsetRatio = 0.15;
      const towardCenterX = (centerX - targetX) * offsetRatio;
      const towardCenterY = (centerY - targetY) * offsetRatio;

      // é¢å¤–å‘ä¸Šåç§»ï¼Œé¿å…æ•´ä½“åä¸‹
      const upwardOffset = 20; // å‘ä¸Šåç§»20px

      endX = targetX + towardCenterX;
      endY = targetY + towardCenterY - upwardOffset;
    } else {
      const toRect = toHandEl.getBoundingClientRect();
      endX = toRect.left + toRect.width / 2;
      endY = toRect.top + toRect.height / 2;
    }

    // ç¡®å®šç›®æ ‡æ‰‹ç‰Œå°ºå¯¸
    let targetCardWidth, targetCardHeight;
    if (toPlayerIdx === 2) {
      const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1.29;
      targetCardWidth = 52 * scaleTop;
      targetCardHeight = 72 * scaleTop;
    } else {
      const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1.25;
      targetCardWidth = 64 * scaleSide;
      targetCardHeight = 89 * scaleSide;
    }

    // åˆ›å»ºé£è¡Œçš„Jokerå¡ç‰Œï¼ˆåŒé¢ç»“æ„ï¼šèƒŒé¢+æ­£é¢ï¼Œæ”¯æŒç¿»è½¬ï¼‰
    // å¤–å±‚å®¹å™¨ï¼šè´Ÿè´£ä½ç½®å’Œç¼©æ”¾
    const outerContainer = document.createElement("div");
    outerContainer.style.width = "86px";
    outerContainer.style.height = "124px";
    outerContainer.style.position = "fixed";
    outerContainer.style.left = `${startX - 43}px`;
    outerContainer.style.top = `${startY - 62}px`;
    outerContainer.style.zIndex = "10010";
    outerContainer.style.pointerEvents = "none";

    // å†…å±‚ç¿»è½¬å®¹å™¨ï¼šè´Ÿè´£Yè½´ç¿»è½¬
    const flipContainer = document.createElement("div");
    flipContainer.style.width = "100%";
    flipContainer.style.height = "100%";
    flipContainer.style.transformStyle = "preserve-3d";
    flipContainer.style.position = "relative";

    // èƒŒé¢ï¼ˆåˆå§‹å¯è§ï¼‰
    const backFace = document.createElement("div");
    backFace.className = "miniBack";
    backFace.style.width = "100%";
    backFace.style.height = "100%";
    backFace.style.position = "absolute";
    backFace.style.left = "0";
    backFace.style.top = "0";
    backFace.style.backfaceVisibility = "hidden";
    backFace.style.transform = "rotateY(0deg)";

    // æ­£é¢ï¼ˆåˆå§‹éšè—ï¼Œ90Â°åå¡«å……å¤§ç‹å›¾æ¡ˆï¼‰
    const frontFace = document.createElement("div");
    frontFace.style.width = "100%";
    frontFace.style.height = "100%";
    frontFace.style.position = "absolute";
    frontFace.style.left = "0";
    frontFace.style.top = "0";
    frontFace.style.backfaceVisibility = "hidden";
    frontFace.style.transform = "rotateY(180deg)";
    // åˆå§‹æ˜¾ç¤ºç©ºèƒŒæ™¯ï¼Œé¿å…å®Œå…¨é€æ˜
    frontFace.style.background = "rgba(255,255,255,0.1)";
    frontFace.style.border = "1px solid rgba(0,0,0,0.16)";
    frontFace.style.borderRadius = "10px";

    flipContainer.appendChild(backFace);
    flipContainer.appendChild(frontFace);
    outerContainer.appendChild(flipContainer);
    document.body.appendChild(outerContainer);

    // åˆ›å»ºèƒŒæ™¯é®ç½©ï¼ˆå‚è€ƒå‘ç‰Œé˜¶æ®µçš„å¤§ç‹å¡èƒŒæ™¯å˜æš—æ•ˆæœï¼‰
    const backdrop = document.createElement("div");
    backdrop.style.position = "fixed";
    backdrop.style.left = "0";
    backdrop.style.top = "0";
    backdrop.style.width = "100%";
    backdrop.style.height = "100%";
    backdrop.style.backgroundColor = "rgba(0,0,0,0.7)";
    backdrop.style.zIndex = "10009"; // ä½äºå¡ç‰Œå’Œæ–‡å­—
    backdrop.style.pointerEvents = "none";
    backdrop.style.opacity = "0";
    document.body.appendChild(backdrop);

    // åˆ›å»ºæ–‡å­—å…ƒç´ ï¼ˆä¼šåœ¨äº®ç›¸æ—¶æ˜¾ç¤ºï¼‰
    const toPlayerName = window.game?.players?.[toPlayerIdx]?.name || "";
    const nameText = document.createElement("div");
    nameText.style.position = "fixed";
    nameText.style.left = "50%";
    nameText.style.top = `${centerY + 80}px`;
    nameText.style.transform = "translateX(-50%)";
    nameText.style.zIndex = "10011";
    nameText.style.fontSize = "18px";
    nameText.style.fontWeight = "900";
    nameText.style.color = "rgba(255,255,255,0.92)";
    nameText.style.textShadow = "0 2px 12px rgba(0,0,0,0.55)";
    nameText.style.pointerEvents = "none";
    nameText.style.opacity = "0";
    nameText.textContent = `ç‹å…«ç‰Œ â†’ ${toPlayerName}`;
    document.body.appendChild(nameText);

    // é˜¶æ®µ1ï¼šé£åˆ°å±å¹•ä¸­é—´ + äº®ç›¸0.8s
    const dist1 = Math.sqrt(Math.pow(centerX - startX, 2) + Math.pow(centerY - startY, 2));
    const arcHeight1 = Math.min(150, dist1 * 0.3);

    const flyDuration = 300;    // é£è¡Œæ—¶é•¿300msï¼ˆç¼©çŸ­100msï¼‰
    const showDuration = 800;   // äº®ç›¸æ—¶é•¿800ms
    const totalDuration1 = flyDuration + showDuration; // æ€»å…±1100ms

    // é˜¶æ®µ1ä½¿ç”¨ç›´æ¥çš„å…³é”®å¸§ï¼Œå®ç°ease-outæ›²çº¿
    const outerKeyframes1 = [
      // èµ·ç‚¹
      {
        left: `${startX - 43}px`,
        top: `${startY - 62}px`,
        transform: `scale(1)`,
        opacity: 1,
        offset: 0
      },
      // é£è¡Œç»ˆç‚¹ï¼ˆease-out cubic-bezierï¼‰
      {
        left: `${centerX - 43}px`,
        top: `${centerY - 62}px`,
        transform: `scale(1.5)`,
        opacity: 1,
        offset: flyDuration / totalDuration1,
        easing: "cubic-bezier(0.33, 1, 0.68, 1)" // ease-out
      },
      // äº®ç›¸ç»“æŸï¼ˆåœç•™ï¼‰
      {
        left: `${centerX - 43}px`,
        top: `${centerY - 62}px`,
        transform: `scale(1.5)`,
        opacity: 1,
        offset: 1
      }
    ];

    const flipKeyframes1 = [
      // èµ·ç‚¹ï¼šèƒŒé¢
      {
        transform: `rotateY(0deg)`,
        offset: 0
      },
      // é£è¡Œç»ˆç‚¹ï¼šæ­£é¢ï¼ˆease-outï¼‰
      {
        transform: `rotateY(180deg)`,
        offset: flyDuration / totalDuration1,
        easing: "cubic-bezier(0.33, 1, 0.68, 1)" // ease-out
      },
      // äº®ç›¸ç»“æŸï¼šä¿æŒæ­£é¢
      {
        transform: `rotateY(180deg)`,
        offset: 1
      }
    ];

    // å¤–å±‚å®¹å™¨åŠ¨ç”»ï¼šä½ç½®å’Œç¼©æ”¾
    const outerAnim = outerContainer.animate(outerKeyframes1, {
      duration: totalDuration1,
      easing: "linear", // ä½¿ç”¨å…³é”®å¸§å†…çš„easing
      fill: "forwards"
    });

    // å†…å±‚å®¹å™¨åŠ¨ç”»ï¼šYè½´ç¿»è½¬
    const flipAnim = flipContainer.animate(flipKeyframes1, {
      duration: totalDuration1,
      easing: "linear", // ä½¿ç”¨å…³é”®å¸§å†…çš„easing
      fill: "forwards"
    });

    // ç›‘æ§ç¿»è½¬è¿›åº¦ï¼Œåœ¨90Â°æ—¶å¡«å……å¤§ç‹æ­£é¢å›¾æ¡ˆ
    let flipped = false;
    const checkFlip = () => {
      if (flipped || flipAnim.playState === 'finished') return;
      const currentTime = flipAnim.currentTime || 0;
      const progress = currentTime / totalDuration1; // 0.0 - 1.0

      // ç®€åŒ–è®¡ç®—ï¼šç›´æ¥ç”¨è¿›åº¦åˆ¤æ–­
      const flipProgress = progress * (totalDuration1 / flyDuration);
      const flipRotation = Math.min(flipProgress, 1.0) * 180;

      // å½“æ—‹è½¬åˆ° 90Â° æ—¶ï¼Œå¡«å……æ­£é¢å¤§ç‹å›¾æ¡ˆ
      if (flipRotation >= 90 && !flipped) {
        flipped = true;
        console.log("[AI Jokerç¿»è½¬] åˆ°è¾¾90Â°ï¼Œå¡«å……å¤§ç‹æ­£é¢å›¾æ¡ˆ");

        // å¡«å……æ­£é¢å¡ç‰Œçš„æ ·å¼å’Œå†…å®¹
        frontFace.className = "faceCard joker imgCard";
        frontFace.dataset.corner = "";

        // é‡æ–°è®¾ç½®å…³é”®çš„ inline style
        frontFace.style.width = "100%";
        frontFace.style.height = "100%";
        frontFace.style.position = "absolute";
        frontFace.style.left = "0";
        frontFace.style.top = "0";
        frontFace.style.backfaceVisibility = "hidden";
        frontFace.style.transform = "rotateY(180deg)";
        frontFace.style.background = ""; // æ¸…é™¤å ä½èƒŒæ™¯
        frontFace.style.border = "";
        frontFace.style.borderRadius = "";

        frontFace.innerHTML = `
          <div class="cardContent">
            <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
          </div>
        `;
      } else {
        requestAnimationFrame(checkFlip);
      }
    };
    requestAnimationFrame(checkFlip);

    // åŒæ­¥èƒŒæ™¯é®ç½©åŠ¨ç”»
    backdrop.animate([
      { opacity: 0, offset: 0 },
      { opacity: 0, offset: flyDuration / totalDuration1 },
      { opacity: 1, offset: (flyDuration + 100) / totalDuration1 }, // é£è¡Œç»“æŸå100msæ·¡å…¥
      { opacity: 1, offset: (totalDuration1 - 100) / totalDuration1 }, // ç»“æŸå‰100mså¼€å§‹æ·¡å‡º
      { opacity: 0, offset: 1 }
    ], {
      duration: totalDuration1,
      easing: "linear",
      fill: "forwards"
    });

    // åŒæ­¥æ–‡å­—åŠ¨ç”»
    nameText.animate([
      { opacity: 0, offset: 0 },
      { opacity: 0, offset: flyDuration / totalDuration1 },
      { opacity: 1, offset: (flyDuration + showDuration * 0.2) / totalDuration1 },
      { opacity: 1, offset: (flyDuration + showDuration * 0.8) / totalDuration1 },
      { opacity: 0, offset: 1 }
    ], {
      duration: totalDuration1,
      easing: "linear",
      fill: "forwards"
    });

    outerAnim.onfinish = () => {
      console.log("[AI JokeråŠ¨ç”»] äº®ç›¸å®Œæˆï¼Œå¼€å§‹é£å‘AIæ‰‹ç‰Œ");
      nameText.remove();
      backdrop.remove();

      // é˜¶æ®µ2ï¼šä»å±å¹•ä¸­é—´é£å‘ç›®æ ‡AIæ‰‹ç‰Œï¼ˆåŒæ—¶ç¿»è½¬å›èƒŒé¢ï¼‰
      const targetScale = targetCardWidth / 86;

      // è®¡ç®—ç›®æ ‡æ—‹è½¬è§’åº¦
      let targetRotZ = 0;
      if (toPlayerIdx === 3) targetRotZ = 90;        // å·¦ä¾§AI
      else if (toPlayerIdx === 1) targetRotZ = -90;  // å³ä¾§AI
      else if (toPlayerIdx === 2) targetRotZ = 180;  // ä¸Šæ–¹AI

      const stage2Duration = 600;

      // å¤–å±‚å®¹å™¨ï¼šä½ç½®ã€ç¼©æ”¾ã€Zè½´æ—‹è½¬ï¼ˆä½¿ç”¨ ease-out + è¿‡å†²æ•ˆæœï¼‰
      const overshootScale = targetScale * 1.08; // 8% è¿‡å†²
      const outerKeyframes2 = [
        // èµ·ç‚¹ï¼šä¸­å¿ƒä½ç½®ï¼Œæ”¾å¤§1.5å€
        {
          left: `${centerX - 43}px`,
          top: `${centerY - 62}px`,
          transform: `scale(1.5) rotateZ(0deg)`,
          opacity: 1,
          offset: 0
        },
        // 70%ï¼šæ¥è¿‘ç›®æ ‡ï¼Œè¿‡å†²åˆ°108%
        {
          left: `${endX - 43}px`,
          top: `${endY - 62}px`,
          transform: `scale(${overshootScale}) rotateZ(${targetRotZ}deg)`,
          opacity: 0.95,
          offset: 0.70,
          easing: "cubic-bezier(0.25, 0.46, 0.45, 0.94)" // ease-out
        },
        // 100%ï¼šå›å¼¹åˆ°ç›®æ ‡å°ºå¯¸
        {
          left: `${endX - 43}px`,
          top: `${endY - 62}px`,
          transform: `scale(${targetScale}) rotateZ(${targetRotZ}deg)`,
          opacity: 0.95,
          offset: 1,
          easing: "cubic-bezier(0.25, 0.46, 0.45, 0.94)" // ease-out
        }
      ];

      // å†…å±‚å®¹å™¨ï¼šYè½´ç¿»è½¬ï¼ˆä»æ­£é¢180Â°ç¿»å›èƒŒé¢360Â°ï¼‰
      const flipKeyframes2 = [
        {
          transform: `rotateY(180deg)`,
          offset: 0
        },
        {
          transform: `rotateY(360deg)`,
          offset: 1,
          easing: "cubic-bezier(0.4, 0, 0.2, 1)" // ease-in-out
        }
      ];

      const anim2 = outerContainer.animate(outerKeyframes2, {
        duration: stage2Duration,
        easing: "linear" // ä½¿ç”¨å…³é”®å¸§å†…çš„easing
      });

      // ç¬¬äºŒé˜¶æ®µçš„ç¿»è½¬åŠ¨ç”»
      const flipAnim2 = flipContainer.animate(flipKeyframes2, {
        duration: stage2Duration,
        easing: "linear" // ä½¿ç”¨å…³é”®å¸§å†…çš„easing
      });

      anim2.onfinish = () => {
        console.log("[AI JokeråŠ¨ç”»] å®Œæˆ");
        outerContainer.remove();
        if (onComplete) onComplete();
      };
    };
  } catch (e) {
    console.error("[AI JokeråŠ¨ç”»] é”™è¯¯:", e);
    if (onComplete) onComplete();
  }
}

// JokeræŠ½ç‰ŒåŠ¨ç”»ï¼šä»æŒ‡å®šåæ ‡é£åˆ°å±å¹•ä¸­é—´äº®ç›¸0.8sï¼Œç„¶åé£å‘æ‰‹ç‰Œ
function animateJokerDrawFromPoint(startX, startY, toPlayerIdx, onComplete) {
  console.log("[JokeråŠ¨ç”»] å¼€å§‹", { startX, startY, toPlayerIdx });
  try {
    const toHandEl = seatHandElByPlayerIndex(toPlayerIdx);
    if (!toHandEl) {
      console.log("[JokeråŠ¨ç”»] é”™è¯¯ï¼šæ‰¾ä¸åˆ°ç›®æ ‡æ‰‹ç‰Œå…ƒç´ ");
      if (onComplete) onComplete();
      return;
    }

    const toRect = toHandEl.getBoundingClientRect();

    // å±å¹•ä¸­å¿ƒç‚¹ï¼ˆäº®ç›¸ä½ç½®ï¼‰
    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    // ç»ˆç‚¹ï¼ˆç©å®¶æ‰‹ç‰Œä¸­å¿ƒï¼‰
    const endX = toRect.left + toRect.width / 2;
    const endY = toRect.top + toRect.height / 2;

    // ç¡®å®šç›®æ ‡æ‰‹ç‰Œå°ºå¯¸
    let targetCardWidth, targetCardHeight;
    if (toPlayerIdx === 0) {
      const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 0.85;
      targetCardWidth = 86 * scalePlayer;
      targetCardHeight = 124 * scalePlayer;
    } else if (toPlayerIdx === 2) {
      const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1.29;
      targetCardWidth = 52 * scaleTop;
      targetCardHeight = 72 * scaleTop;
    } else {
      const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1.25;
      targetCardWidth = 64 * scaleSide;
      targetCardHeight = 89 * scaleSide;
    }

    // åˆ›å»ºé£è¡Œçš„Jokerå¡ç‰Œ
    const flyingCard = document.createElement("div");
    flyingCard.className = "faceCard joker imgCard";
    flyingCard.style.width = "140px";
    flyingCard.style.height = "196px";
    flyingCard.style.position = "fixed";
    flyingCard.style.left = `${startX - 70}px`;
    flyingCard.style.top = `${startY - 98}px`;
    flyingCard.style.zIndex = "10010";
    flyingCard.style.pointerEvents = "none";
    flyingCard.innerHTML = `
      <div class="cardContent">
        <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
      </div>
    `;
    document.body.appendChild(flyingCard);

    // åˆ›å»ºæ–‡å­—å…ƒç´ ï¼ˆä¼šåœ¨äº®ç›¸æ—¶æ˜¾ç¤ºï¼‰
    const nameText = document.createElement("div");
    nameText.style.position = "fixed";
    nameText.style.left = "50%";
    nameText.style.top = `${centerY + 120}px`;
    nameText.style.transform = "translateX(-50%)";
    nameText.style.zIndex = "10011";
    nameText.style.fontSize = "18px";
    nameText.style.fontWeight = "900";
    nameText.style.color = "rgba(255,255,255,0.92)";
    nameText.style.textShadow = "0 2px 12px rgba(0,0,0,0.55)";
    nameText.style.pointerEvents = "none";
    nameText.style.opacity = "0";
    nameText.textContent = `ç‹å…«ç‰Œ â†’ ${game?.players?.[toPlayerIdx]?.name || ""}`;
    document.body.appendChild(nameText);

    // é˜¶æ®µ1ï¼šé£åˆ°å±å¹•ä¸­é—´ + äº®ç›¸0.8s (ä¸€ä¸ªå®Œæ•´åŠ¨ç”»)
    // è®¡ç®—åˆ°å±å¹•ä¸­é—´çš„è·ç¦»
    const dist1 = Math.sqrt(Math.pow(centerX - startX, 2) + Math.pow(centerY - startY, 2));
    const arcHeight1 = Math.min(150, dist1 * 0.3);

    const steps1 = 40; // æ›´å¤šæ­¥éª¤ä»¥åŒ…å«äº®ç›¸
    const flyDuration = 400; // é£è¡Œæ—¶é•¿400ms
    const showDuration = 800; // äº®ç›¸æ—¶é•¿800ms
    const totalDuration1 = flyDuration + showDuration; // æ€»å…±1200ms

    const keyframes1 = [];
    for (let i = 0; i <= steps1; i++) {
      const t = i / steps1;
      const time = t * totalDuration1;

      let x, y, scale, textOpacity;

      if (time <= flyDuration) {
        // é£è¡Œé˜¶æ®µ (0-400ms)
        const flyT = time / flyDuration;
        const easeT = 1 - Math.pow(1 - flyT, 3); // ease-out

        // è´å¡å°”æ›²çº¿
        const controlX = (startX + centerX) / 2;
        const controlY = (startY + centerY) / 2 - arcHeight1;
        x = (1-easeT)*(1-easeT)*startX + 2*(1-easeT)*easeT*controlX + easeT*easeT*centerX;
        y = (1-easeT)*(1-easeT)*startY + 2*(1-easeT)*easeT*controlY + easeT*easeT*centerY;

        scale = 1 + 0.3 * easeT; // ä»1.0æ”¾å¤§åˆ°1.3
        textOpacity = 0;
      } else {
        // äº®ç›¸é˜¶æ®µ (400-1200ms) - åœç•™åœ¨å±å¹•ä¸­é—´
        x = centerX;
        y = centerY;
        scale = 1.3;

        const showT = (time - flyDuration) / showDuration;
        // æ–‡å­—æ·¡å…¥æ·¡å‡º
        if (showT < 0.2) {
          textOpacity = showT / 0.2; // 0-0.2: æ·¡å…¥
        } else if (showT > 0.8) {
          textOpacity = (1 - showT) / 0.2; // 0.8-1.0: æ·¡å‡º
        } else {
          textOpacity = 1; // 0.2-0.8: å®Œå…¨æ˜¾ç¤º
        }
      }

      keyframes1.push({
        left: `${x - 70}px`,
        top: `${y - 98}px`,
        transform: `scale(${scale})`,
        opacity: 1
      });
    }

    const anim1 = flyingCard.animate(keyframes1, {
      duration: totalDuration1,
      easing: "linear",
      fill: "forwards"
    });

    // åŒæ­¥æ–‡å­—åŠ¨ç”»
    nameText.animate([
      { opacity: 0, offset: 0 },
      { opacity: 0, offset: flyDuration / totalDuration1 },
      { opacity: 1, offset: (flyDuration + showDuration * 0.2) / totalDuration1 },
      { opacity: 1, offset: (flyDuration + showDuration * 0.8) / totalDuration1 },
      { opacity: 0, offset: 1 }
    ], {
      duration: totalDuration1,
      easing: "linear",
      fill: "forwards"
    });

    anim1.onfinish = () => {
      console.log("[JokeråŠ¨ç”»] äº®ç›¸å®Œæˆï¼Œå¼€å§‹é£å‘æ‰‹ç‰Œ");
      nameText.remove();

      // é˜¶æ®µ2ï¼šä»å±å¹•ä¸­é—´é£å‘ç©å®¶æ‰‹ç‰Œ
      const dist2 = Math.sqrt(Math.pow(endX - centerX, 2) + Math.pow(endY - centerY, 2));
      const arcHeight2 = Math.min(150, dist2 * 0.3);
      const controlX2 = (centerX + endX) / 2;
      const controlY2 = (centerY + endY) / 2 - arcHeight2;

      const targetScale = targetCardWidth / 140;
      const overshootDist = dist2 * 0.05;

      const steps2 = 30;
      const keyframes2 = [];

      for (let i = 0; i <= steps2; i++) {
        const t = i / steps2;
        let easeT, overshoot;

        if (t <= 0.72) {
          const t1 = t / 0.72;
          easeT = 1 - Math.pow(1 - t1, 3);
          overshoot = 1.05;
        } else {
          const t2 = (t - 0.72) / 0.28;
          const easeT2 = t2 < 0.5 ? 4 * t2 * t2 * t2 : 1 - Math.pow(-2 * t2 + 2, 3) / 2;
          easeT = 1.05 - 0.05 * easeT2;
          overshoot = easeT;
        }

        const baseX = (1-easeT)*(1-easeT)*centerX + 2*(1-easeT)*easeT*controlX2 + easeT*easeT*endX;
        const baseY = (1-easeT)*(1-easeT)*centerY + 2*(1-easeT)*easeT*controlY2 + easeT*easeT*endY;

        const dirX = endX - centerX;
        const dirY = endY - centerY;
        const dirLen = Math.sqrt(dirX * dirX + dirY * dirY);
        const normX = dirLen > 0 ? dirX / dirLen : 0;
        const normY = dirLen > 0 ? dirY / dirLen : 0;

        const overshootAmount = (overshoot - 1.0) * overshootDist;
        const x = baseX + normX * overshootAmount;
        const y = baseY + normY * overshootAmount;

        const scale = 1.3 + (targetScale - 1.3) * Math.min(easeT, 1.0);

        keyframes2.push({
          left: `${x - 70}px`,
          top: `${y - 98}px`,
          transform: `scale(${scale})`,
          opacity: 1 - 0.1 * Math.min(easeT, 1.0)
        });
      }

      const anim2 = flyingCard.animate(keyframes2, {
        duration: 600,
        easing: "linear"
      });

      anim2.onfinish = () => {
        console.log("[JokeråŠ¨ç”»] å®Œæˆ");
        flyingCard.remove();
        if (onComplete) onComplete();
      };
    };
  } catch (e) {
    console.error("[JokeråŠ¨ç”»] é”™è¯¯:", e);
    if (onComplete) onComplete();
  }
}

// ç®€æ´çš„é£è¡Œå‡½æ•°ï¼šä».tableBgä¸­å¿ƒé£å‘ç©å®¶æ‰‹ç‰Œï¼Œ90åº¦æ—¶æ›¿æ¢å›¾ç‰‡
function flyJokerToPlayerSimple(game, playerIndex, onComplete) {
  try {
    const handEl = seatHandElByPlayerIndex(playerIndex);
    const player = game.players[playerIndex];
    const numCards = player ? player.hand.length + 1 : 1;

    // è·å–ç›®æ ‡å¡ç‰Œå°ºå¯¸
    let cardWidth, cardHeight;
    if (playerIndex === 0) {
      const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 1;
      cardWidth = 86 * s;
      cardHeight = 124 * s;
    } else if (playerIndex === 2) {
      const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1;
      cardWidth = 52 * s;
      cardHeight = 72 * s;
    } else {
      const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1;
      cardWidth = 64 * s;
      cardHeight = 89 * s;
    }

    // è®¡ç®—ç›®æ ‡ä½ç½®
    const handRect = handEl.getBoundingClientRect();
    let targetX, targetY;
    if (playerIndex === 0) {
      const center = (numCards - 1) / 2;
      const spread = Math.min(62, 920 / Math.max(1, numCards - 1));
      const d = numCards - 1 - center;
      targetX = handRect.left + handRect.width / 2 + d * spread;
      targetY = handRect.top + 18 + cardHeight / 2 + Math.abs(d) * 0.8;
    } else {
      const center = (numCards - 1) / 2;
      const d = numCards - 1 - center;
      if (playerIndex === 2) {
        targetX = handRect.left + handRect.width / 2 + d * 12;
        targetY = handRect.top + handRect.height / 2 + d * 0.3;
      } else {
        targetX = handRect.left + handRect.width / 2 + d * 0.3;
        targetY = handRect.top + handRect.height / 2 + d * 9;
      }
    }

    // è·å–.tableBgä¸­å¿ƒä½œä¸ºèµ·ç‚¹
    const tableBg = document.querySelector('.tableBg');
    const tbr = tableBg ? tableBg.getBoundingClientRect() : { left: 0, top: 0, width: window.innerWidth, height: window.innerHeight };
    const startX = tbr.left + tbr.width / 2;
    const startY = tbr.top + tbr.height / 2;

    // åˆ›å»ºé£è¡Œå¡ç‰Œ
    const card = document.createElement('div');
    card.style.cssText = `position:fixed;left:${startX-43}px;top:${startY-62}px;width:86px;height:124px;z-index:10060;border:1px solid rgba(0,0,0,0.22);border-radius:16px;overflow:hidden;background:white;`;
    card.innerHTML = `<img id="jImg" style="width:100%;height:100%;object-fit:contain" src="./assets/joker.png">`;
    document.body.appendChild(card);

    const img = card.querySelector('#jImg');
    const targetScale = cardWidth / 86;
    let rotZ = 0;
    if (playerIndex === 1) rotZ = -90;
    else if (playerIndex === 2) rotZ = 180;
    else if (playerIndex === 3) rotZ = 90;

    const dist = Math.sqrt((targetX - startX) ** 2 + (targetY - startY) ** 2);
    const arc = Math.min(200, dist * 0.4);
    const cx = (startX + targetX) / 2;
    let cy = (startY + targetY) / 2;
    if (playerIndex === 0) cy -= arc;
    else if (playerIndex === 2) cy -= arc * 0.5;
    else cy += arc * 0.3;

    const kf = [];
    for (let i = 0; i <= 30; i++) {
      const t = i / 30;
      const et = 1 - (1 - t) ** 3;
      const x = (1 - et) ** 2 * startX + 2 * (1 - et) * et * cx + et ** 2 * targetX;
      const y = (1 - et) ** 2 * startY + 2 * (1 - et) * et * cy + et ** 2 * targetY;
      const sc = 1 + (targetScale - 1) * et;
      const rz = rotZ * et;
      let ry = 0;
      if (playerIndex !== 0 && et > 0.30) {
        ry = ((et - 0.30) / 0.70) * 180;
      }
      kf.push({ left: `${x - 43}px`, top: `${y - 62}px`, transform: `scale(${sc}) rotateZ(${rz}deg) rotateY(${ry}deg)`, opacity: 1 });
    }

    const an = card.animate(kf, { duration: 560, easing: 'linear', fill: 'forwards' });

    // AI: 90åº¦æ—¶æ›¿æ¢å›¾ç‰‡
    if (playerIndex !== 0 && img) {
      let flipped = false;
      const check = () => {
        if (flipped || an.playState === 'finished') return;
        const ct = an.currentTime || 0;
        const p = ct / 560;
        const et = 1 - (1 - p) ** 3;
        let ry = 0;
        if (et > 0.30) ry = ((et - 0.30) / 0.70) * 180;
        if (ry >= 90) {
          flipped = true;
          img.src = './assets/card-back.png';
          card.style.background = '#2b4a2d';
        } else {
          requestAnimationFrame(check);
        }
      };
      requestAnimationFrame(check);
    }

    an.onfinish = () => {
      card.remove();
      if (onComplete) onComplete();
    };
  } catch (e) {
    console.error('flyJokerToPlayerSimple error:', e);
    if (onComplete) onComplete();
  }
}

function showJokerRevealAndFly(game, playerIndex, onComplete) {
  // ğŸ¨ ä½¿ç”¨ç²’å­å‡èšç‰¹æ•ˆï¼ˆå¦‚æœå¯ç”¨ï¼‰
  if (window.JokerSummon && typeof window.JokerSummon.createSummonEffect === 'function') {
    const summonEffect = window.JokerSummon.createSummonEffect({
      jokerImageUrl: './assets/joker.png',
      duration: 1.2, // ç¼©çŸ­åˆ°1.2ç§’ï¼ˆæ‰­æ›²åœ¨60%åå°±åœæ­¢äº†ï¼‰
      onComplete: () => {
        summonEffect.destroy(); // é»‘å±ç¬é—´æ¶ˆå¤±
        flyJokerToPlayerSimple(game, playerIndex, onComplete); // ç«‹å³å¼€å§‹é£è¡Œ
      }
    });
    setTimeout(() => summonEffect.play(), 100);
    return;
  }

  // Fallback: åŸå§‹åŠ¨ç”»
  const prev = document.querySelector(".jokerRevealOverlay");
  if (prev) prev.remove();

  const name = game?.players?.[playerIndex]?.name || "";
  const wrap = document.createElement("div");
  wrap.className = "jokerRevealOverlay";
  wrap.innerHTML = `
    <div class="jokerRevealInner">
      <div class="revealStage">
        <div class="revealCard joker imgCard" data-corner="">
          <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" /></div>
        </div>
      </div>
      <div class="revealTo">ç‹å…«ç‰Œ â†’ ${escapeHtml(name)}</div>
    </div>
  `;
  document.body.appendChild(wrap);

  const revealEl = wrap.querySelector(".revealCard");
  if (!revealEl) {
    wrap.remove();
    if (onComplete) onComplete();
    return;
  }

  window.clearTimeout(showJokerRevealAndFly._t);
  showJokerRevealAndFly._t = window.setTimeout(() => {
    try {
      const from = revealEl.getBoundingClientRect();
      const handEl = seatHandElByPlayerIndex(playerIndex);
      const handRect = handEl.getBoundingClientRect();

      // Calculate target position: rightmost card position AFTER joker is added
      const player = game.players[playerIndex];
      const numCards = player ? player.hand.length + 1 : 1; // +1 for joker being added
      let targetX, targetY;

      // Get actual card size first (needed for position calculation)
      let cardWidth, cardHeight;
      if (playerIndex === 0) {
        const scalePlayer = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-player-card')) || 1;
        cardWidth = 86 * scalePlayer;
        cardHeight = 124 * scalePlayer;
      } else if (playerIndex === 2) {
        const scaleTop = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-top-card')) || 1;
        cardWidth = 52 * scaleTop;
        cardHeight = 72 * scaleTop;
      } else {
        const scaleSide = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--scale-ai-side-card')) || 1;
        cardWidth = 64 * scaleSide;
        cardHeight = 89 * scaleSide;
      }

      if (playerIndex === 0) {
        // Bottom player: calculate rightmost card position in fan layout (AFTER joker added)
        const center = (numCards - 1) / 2;
        const maxFanWidth = 920;
        const spread = Math.min(62, maxFanWidth / Math.max(1, numCards - 1));
        const rightmostIdx = numCards - 1;
        const rightmostD = rightmostIdx - center;
        // faceCard positioning: left: 50%, top: 18px, transform: translateX(-50%) translateX(var(--x)) translateY(var(--y))
        // So actual center X = handRect.left + handRect.width/2 + --x
        // Actual center Y = handRect.top + 18 + cardHeight/2 + --y
        const xOffset = rightmostD * spread;
        const yOffset = Math.abs(rightmostD) * 0.8;
        targetX = handRect.left + handRect.width / 2 + xOffset;
        targetY = handRect.top + 18 + cardHeight / 2 + yOffset;
      } else {
        // AI players: calculate tail position in their pile (AFTER joker added)
        const center = (numCards - 1) / 2;
        const tailIdx = numCards - 1;
        const tailD = tailIdx - center;

        if (playerIndex === 2) {
          // Top player: pile spreads left, tail is at left side (positive sx)
          const tailSx = tailD * 12;
          const tailSy = tailD * 0.3;
          targetX = handRect.left + handRect.width / 2 + tailSx;
          targetY = handRect.top + handRect.height / 2 + tailSy;
        } else {
          // Left/right players: pile spreads downward, tail is at bottom
          const tailSx = tailD * 0.3;
          const tailSy = tailD * 9;
          targetX = handRect.left + handRect.width / 2 + tailSx;
          targetY = handRect.top + handRect.height / 2 + tailSy;
        }
      }

      // Build target rect: targetX/targetY are CENTER positions
      // Convert to left/top (top-left corner) for the to object
      const to = {
        left: targetX - cardWidth / 2,
        top: targetY - cardHeight / 2,
        width: cardWidth,
        height: cardHeight
      };

      console.log(`[Joker] Player ${playerIndex}, numCards: ${numCards}, targetX: ${targetX}, targetY: ${targetY}, cardWidth: ${cardWidth}`);

      // ä¸å…‹éš†ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å¡ç‰Œå…ƒç´ 
      // ä» wrap ä¸­åˆ†ç¦» revealElï¼ˆé¿å… wrap.remove() æ—¶ä¸€èµ·åˆ é™¤ï¼‰
      revealEl.remove();
      flyFromRectToRect(from, to, revealEl, playerIndex, onComplete);
      wrap.remove();
    } catch {
      // ignore
      if (onComplete) onComplete();
    }
  }, 720);
}

function showDrawRevealAndFly(game, drawnCard, playerIndex) {
  const msg = $("#message");
  msg.classList.add("revealOnly");

  if (drawnCard.type === "joker") {
    const name = game?.players?.[playerIndex]?.name || "";
    msg.innerHTML = `
      <div class="revealStage">
        <div class="revealCard joker imgCard" data-corner="">
          <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" /></div>
        </div>
      </div>
      <div class="revealTo">ç‹å…«ç‰Œ â†’ ${escapeHtml(name)}</div>
    `;
  } else {
    msg.innerHTML = `
      <div class="revealStage">
        <div class="revealCard" data-corner="">
          <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" /></div>
        </div>
      </div>
    `;
  }

  const revealEl = msg.querySelector(".revealCard");
  if (!revealEl) return;
  // no suit coloring in image mode

  // Fly to the drawer's hand area after a short reveal.
  window.clearTimeout(showDrawRevealAndFly._t);
  showDrawRevealAndFly._t = window.setTimeout(() => {
    try {
      const from = revealEl.getBoundingClientRect();
      const handEl = seatHandElByPlayerIndex(playerIndex);
      const to = handEl.getBoundingClientRect();

      // ä¸å…‹éš†ï¼Œç›´æ¥ä½¿ç”¨åŸå§‹å¡ç‰Œå…ƒç´ 
      // ä» msg ä¸­åˆ†ç¦»å‡ºæ¥ï¼ˆé¿å… msg.innerHTML = "" æ—¶ä¸€èµ·æ¸…é™¤ï¼‰
      revealEl.remove();

      // æ¸…é™¤æ¶ˆæ¯åŒºåŸŸçš„å…¶ä»–å†…å®¹
      msg.innerHTML = "";
      msg.classList.remove("revealOnly");

      // é£è¡ŒåŠ¨ç”»
      flyFromRectToRect(from, to, revealEl);
    } catch {
      // ignore
      msg.innerHTML = "";
      msg.classList.remove("revealOnly");
    }
  }, 650);
}

function renderAction(game, settings) {
  const choiceRow = $("#choiceRow");
  const btnTryMatch = $("#btnTryMatch");
  const btnClearSelect = $("#btnClearSelect");
  const btnEndTurn = $("#btnEndTurn");

  if (game.gameOver) {
    choiceRow.classList.add("hidden");
    btnEndTurn.disabled = true;
    return;
  }

  const current = game.players[game.currentPlayerIndex];
  const targetIdx = window.Game.getUpstreamPlayerIndex(game);

  // Choice UI
  const isHumanTurn = current.kind === "human";
  choiceRow.classList.toggle("hidden", !isHumanTurn);
  btnTryMatch.disabled = true;
  btnClearSelect.disabled = true;

  // End turn gating: must draw once before ending
  const canDrawUpstream = window.Game.canDrawFrom(game, targetIdx);
  // è§„åˆ™ï¼šé€šå¸¸éœ€è¦å…ˆæŠ½ç‰Œå†ç»“æŸï¼›ä½†å¦‚æœä¸Šå®¶æ²¡ç‰Œå¯æŠ½ï¼Œåˆ™å…è®¸ç›´æ¥ç»“æŸé¿å…å¡æ­»
  btnEndTurn.disabled = !isHumanTurn || (!game.turnHasDrawn && canDrawUpstream);
}

function showLastEvent(game, settings) {
  const msg = $("#message");
  const ev = game.lastEvent;
  if (!ev) {
    msg.innerHTML = "";
    msg.classList.remove("revealOnly");
    return;
  }

  if (ev.type === "joker_deal") {
    // å‘ç‰Œç»“æŸåï¼šç‹å…«ç‰Œäº®ç›¸ï¼ˆå±å¹•å±…ä¸­ï¼‰ï¼Œç„¶åé£åˆ°æŒ‡å®šç©å®¶æ‰‹ç‰Œ
    msg.innerHTML = "";
    msg.classList.remove("revealOnly");
    showJokerRevealAndFly(game, Math.max(0, ev.playerIndex || 0));
  } else if (ev.type === "draw") {
    // Draw animations are now handled inline during the draw action (with flying card)
    // Only clear the message area here
    msg.innerHTML = "";
    msg.classList.remove("revealOnly");
  } else if (ev.type === "discard_pair") {
    // no text / no TTS
  } else if (ev.type === "mismatch") {
    // No textæç¤º
    msg.innerHTML = "";
  } else {
    msg.innerHTML = "";
  }
}

function renderAll(game, settings) {
  renderSeats(game);
  renderDiscardPile(game);
  renderAction(game, settings);
  showLastEvent(game, settings);
}

function runAiLoop(game, settings) {
  if (!game || game.gameOver) return;

  // ğŸ†• æ­»å¾ªç¯æ£€æµ‹ï¼šå¦‚æœæ‰€æœ‰ç©å®¶éƒ½å‡ºå±€ä½†æ¸¸æˆæœªç»“æŸï¼Œå¼ºåˆ¶ç»“æŸ
  const allOut = game.players.every(p => p.out);
  if (allOut) {
    console.log('[æ­»å¾ªç¯æ£€æµ‹] æ‰€æœ‰ç©å®¶éƒ½å·²å‡ºå±€ï¼Œå¼ºåˆ¶ç»“æŸæ¸¸æˆ');
    game.gameOver = true;
    const loser = window.Game.findJokerHolder(game.players);
    game.winnerText = loser
      ? `æ¸¸æˆç»“æŸï¼š${loser.name} æ‰‹é‡Œç•™ç€"ç‹å…«ç‰Œ"ï¼Œå¤±è´¥ï¼`
      : "æ¸¸æˆç»“æŸ";
    renderAll(game, settings);
    return;
  }

  const current = game.players[game.currentPlayerIndex];
  if (!current) return;
  // If somehow we landed on an "out" player, immediately advance until we reach an active one.
  if (current.out) {
    window.Game.advanceTurn(game);
    renderAll(game, settings);
    return runAiLoop(game, settings);
  }
  if (current.kind !== "ai") return;

  // ç©å®¶å‡ºå±€ååŠ é€ŸAIå¯¹å±€
  const humanPlayer = game.players.find(p => p.kind === "human");
  const speedUpAi = humanPlayer && humanPlayer.out;
  const basePace = speedUpAi ? 200 : settings.aiPaceMs;

  // ğŸ†• å›åˆå¼€å§‹æ—¶å…ˆæ£€æŸ¥æ˜¯å¦æœ‰é…å¯¹ï¼Œå¦‚æœæœ‰åˆ™å…ˆå‡ºç‰Œå†æŠ½ç‰Œ
  const initialPair = window.Game.findAnyPairInHand(current.hand);
  if (initialPair && !game.turnHasDrawn) {
    console.log(`[AIå›åˆå¼€å§‹] AI${game.currentPlayerIndex} å‘ç°åˆå§‹é…å¯¹ï¼Œå…ˆå‡ºç‰Œ`);

    // å»¶è¿Ÿåå¼€å§‹å‡ºç‰Œï¼ˆç»™AIä¸€ä¸ª"æ€è€ƒ"çš„æ—¶é—´ï¼‰- å‡åŠç‰ˆ
    const initialThinkingDelay = speedUpAi ? 200 : (300 + Math.random() * 200);  // 0.3-0.5s

    window.clearTimeout(runAiLoop._t);
    runAiLoop._t = window.setTimeout(() => {
      // é€’å½’å‡ºç‰Œç›´åˆ°æ²¡æœ‰é…å¯¹
      const discardAllInitialPairs = () => {
        const pair = window.Game.findAnyPairInHand(current.hand);
        if (!pair) {
          // æ²¡æœ‰é…å¯¹äº†ï¼Œç»§ç»­æ­£å¸¸æŠ½ç‰Œæµç¨‹
          console.log(`[AIå›åˆå¼€å§‹] AI${game.currentPlayerIndex} é…å¯¹å®Œæˆï¼Œå¼€å§‹æŠ½ç‰Œ`);
          proceedToDrawPhase();
          return;
        }

        // å‡ºç‰ŒåŠ¨ç”»ï¼šå…ˆå¯åŠ¨åŠ¨ç”»ï¼Œå®Œæˆåæ‰ç§»é™¤æ‰‹ç‰Œ
        const aiIdx = game.currentPlayerIndex;
        animateAiDiscardPair(aiIdx, pair[0], pair[1], () => {
          // åŠ¨ç”»å®Œæˆåæ‰ç§»é™¤æ‰‹ç‰Œ
          window.Game.tryDiscardPairByCardIds(game, aiIdx, pair[0].id, pair[1].id);

          // ç«‹å³æ¸²æŸ“å¼ƒç‰Œå †ï¼ˆæ— ç¼è¡”æ¥é£è¡ŒåŠ¨ç”»ï¼‰
          renderDiscardPile(game);

          // å»¶è¿Ÿæ¸²æŸ“æ‰‹ç‰Œï¼Œç­‰å¾…æ‰‹ç‰Œè°ƒæ•´åŠ¨ç”»å®Œæˆï¼ˆé¿å…çªç„¶è·³å˜ï¼‰
          setTimeout(() => {
            renderSeats(game);
            renderAction(game, settings);
            showLastEvent(game, settings);

            // æ£€æŸ¥æ˜¯å¦å‡ºå±€
            if (current.out || game.gameOver) {
              window.Game.advanceTurn(game);
              renderAll(game, settings);
              runAiLoop(game, settings);
              return;
            }

            // ç­‰å¾…åç»§ç»­å‡ºä¸‹ä¸€å¯¹ - å‡åŠç‰ˆ
            const thinkingDelay = speedUpAi ? 150 : (400 + Math.random() * 200);  // 0.4-0.6s
            window.setTimeout(discardAllInitialPairs, thinkingDelay);
          }, 100); // å»¶è¿Ÿ 100msï¼Œç¡®ä¿ adjusting æ ‡è®°è¿˜åœ¨
        });
      };

      discardAllInitialPairs();
    }, initialThinkingDelay);
    return;
  }

  // æ­£å¸¸æŠ½ç‰Œæµç¨‹
  function proceedToDrawPhase() {
    console.log(`[AIæŠ½ç‰Œæµç¨‹] proceedToDrawPhase è¢«è°ƒç”¨, å½“å‰ç©å®¶: AI${game.currentPlayerIndex}`);
    // AIï¼šä»ä¸Šå®¶æŠ½ä¸€å¼ ï¼ˆä½¿ç”¨æ™ºèƒ½æŠ½ç‰Œé€»è¾‘ï¼‰
    const targetIdx = window.Game.getUpstreamPlayerIndex(game);
    const target = game.players[targetIdx];
    console.log(`[AIæŠ½ç‰Œæµç¨‹] ä¸Šå®¶ç´¢å¼•: ${targetIdx}, ä¸Šå®¶æ‰‹ç‰Œæ•°: ${target ? target.hand.length : 0}`);
    if (!target || target.out || target.hand.length === 0) {
      console.log(`[AIæŠ½ç‰Œæµç¨‹] ä¸Šå®¶æ— ç‰Œï¼Œè·³è¿‡æŠ½ç‰Œ`);
      window.Game.advanceTurn(game);
      renderAll(game, settings);
      return runAiLoop(game, settings);
    }

    // è®¡ç®—AIæŠ½ç‰Œå»¶è¿Ÿï¼ˆæ ¹æ®æ‰‹ç‰Œæ•°é‡å¢åŠ ç´§å¼ æ„Ÿï¼‰
    const aiDrawDelay = speedUpAi ? 200 : window.Game.getAiDrawDelay(game, game.currentPlayerIndex);
    console.log(`[AIæŠ½ç‰Œæµç¨‹] å»¶è¿Ÿ ${aiDrawDelay}ms åå¼€å§‹æŠ½ç‰Œ`);

    window.clearTimeout(runAiLoop._t);
    runAiLoop._t = window.setTimeout(() => {
      try {
        // ä½¿ç”¨æ™ºèƒ½æŠ½ç‰Œç´¢å¼•ï¼ˆç¬¬ä¸‰æŠŠä¼šä¼˜å…ˆæŠ½JOKERï¼‰
        const idx = window.Game.getAiDrawIndex(game, game.currentPlayerIndex, targetIdx);

        // æ£€æŸ¥æ˜¯å¦æœ‰æœ‰æ•ˆçš„ç‰Œå¯æŠ½
        if (idx < 0 || !target.hand[idx]) {
          console.log(`[AIæŠ½ç‰Œæµç¨‹] æ— æ•ˆç´¢å¼•æˆ–æ— ç‰Œï¼Œè·³è¿‡æŠ½ç‰Œ`);
          window.Game.advanceTurn(game);
          renderAll(game, settings);
          return runAiLoop(game, settings);
        }

        const drawnCard = target.hand[idx];
        const isJoker = drawnCard.type === "joker";
        const currentIdx = game.currentPlayerIndex;
        console.log(`[AIæŠ½ç‰Œæµç¨‹] å‡†å¤‡æŠ½ç¬¬${idx}å¼ ç‰Œ, isJoker: ${isJoker}`, drawnCard);

        if (isJoker) {
          console.log(`[AIæŠ½ç‰Œæµç¨‹] æŠ½åˆ°JOKERï¼Œä½¿ç”¨AIä¸“å±äº®ç›¸åŠ¨ç”»`);
          // AIæŠ½åˆ°Jokerï¼šä½¿ç”¨AIä¸“å±çš„äº®ç›¸åŠ¨ç”»ï¼ˆé£åˆ°å±å¹•ä¸­å¿ƒäº®ç›¸ + é£å‘AIæ‰‹ç‰Œï¼‰
          animateAiJokerDraw(targetIdx, currentIdx, drawnCard, () => {
            // After animation, execute the draw
            window.Game.drawCard(game, targetIdx, idx);
            renderAll(game, settings);

            // Continue AI turn: discard pairs with animation
            continueAiTurnAfterDraw();
          });
        } else {
          console.log(`[AIæŠ½ç‰Œæµç¨‹] æ™®é€šå¡ç‰Œï¼Œè°ƒç”¨ animateDrawCardFly`);
          // Normal card: fly directly to AI hand
          animateDrawCardFly(targetIdx, currentIdx, drawnCard, () => {
            // After animation, execute the draw
            window.Game.drawCard(game, targetIdx, idx);
            renderAll(game, settings);

            // Continue AI turn: discard pairs with animation
            continueAiTurnAfterDraw();
          });
        }

        function continueAiTurnAfterDraw() {
          window.setTimeout(() => {
            try {
              // AI auto-discard all pairs it can find (with animations)
              const discardNextPair = () => {
                if (game.gameOver) {
                  // Game ended, just run next loop
                  renderAll(game, settings);
                  runAiLoop(game, settings);
                  return;
                }

                const currentPlayer = game.players[game.currentPlayerIndex];
                const pair = window.Game.findAnyPairInHand(currentPlayer.hand);
                if (!pair) {
                  // No more pairs, advance turn
                  console.log(`[AIå›åˆ] ${currentPlayer.name} æŠ½ç‰Œåæ— é…å¯¹ï¼Œæ— è¿›å±•å›åˆæ•°: ${game.noProgressTurns || 0}`);

                  // ğŸ”„ ä¸»åŠ¨æ£€æµ‹ï¼šå¦‚æœå³å°†è§¦å‘æ­»å¾ªç¯æ£€æµ‹ï¼Œå…ˆæ¸²æŸ“ä¸€æ¬¡è®© renderSeats æ£€æŸ¥
                  if ((game.noProgressTurns || 0) >= 6) {
                    console.log(`   æ¥è¿‘æ­»å¾ªç¯é˜ˆå€¼ï¼Œå…ˆæ¸²æŸ“æ£€æŸ¥...`);
                    renderAll(game, settings);
                  }

                  if (!game.gameOver) window.Game.advanceTurn(game);
                  renderAll(game, settings);
                  runAiLoop(game, settings);
                  return;
                }

                // Animate discard, then execute and continue
                const aiIdx = game.currentPlayerIndex;
                animateAiDiscardPair(aiIdx, pair[0], pair[1], () => {
                  // åŠ¨ç”»å®Œæˆåæ‰ç§»é™¤æ‰‹ç‰Œ
                  window.Game.tryDiscardPairByCardIds(
                    game,
                    aiIdx,
                    pair[0].id,
                    pair[1].id
                  );

                  // ç«‹å³æ¸²æŸ“å¼ƒç‰Œå †ï¼ˆæ— ç¼è¡”æ¥é£è¡ŒåŠ¨ç”»ï¼‰
                  renderDiscardPile(game);

                  // å»¶è¿Ÿæ¸²æŸ“æ‰‹ç‰Œï¼Œç­‰å¾…æ‰‹ç‰Œè°ƒæ•´åŠ¨ç”»å®Œæˆ
                  setTimeout(() => {
                    renderSeats(game);
                    renderAction(game, settings);
                    showLastEvent(game, settings);

                    // Wait a bit before next pair - å‡åŠç‰ˆ
                    const thinkingDelay = 400 + Math.random() * 200;  // 0.4-0.6s
                    window.setTimeout(discardNextPair, thinkingDelay);
                  }, 100);
                });
              };

              discardNextPair();
            } catch {
              // ignore
            }
          }, isJoker ? Math.max(basePace, 1200) : basePace);
        }
      } catch {
        // ignore
      }
    }, aiDrawDelay); // ä½¿ç”¨åŠ¨æ€è®¡ç®—çš„å»¶è¿Ÿæ—¶é—´
  }

  // å¦‚æœæ²¡æœ‰åˆå§‹é…å¯¹ï¼Œç›´æ¥è¿›å…¥æŠ½ç‰Œé˜¶æ®µ
  proceedToDrawPhase();
}

function initUi(imagePairs = []) {
  // åˆå§‹åŒ–å…¨å±€æ¸¸æˆè¿½è¸ªå™¨
  if (!window.__GAME_ROUND_TRACKER__) {
    window.__GAME_ROUND_TRACKER__ = {
      currentLevel: 1,
      roundNumber: 0,
    };
  }

  const settings = {
    showBothOnDraw: true,
    autoAdvanceMs: 0,
    aiPaceMs: 325,  // å‡åŠ: 650 â†’ 325
  };

  const autoNextToggle = $("#autoNextToggle");
  const pairCountInput = $("#pairCount");
  const pairCountNum = $("#pairCountNum");
  const pairCountLabel = $("#pairCountLabel");
  const totalCardLabel = $("#totalCardLabel");
  const btnStart = $("#btnStart");
  const btnRestart = $("#btnRestart");
  const btnTryMatch = $("#btnTryMatch");
  const btnClearSelect = $("#btnClearSelect");
  const btnEndTurn = $("#btnEndTurn");
  const btnHintImg = $("#btnHintImg");
  const btnMatchImg = $("#btnMatchImg");
  const btnEndTurnImg = $("#btnEndTurnImg");
  const endOverlay = $("#endOverlay");
  const endTitle = $("#endTitle");
  const endSubtitle = $("#endSubtitle");
  const btnPlayAgain = $("#btnPlayAgain");
  const btnBackToSetup = $("#btnBackToSetup");
  const btnTune = $("#btnTune");
  const tunerPanel = $("#tunerPanel");
  const btnTuneClose = $("#btnTuneClose");
  const btnTuneReset = $("#btnTuneReset");
  const btnTuneImport = $("#btnTuneImport");
  const btnTuneCopy = $("#btnTuneCopy");
  const tunerControls = $("#tunerControls");
  const drawOverlay = $("#drawOverlay");
  const drawRow = $("#drawRow");
  const btnDrawClose = $("#btnDrawClose");
  const drawOverlayInner = drawOverlay.querySelector(".drawOverlayInner");
  const drawScroll = $("#drawScroll");
  const drawThumb = $("#drawThumb");
  // Hook for scrollbar recalculation (assigned in the scroll-sync IIFE below).
  let recalcDrawScrollSoon = null;
  // Draw overlay scrollbar: thumb appears as full bar then shrinks along the card "spread" timeline.
  let drawThumbAnimRaf = null;
  let drawThumbFinalWPercent = 100;

  let game = null;
  let selected = [];
  let lastHumanActionAt = 0;
  let hintT = null;
  let hintHandT = null; // æç¤ºæ‰‹å®šæ—¶å™¨
  let lastTurnPlayerId = null;
  let isDealing = false;
  let suppressHandClickUntil = 0;

  function advancePastOutPlayers() {
    if (!game || game.gameOver) return;
    // If the current player is out, immediately advance until reaching an active one.
    let guard = 0;
    while (!game.gameOver && game.players[game.currentPlayerIndex]?.out && guard++ < 10) {
      window.Game.advanceTurn(game);
    }
  }

  const HINT_MS = 3000;
  const HINT_HAND_MS = 3000; // å‘¼å¸åŠ¨ç”»å‡ºç°åå†ç­‰3ç§’æ˜¾ç¤ºæç¤ºæ‰‹
  const LAYOUT_KEY = "oldmaid_layout_v1";

  const DEFAULT_LAYOUT = {
    top: { left: 32.8, top: -2.8, width: 34.5, height: 8 },
    left: { left: -2.2, top: 37.2, width: 15, height: 8 },
    right: { left: 74.1, top: 37.2, width: 41, height: 8 },
    bottom: { left: 19.7, top: 61.6, width: 62, height: 25 },
    center: { left: 30.5, top: 22.2, width: 40, height: 20 },
    buttons: {
      hint: { x: 0, y: 14 },
      match: { x: 3, y: 14 },
      endturn: { x: 6, y: 14 },
    },
    scales: {
      playerCard: 0.85,
      aiTopCard: 1.29,
      aiSideCard: 1.25,
      uiButtons: 0.84,
      discardPile: 0.82,
    },
    handCount: {
      top: { x: 0, y: 0 },
      left: { x: 0, y: 0 },
      right: { x: 0, y: 0 },
      bottom: { x: 0, y: 0 },
      scaleX: 1.0,
      scaleY: 1.0,
    },
  };

  function getZones() {
    return {
      top: document.querySelector(".zone-top"),
      left: document.querySelector(".zone-left"),
      right: document.querySelector(".zone-right"),
      bottom: document.querySelector(".zone-bottom"),
      center: document.querySelector(".zone-center"),
    };
  }

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }

  function clampToStep(n, min, max, step) {
    const clamped = clamp(n, min, max);
    const stepped = Math.round(clamped / step) * step;
    // Avoid floating point noise for 0.5 steps etc.
    return Number(stepped.toFixed(3));
  }

  function parseMaybeDecimal(raw) {
    if (raw == null) return NaN;
    const s = String(raw).trim().replace(",", ".");
    // Keep only first valid numeric token
    const m = s.match(/-?\d+(\.\d+)?/);
    return m ? Number(m[0]) : NaN;
  }

  function loadLayout() {
    try {
      const raw = localStorage.getItem(LAYOUT_KEY);
      const clone = (o) => JSON.parse(JSON.stringify(o));
      if (!raw) return clone(DEFAULT_LAYOUT);
      const parsed = JSON.parse(raw);
      // Deep-merge for buttons and cardSizes
      const merged = { ...clone(DEFAULT_LAYOUT), ...parsed };
      merged.buttons = { ...clone(DEFAULT_LAYOUT).buttons, ...(parsed.buttons || {}) };
      merged.buttons.hint = { x: 0, y: 0, ...(merged.buttons.hint || {}) };
      merged.buttons.match = { x: 0, y: 0, ...(merged.buttons.match || {}) };
      merged.buttons.endturn = { x: 0, y: 0, ...(merged.buttons.endturn || {}) };
      merged.scales = { ...clone(DEFAULT_LAYOUT).scales, ...(parsed.scales || {}) };
      merged.handCount = { ...clone(DEFAULT_LAYOUT).handCount, ...(parsed.handCount || {}) };
      merged.handCount.top = { x: 0, y: 0, ...(merged.handCount.top || {}) };
      merged.handCount.left = { x: 0, y: 0, ...(merged.handCount.left || {}) };
      merged.handCount.right = { x: 0, y: 0, ...(merged.handCount.right || {}) };
      merged.handCount.bottom = { x: 0, y: 0, ...(merged.handCount.bottom || {}) };
      return merged;
    } catch {
      return JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
    }
  }

  function saveLayout(layout) {
    try {
      localStorage.setItem(LAYOUT_KEY, JSON.stringify(layout));
    } catch {
      // ignore
    }
  }

  function applyLayout(layout) {
    const zones = getZones();
    for (const key of Object.keys(zones)) {
      const el = zones[key];
      const v = layout[key];
      if (!el || !v) continue;
      const left = clamp(Number(v.left), -10, 95);
      const top = clamp(Number(v.top), -10, 95);
      const width = clamp(Number(v.width), 8, 95);
      const height = clamp(Number(v.height), 8, 80);
      el.style.left = `${left}%`;
      el.style.top = `${top}%`;
      el.style.width = `${width}%`;
      el.style.height = `${height}%`;
    }

    // Button offsets
    const btns = layout.buttons || {};
    const applyBtn = (el, cfg) => {
      if (!el || !cfg) return;
      const x = clamp(Number(cfg.x), -260, 260);
      const y = clamp(Number(cfg.y), -180, 180);
      el.style.setProperty("--btnX", `${x}px`);
      el.style.setProperty("--btnY", `${y}px`);
    };
    applyBtn(btnHintImg, btns.hint);
    applyBtn(btnMatchImg, btns.match);
    applyBtn(btnEndTurnImg, btns.endturn);

    // Apply scales
    const scales = layout.scales || {};
    document.documentElement.style.setProperty("--scale-player-card", String(clamp(scales.playerCard || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-ai-top-card", String(clamp(scales.aiTopCard || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-ai-side-card", String(clamp(scales.aiSideCard || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-ui-buttons", String(clamp(scales.uiButtons || 1.0, 0.5, 2.0)));
    document.documentElement.style.setProperty("--scale-discard-pile", String(clamp(scales.discardPile || 1.0, 0.5, 2.0)));

    // Apply hand count position and scale (per zone)
    const hc = layout.handCount || {};
    // Top zone
    document.documentElement.style.setProperty("--hand-count-top-x", `${clamp((hc.top?.x || 0), -200, 200)}px`);
    document.documentElement.style.setProperty("--hand-count-top-y", `${clamp((hc.top?.y || 0), -200, 200)}px`);
    // Left zone
    document.documentElement.style.setProperty("--hand-count-left-x", `${clamp((hc.left?.x || 0), -200, 200)}px`);
    document.documentElement.style.setProperty("--hand-count-left-y", `${clamp((hc.left?.y || 0), -200, 200)}px`);
    // Right zone
    document.documentElement.style.setProperty("--hand-count-right-x", `${clamp((hc.right?.x || 0), -200, 200)}px`);
    document.documentElement.style.setProperty("--hand-count-right-y", `${clamp((hc.right?.y || 0), -200, 200)}px`);
    // Bottom zone
    document.documentElement.style.setProperty("--hand-count-bottom-x", `${clamp((hc.bottom?.x || 0), -200, 200)}px`);
    document.documentElement.style.setProperty("--hand-count-bottom-y", `${clamp((hc.bottom?.y || 0), -200, 200)}px`);
    // Global scale
    document.documentElement.style.setProperty("--hand-count-scale-x", String(clamp(hc.scaleX || 1.0, 0.3, 3.0)));
    document.documentElement.style.setProperty("--hand-count-scale-y", String(clamp(hc.scaleY || 1.0, 0.3, 3.0)));
  }

  function buildTunerUI(layout) {
    tunerControls.innerHTML = "";
    const groups = [
      ["top", "ä¸Šæ–¹AI"],
      ["left", "å·¦ä¾§AI"],
      ["right", "å³ä¾§AI"],
      ["bottom", "ç©å®¶æ‰‹ç‰Œ"],
      ["center", "å¼ƒç‰Œå †"],
    ];

    function addSlider(groupKey, prop, min, max, step) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = `${prop}(%)`;

      const input = document.createElement("input");
      input.type = "range";
      input.min = String(min);
      input.max = String(max);
      input.step = String(step);
      input.value = String(layout[groupKey][prop]);

      const num = document.createElement("input");
      // Use text input for better decimal keyboard support on mobile (number often hides '.')
      num.type = "text";
      num.className = "tunerNum";
      num.min = String(min);
      num.max = String(max);
      num.step = String(step);
      num.value = String(layout[groupKey][prop]);
      num.inputMode = "decimal";
      num.autocomplete = "off";
      num.spellcheck = false;

      const applyFromRange = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout[groupKey][prop] = n;
        input.value = String(n);
        // Keep number box in sync when slider is used
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextLive = () => {
        // While typing, don't rewrite the text box (so "1." / "-"/ "." can be typed).
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, min, max);
        layout[groupKey][prop] = n;
        input.value = String(n); // range will snap to its step
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextCommit = () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout[groupKey][prop] = n;
        input.value = String(n);
        num.value = String(n); // normalize on commit
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", applyFromRange);
      num.addEventListener("input", applyFromTextLive);
      num.addEventListener("change", applyFromTextCommit);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    function addPxSlider(buttonKey, prop, min, max, step) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = `${prop.toUpperCase()}(px)`;

      const input = document.createElement("input");
      input.type = "range";
      input.min = String(min);
      input.max = String(max);
      input.step = String(step);
      input.value = String(layout.buttons[buttonKey][prop]);

      const num = document.createElement("input");
      // Use text input for consistent keyboard and allow '.' / ',' on mobile
      num.type = "text";
      num.className = "tunerNum";
      num.min = String(min);
      num.max = String(max);
      num.step = String(step);
      num.value = String(layout.buttons[buttonKey][prop]);
      num.inputMode = "decimal";
      num.autocomplete = "off";
      num.spellcheck = false;

      const applyFromRange = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout.buttons[buttonKey][prop] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextLive = () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, min, max);
        layout.buttons[buttonKey][prop] = n;
        input.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      const applyFromTextCommit = () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout.buttons[buttonKey][prop] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", applyFromRange);
      num.addEventListener("input", applyFromTextLive);
      num.addEventListener("change", applyFromTextCommit);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    for (const [key, title] of groups) {
      const g = document.createElement("div");
      g.className = "tunerGroup";
      const t = document.createElement("div");
      t.className = "tunerGroupTitle";
      t.textContent = title;
      g.appendChild(t);

      // Use finer steps so decimal tuning doesn't "snap back" on blur/close.
      g.appendChild(addSlider(key, "left", -10, 95, 0.1));
      g.appendChild(addSlider(key, "top", -10, 95, 0.1));
      g.appendChild(addSlider(key, "width", 8, 95, 0.1));
      g.appendChild(addSlider(key, "height", 8, 80, 0.1));
      tunerControls.appendChild(g);
    }

    // Button controls
    const btnGroup = document.createElement("div");
    btnGroup.className = "tunerGroup";
    const bt = document.createElement("div");
    bt.className = "tunerGroupTitle";
    bt.textContent = "æŒ‰é’®ä½ç§»ï¼ˆåƒç´ ï¼‰";
    btnGroup.appendChild(bt);

    const mkSub = (name) => {
      const t = document.createElement("div");
      t.style.marginTop = "8px";
      t.style.fontWeight = "900";
      t.style.fontSize = "12px";
      t.style.opacity = "0.9";
      t.textContent = name;
      return t;
    };

    btnGroup.appendChild(mkSub("æç¤º"));
    btnGroup.appendChild(addPxSlider("hint", "x", -260, 260, 1));
    btnGroup.appendChild(addPxSlider("hint", "y", -180, 180, 1));

    btnGroup.appendChild(mkSub("åŒ¹é…å‡ºç‰Œ"));
    btnGroup.appendChild(addPxSlider("match", "x", -260, 260, 1));
    btnGroup.appendChild(addPxSlider("match", "y", -180, 180, 1));

    btnGroup.appendChild(mkSub("ç»“æŸå›åˆ"));
    btnGroup.appendChild(addPxSlider("endturn", "x", -260, 260, 1));
    btnGroup.appendChild(addPxSlider("endturn", "y", -180, 180, 1));

    tunerControls.appendChild(btnGroup);

    // Hand count badge controls
    const handCountGroup = document.createElement("div");
    handCountGroup.className = "tunerGroup";
    const hcTitle = document.createElement("div");
    hcTitle.className = "tunerGroupTitle";
    hcTitle.textContent = "æ‰‹ç‰Œæ•°æ ‡ç‰Œä½ç½®ä¸ç¼©æ”¾";
    handCountGroup.appendChild(hcTitle);

    function addHandCountPosSlider(zone, axis, label, min, max, step) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = `${label}(px)`;

      const input = document.createElement("input");
      input.type = "range";
      input.min = String(min);
      input.max = String(max);
      input.step = String(step);
      input.value = String(layout.handCount[zone][axis]);

      const num = document.createElement("input");
      num.type = "text";
      num.className = "tunerNum";
      num.value = String(layout.handCount[zone][axis]);
      num.inputMode = "decimal";

      const apply = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout.handCount[zone][axis] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", apply);
      num.addEventListener("input", () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, min, max);
        layout.handCount[zone][axis] = n;
        input.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      });
      num.addEventListener("change", apply);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    function addHandCountScaleSlider(prop, label, min, max, step) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = label;

      const input = document.createElement("input");
      input.type = "range";
      input.min = String(min);
      input.max = String(max);
      input.step = String(step);
      input.value = String(layout.handCount[prop]);

      const num = document.createElement("input");
      num.type = "text";
      num.className = "tunerNum";
      num.value = String(layout.handCount[prop]);
      num.inputMode = "decimal";

      const apply = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, min, max, step);
        layout.handCount[prop] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", apply);
      num.addEventListener("input", () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, min, max);
        layout.handCount[prop] = n;
        input.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      });
      num.addEventListener("change", apply);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    // Top zone
    handCountGroup.appendChild(mkSub("ä¸Šæ–¹AI"));
    handCountGroup.appendChild(addHandCountPosSlider("top", "x", "Xåç§»", -200, 200, 1));
    handCountGroup.appendChild(addHandCountPosSlider("top", "y", "Yåç§»", -200, 200, 1));

    // Left zone
    handCountGroup.appendChild(mkSub("å·¦ä¾§AI"));
    handCountGroup.appendChild(addHandCountPosSlider("left", "x", "Xåç§»", -200, 200, 1));
    handCountGroup.appendChild(addHandCountPosSlider("left", "y", "Yåç§»", -200, 200, 1));

    // Right zone
    handCountGroup.appendChild(mkSub("å³ä¾§AI"));
    handCountGroup.appendChild(addHandCountPosSlider("right", "x", "Xåç§»", -200, 200, 1));
    handCountGroup.appendChild(addHandCountPosSlider("right", "y", "Yåç§»", -200, 200, 1));

    // Bottom zone
    handCountGroup.appendChild(mkSub("ç©å®¶"));
    handCountGroup.appendChild(addHandCountPosSlider("bottom", "x", "Xåç§»", -200, 200, 1));
    handCountGroup.appendChild(addHandCountPosSlider("bottom", "y", "Yåç§»", -200, 200, 1));

    // Global scale
    handCountGroup.appendChild(mkSub("å…¨å±€ç¼©æ”¾"));
    handCountGroup.appendChild(addHandCountScaleSlider("scaleX", "Xç¼©æ”¾", 0.3, 3.0, 0.01));
    handCountGroup.appendChild(addHandCountScaleSlider("scaleY", "Yç¼©æ”¾", 0.3, 3.0, 0.01));

    tunerControls.appendChild(handCountGroup);

    // Scales group
    const scaleGroup = document.createElement("div");
    scaleGroup.className = "tunerGroup";
    const scaleTitle = document.createElement("div");
    scaleTitle.className = "tunerGroupTitle";
    scaleTitle.textContent = "å¡ç‰Œä¸æŒ‰é’®ç¼©æ”¾";
    scaleGroup.appendChild(scaleTitle);

    function addScaleSlider(scaleKey, label) {
      const row = document.createElement("div");
      row.className = "tunerRow";

      const lab = document.createElement("label");
      lab.textContent = label;

      const input = document.createElement("input");
      input.type = "range";
      input.min = "0.5";
      input.max = "2.0";
      input.step = "0.01";
      input.value = String(layout.scales[scaleKey]);

      const num = document.createElement("input");
      num.type = "text";
      num.className = "tunerNum";
      num.value = String(layout.scales[scaleKey]);
      num.inputMode = "decimal";

      const apply = () => {
        const n0 = parseMaybeDecimal(input.value);
        if (Number.isNaN(n0)) return;
        const n = clampToStep(n0, 0.5, 2.0, 0.01);
        layout.scales[scaleKey] = n;
        input.value = String(n);
        num.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      };

      input.addEventListener("input", apply);
      num.addEventListener("input", () => {
        const n0 = parseMaybeDecimal(num.value);
        if (Number.isNaN(n0)) return;
        const n = clamp(n0, 0.5, 2.0);
        layout.scales[scaleKey] = n;
        input.value = String(n);
        applyLayout(layout);
        saveLayout(layout);
      });
      num.addEventListener("change", apply);

      row.appendChild(lab);
      row.appendChild(input);
      row.appendChild(num);
      return row;
    }

    scaleGroup.appendChild(addScaleSlider("playerCard", "ç©å®¶æ‰‹ç‰Œ"));
    scaleGroup.appendChild(addScaleSlider("aiTopCard", "AIä¸Šå®¶"));
    scaleGroup.appendChild(addScaleSlider("aiSideCard", "AIå·¦å³"));
    scaleGroup.appendChild(addScaleSlider("discardPile", "å¼ƒç‰Œå †"));
    scaleGroup.appendChild(addScaleSlider("uiButtons", "UIæŒ‰é’®"));

    tunerControls.appendChild(scaleGroup);
  }

  // Init layout tuning
  let layout = loadLayout();
  applyLayout(layout);
  buildTunerUI(layout);

  function updateTuneButtonState() {
    const gameEl = $("#game");
    btnTune.disabled = gameEl.classList.contains("hidden");
    if (btnTune.disabled) tunerPanel.classList.add("hidden");
  }
  updateTuneButtonState();

  function clearHintHighlight() {
    const cards = Array.from($("#pBottomHand").querySelectorAll(".faceCard"));
    for (const el of cards) {
      el.classList.remove("hintPulse");
      el.classList.remove("hintPulseAuto");
    }

    // æ¸…é™¤ä¿æŠ¤æ ‡è®°ï¼Œå…è®¸ renderSeats é‡å»ºå…ƒç´ 
    const bottomHandEl = document.getElementById("pBottomHand");
    if (bottomHandEl) {
      bottomHandEl.dataset.adjusting = "";
    }
  }

  function clearHintHand() {
    const hintHand = document.getElementById("hintHand");
    if (hintHand) {
      hintHand.remove();
    }
  }

  function showHintHand() {
    // å…ˆæ¸…é™¤å·²æœ‰çš„æç¤ºæ‰‹
    clearHintHand();

    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;

    // æ£€æŸ¥åº”è¯¥æç¤ºå“ªé‡Œ
    const hasPair = window.Game.findAnyPairInHand(game.players[0].hand);

    let targetEl = null;
    if (hasPair) {
      // æœ‰é…å¯¹ç‰Œï¼šæç¤ºæ‰‹ç‰Œä¸­çš„ç¬¬ä¸€å¼ é…å¯¹ç‰Œ
      const pair = hasPair;
      const cardId = pair[0].id;
      targetEl = $("#pBottomHand").querySelector(`.faceCard[data-card-id="${CSS.escape(cardId)}"]`);
    } else if (!game.turnHasDrawn) {
      // æ²¡æœ‰é…å¯¹ç‰Œä¸”è¿˜æ²¡æŠ½ç‰Œï¼šæç¤ºä¸Šå®¶æ‰‹ç‰Œçš„ç¬¬ä¸€å¼ 
      const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
      if (upstreamIdx >= 0) {
        const upstreamHandEl = seatHandElByPlayerIndex(upstreamIdx);
        if (upstreamHandEl) {
          targetEl = upstreamHandEl.querySelector('.miniBack');
        }
      }
    }

    if (!targetEl) return;

    // åˆ›å»ºæç¤ºæ‰‹å…ƒç´ 
    const hintHand = document.createElement("div");
    hintHand.id = "hintHand";
    hintHand.className = "hintHand clicking"; // ç«‹å³æ·»åŠ ç‚¹å‡»åŠ¨ç”»ç±»
    document.body.appendChild(hintHand);

    // è·å–ç›®æ ‡å¡ç‰Œä½ç½®
    const targetRect = targetEl.getBoundingClientRect();
    const handSize = 60; // æç¤ºæ‰‹å›¾ç‰‡å¤§å°

    // å®šä½åˆ°å¡ç‰Œå³ä¸Šè§’
    hintHand.style.left = `${targetRect.right - handSize / 2}px`;
    hintHand.style.top = `${targetRect.top - handSize / 2}px`;
  }

  function maybeShowHint(isAuto = false) {
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;

    const pair = window.Game.findAnyPairInHand(game.players[0].hand);
    if (!pair) return;

    const a = pair[0].id;
    const b = pair[1].id;

    // è®¾ç½®ä¿æŠ¤æ ‡è®°ï¼Œé˜²æ­¢ renderSeats æ‰“æ–­æç¤ºåŠ¨ç”»
    const bottomHandEl = document.getElementById("pBottomHand");
    if (bottomHandEl) {
      bottomHandEl.dataset.adjusting = "true";
    }

    if (isAuto) {
      // è‡ªåŠ¨æç¤ºï¼šåªæ˜¾ç¤ºå‘¼å¸ç¼©æ”¾åŠ¨ç”»ï¼Œä¸é€‰ä¸­
      const aEl = $("#pBottomHand").querySelector(
        `.faceCard[data-card-id="${CSS.escape(a)}"]`
      );
      const bEl = $("#pBottomHand").querySelector(
        `.faceCard[data-card-id="${CSS.escape(b)}"]`
      );
      for (const el of [aEl, bEl]) {
        if (!el) continue;
        el.classList.add("hintPulseAuto");
      }
    } else {
      // æ‰‹åŠ¨æç¤ºï¼šè‡ªåŠ¨é€‰ä¸­ä¸¤å¼ ç‰Œï¼ˆå¼¹å‡ºæ•ˆæœï¼‰
      selected = [a, b];
      renderSelectionHighlights();
      syncSelectionUi();
    }

    // 1.2ç§’åæ¸…é™¤ä¿æŠ¤æ ‡è®°ï¼ˆhintPulse åŠ¨ç”»ä¸€ä¸ªå¾ªç¯çš„æ—¶é—´ï¼‰
    setTimeout(() => {
      if (bottomHandEl) {
        bottomHandEl.dataset.adjusting = "";
      }
    }, 1200);
  }

  // æç¤ºä¸Šå®¶æ‰‹ç‰Œï¼ˆå‘¼å¸åŠ¨ç”»ï¼‰
  function hintUpstreamHand() {
    const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
    if (upstreamIdx < 0) return;
    const upstreamHandEl = seatHandElByPlayerIndex(upstreamIdx);
    if (!upstreamHandEl) return;
    const cards = upstreamHandEl.querySelectorAll('.miniBack');
    cards.forEach(card => card.classList.add('hintPulseAuto'));
    setTimeout(() => {
      cards.forEach(card => card.classList.remove('hintPulseAuto'));
    }, 5000);
  }

  function scheduleHintFromNow() {
    if (hintT) return; // already scheduled for current inactivity window
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;

    const stamp = lastHumanActionAt;
    hintT = window.setTimeout(() => {
      // If user acted since scheduling, do nothing.
      if (lastHumanActionAt !== stamp) return;

      // æ£€æŸ¥æ‰‹é‡Œæ˜¯å¦æœ‰å¯é…å¯¹çš„ç‰Œ
      const hasPair = window.Game.findAnyPairInHand(game.players[0].hand);
      if (hasPair) {
        // æœ‰é…å¯¹ç‰Œï¼šæç¤ºæ‰‹ç‰Œ
        maybeShowHint(true);
      } else if (!game.turnHasDrawn) {
        // æ²¡æœ‰é…å¯¹ç‰Œä¸”è¿˜æ²¡æŠ½ç‰Œï¼šæç¤ºä¸Šå®¶æ‰‹ç‰Œ
        hintUpstreamHand();
      }

      // å¯åŠ¨æç¤ºæ‰‹å®šæ—¶å™¨ï¼šå‘¼å¸åŠ¨ç”»å‡ºç°åå†ç­‰3ç§’
      hintHandT = window.setTimeout(() => {
        // å†æ¬¡æ£€æŸ¥ç”¨æˆ·æ˜¯å¦æ“ä½œ
        if (lastHumanActionAt !== stamp) return;
        showHintHand();
      }, HINT_HAND_MS);
    }, HINT_MS);
  }

  function markHumanAction() {
    lastHumanActionAt = Date.now();
    clearHintHighlight();
    clearHintHand();
    window.clearTimeout(hintT);
    hintT = null;
    window.clearTimeout(hintHandT);
    hintHandT = null;
    scheduleHintFromNow();
  }

  // Ensure slider max matches available pairs, and clamp current value.
  if (Array.isArray(imagePairs) && imagePairs.length > 0) {
    pairCountInput.max = String(imagePairs.length);
    pairCountNum.max = String(imagePairs.length);
    if (Number(pairCountInput.value) > imagePairs.length) {
      pairCountInput.value = String(imagePairs.length);
      pairCountNum.value = String(imagePairs.length);
    }
  }

  function syncSettings() {
    settings.autoAdvanceMs = 0; // no longer used for turn flow
    settings.aiPaceMs = autoNextToggle.checked ? 325 : 9999999;  // å‡åŠ: 650 â†’ 325

    const pc = Number(pairCountInput.value);
    pairCountNum.value = String(pc);
    pairCountLabel.textContent = String(pc);
    // image mode: 2 cards per pair + 1 joker
    totalCardLabel.textContent = String(pc * 2 + 1);
  }

  function pickPairs(n) {
    const arr = imagePairs.slice();
    for (let i = arr.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr.slice(0, Math.max(1, Math.min(n, arr.length)));
  }

  function startNewGame() {
    syncSettings();
    const pairCount = Number(pairCountInput.value);
    const pickedPairs = pickPairs(pairCount);

    // æ›´æ–°å…³å¡æ˜¾ç¤º
    const currentLevel = window.__GAME_ROUND_TRACKER__.currentLevel;
    $("#levelIndicator").textContent = `- ç¬¬${currentLevel}å…³`;

    game = window.Game.createGame({
      pairs: pickedPairs,
      playerCount: 4,
      seed: String(Date.now()),
    });
    $("#setup").classList.add("hidden");
    $("#game").classList.remove("hidden");
    endOverlay.classList.add("hidden");
    updateTuneButtonState();
    selected = [];
    // Deal animation: render seats, then slide cards in from bottom with delays (no opacity changes).
    isDealing = true;
    renderSeats(game, { deal: true });
    renderDiscardPile(game);
    renderAction(game, settings);
    showLastEvent(game, settings);

    const allFace = Array.from(document.querySelectorAll("#pBottomHand .faceCard"));
    const aiBacks = Array.from(document.querySelectorAll(".seatHand .miniBack"));
    // Init state (AI uses simple fade-in; human uses composited transform animation)
    for (const el of aiBacks) el.classList.add("dealInit");

    // Compute delays: player cards left->right (idx asc).
    const base = 18;
    const stepHuman = 35; // å¢åŠ åˆ°35msï¼Œè®©å‡ºåœºé—´éš”æ›´æ˜æ˜¾
    for (const el of allFace) {
      const idx = Number(el.dataset.dealIndex || 0);
      el.style.animationDelay = `${base + idx * stepHuman}ms`;
    }
    // AI: simple stagger per seat
    const stepAi = 18;
    for (const el of aiBacks) {
      const idx = Number(el.dataset.dealIndex || 0);
      el.style.transitionDelay = `${base + 80 + idx * stepAi}ms`;
    }

    // Trigger in next frame
    window.requestAnimationFrame(() => {
      for (const el of allFace) el.classList.add("dealAnim");
      for (const el of aiBacks) el.classList.add("dealIn");
    });

    // è®¡ç®—æœ€åä¸€å¼ ç©å®¶æ‰‹ç‰ŒåŠ¨ç”»å®Œæˆçš„æ—¶é—´ï¼ˆä¸åŒ…æ‹¬æ¸…ç†ç¼“å†²ï¼‰
    const lastCardCompleteMs = base + (allFace.length - 1) * stepHuman + 420;
    // å®Œæ•´çš„æ¸…ç†æ—¶é—´ï¼ˆåŒ…æ‹¬ç¼“å†²ï¼‰
    const totalMs = base + allFace.length * stepHuman + 420 + 120;

    // å®šä¹‰å¤„ç†å‡½æ•°
    function handleJokerThenPairs() {
      if (game?.jokerPending) {
        // å…ˆå‘JOKER
        const toIdx = Math.floor(Math.random() * game.players.length);
        game.lastEvent = null;

        renderSeats(game);
        renderDiscardPile(game);
        renderAction(game, settings);

        showJokerRevealAndFly(game, toIdx, () => {
          window.Game.dealPendingJokerToPlayer(game, toIdx);
          game.lastEvent = null;
          renderSeats(game, { animateExpand: true });
          renderDiscardPile(game);
          renderAction(game, settings);

          // JOKERå‘ç‰Œå®Œæˆåï¼Œç­‰å¾…1.5ç§’ï¼Œç„¶åå¼€å§‹æ‰€æœ‰ç©å®¶çš„é…å¯¹åŠ¨ç”»
          console.log("[JOKERå‘ç‰Œå®Œæˆ] ç­‰å¾…1.5ç§’åå¼€å§‹é…å¯¹...");
          setTimeout(() => {
            startInitialPairingAnimation();
          }, 1500);
        });
      } else {
        // æ²¡æœ‰JOKERï¼Œç›´æ¥å¼€å§‹é…å¯¹
        startInitialPairingAnimation();
      }
    }

    function startInitialPairingAnimation() {
      // ğŸ†• ç¬¬ä¸€æ­¥ï¼šåœ¨ç§»é™¤é…å¯¹ä¹‹å‰ï¼Œå…ˆä¿å­˜æ‰€æœ‰AIæ‰‹ç‰Œçš„ä½ç½®
      console.log("[å¼€å§‹é…å¯¹] æ­¥éª¤1ï¼šä¿å­˜æ‰€æœ‰AIæ‰‹ç‰Œä½ç½®...");
      const handPositions = {};
      for (let pi = 1; pi < game.players.length; pi++) {
        const handEl = seatHandElByPlayerIndex(pi);
        if (handEl) {
          // ä½¿ç”¨çˆ¶çº§ .zone çš„rectï¼Œå› ä¸º .seatHand çš„é«˜åº¦å¯èƒ½ä¸º0
          const zoneEl = handEl.parentElement;
          const rect = zoneEl ? zoneEl.getBoundingClientRect() : handEl.getBoundingClientRect();
          handPositions[pi] = rect;
          console.log(`[é…å¯¹åŠ¨ç”»] AI${pi} åŸå§‹ä½ç½®(ä½¿ç”¨zone):`, rect);
        }
      }

      // ç¬¬äºŒæ­¥ï¼šæ”¶é›†æ‰€æœ‰ç©å®¶çš„åˆå§‹é…å¯¹ï¼ˆä½†ä¸ç§»é™¤æ‰‹ç‰Œï¼ï¼‰
      console.log("[å¼€å§‹é…å¯¹] æ­¥éª¤2ï¼šæ”¶é›†é…å¯¹ç‰Œä¿¡æ¯...");
      const pairsByPlayer = {}; // { playerIdx: [{card1, card2}, ...] }

      for (let pi = 1; pi < game.players.length; pi++) {
        const player = game.players[pi];
        if (player && !player.out) {
          // åˆ›å»ºæ‰‹ç‰Œçš„å‰¯æœ¬ï¼Œç”¨äºæŸ¥æ‰¾é…å¯¹ï¼ˆä¸å½±å“åŸå§‹æ‰‹ç‰Œï¼‰
          const handCopy = [...player.hand];
          const pairs = [];

          while (handCopy.length > 0) {
            const pair = window.Game.findAnyPairInHand(handCopy);
            if (!pair) break;

            // ä¿å­˜é…å¯¹ä¿¡æ¯ï¼ˆå¼•ç”¨åŸå§‹å¡ç‰Œå¯¹è±¡ï¼‰
            const originalCard1 = player.hand.find(c => c.id === pair[0].id);
            const originalCard2 = player.hand.find(c => c.id === pair[1].id);

            if (originalCard1 && originalCard2) {
              pairs.push({ card1: originalCard1, card2: originalCard2 });
            }

            // ä»å‰¯æœ¬ä¸­ç§»é™¤è¿™ä¸€å¯¹ï¼ˆé¿å…é‡å¤æŸ¥æ‰¾ï¼‰
            const idx1 = handCopy.findIndex(c => c.id === pair[0].id);
            const idx2 = handCopy.findIndex(c => c.id === pair[1].id);
            if (idx1 >= 0) handCopy.splice(idx1, 1);
            if (idx2 >= 0) handCopy.splice(idx2, 1);
          }

          if (pairs.length > 0) {
            pairsByPlayer[pi] = pairs;
            console.log(`[å‘ç‰Œç»“æŸ] AI${pi} æ‰¾åˆ° ${pairs.length} å¯¹ç‰Œï¼ˆæœªç§»é™¤ï¼‰`);
          }
        }
      }

      // æŒ‰AIé¡ºåºæ’­æ”¾é…å¯¹åŠ¨ç”»
      const playerIndices = Object.keys(pairsByPlayer).map(Number).sort((a, b) => a - b);

      if (playerIndices.length > 0) {
        console.log(`[å‘ç‰Œç»“æŸ] å°†æŒ‰AIé¡ºåºæ’­æ”¾é…å¯¹åŠ¨ç”»`);

        // âš ï¸ ä¸è¦å…ˆæ›´æ–°UIï¼éœ€è¦å…ˆè·å–åŸå§‹æ‰‹ç‰Œä½ç½®ï¼ŒåŠ¨ç”»å®Œæˆåå†æ›´æ–°
        // renderSeats(game);
        // renderDiscardPile(game);

        let totalAnimsCompleted = 0;
        let totalAnimsExpected = 0;
        playerIndices.forEach(pi => {
          totalAnimsExpected += pairsByPlayer[pi].length * 2;
        });

        // é€’å½’æ’­æ”¾æ¯ä¸ªAIçš„é…å¯¹
        let currentPlayerIdx = 0;
        let accumulatedDelay = 0;

        function playNextPlayer() {
          if (currentPlayerIdx >= playerIndices.length) {
            // æ‰€æœ‰AIé…å¯¹å®Œæˆ
            console.log("[å‘ç‰Œç»“æŸ] æ‰€æœ‰é…å¯¹åŠ¨ç”»å®Œæˆï¼Œç­‰å¾…ååˆ·æ–°UI");
            setTimeout(() => {
              renderSeats(game);
              renderDiscardPile(game);
              proceedAfterInitialPairs();
            }, 300);
            return;
          }

          const pi = playerIndices[currentPlayerIdx];
          const pairs = pairsByPlayer[pi];
          const aiName = `AI${pi}`;

          // AIæ€è€ƒå»¶è¿Ÿ - å‡åŠç‰ˆ
          const thinkDelay = 250 + Math.random() * 150;  // 0.25-0.4s
          console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} æ€è€ƒä¸­... (${Math.round(thinkDelay)}ms)`);

          setTimeout(() => {
            console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} å¼€å§‹å‡ºç‰Œ (${pairs.length}å¯¹)`);

            // ğŸ“ ä½¿ç”¨ä¹‹å‰ä¿å­˜çš„åŸå§‹ä½ç½®
            const originalFromRect = handPositions[pi];
            if (!originalFromRect) {
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} é”™è¯¯ï¼šæ²¡æœ‰ä¿å­˜çš„åŸå§‹ä½ç½®`);
              currentPlayerIdx++;
              playNextPlayer();
              return;
            }

            // é€’å½’æ’­æ”¾è¯¥AIçš„æ¯ä¸€å¯¹ç‰Œ
            let pairIdx = 0;

            function playNextPair() {
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} playNextPair, pairIdx=${pairIdx}, total=${pairs.length}`);
              if (pairIdx >= pairs.length) {
                // è¯¥AIçš„æ‰€æœ‰é…å¯¹å®Œæˆï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªAI
                console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} æ‰€æœ‰é…å¯¹å®Œæˆ`);
                currentPlayerIdx++;
                playNextPlayer();
                return;
              }

              const pair = pairs[pairIdx];
              const player = game.players[pi];

              // ä½¿ç”¨æœ€å¼€å§‹ä¿å­˜çš„åŸå§‹ä½ç½®ï¼ˆåœ¨ä»»ä½•ç§»é™¤æ“ä½œä¹‹å‰ï¼Œ2497è¡Œä¿å­˜çš„ï¼‰
              // è¿™ä¸ªä½ç½®æ˜¯æ‰‹ç‰Œå®Œæ•´æ—¶çš„ä½ç½®ï¼Œé«˜åº¦æ­£ç¡®
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} ä½¿ç”¨åŸå§‹ä¿å­˜ä½ç½®:`, originalFromRect);

              // è°ƒç”¨åŠ¨ç”»ï¼Œä¼ å…¥åŸå§‹ä¿å­˜çš„ä½ç½®
              console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} å¼€å§‹æ’­æ”¾åŠ¨ç”» pair ${pairIdx + 1}`);
              animateAiDiscardPair(pi, pair.card1, pair.card2, originalFromRect, () => {
                console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} åŠ¨ç”»å®Œæˆ pair ${pairIdx + 1}`);

                // åŠ¨ç”»å®Œæˆåæ‰ä»æ‰‹ç‰Œä¸­ç§»é™¤è¿™ä¸€å¯¹å¹¶æ·»åŠ åˆ°å¼ƒç‰Œå †
                const idx1 = player.hand.findIndex(c => c.id === pair.card1.id);
                const idx2 = player.hand.findIndex(c => c.id === pair.card2.id);
                if (idx1 >= 0) player.hand.splice(idx1, 1);
                if (idx2 >= 0) player.hand.splice(idx2, 1);
                game.discardPile.push(pair.card1, pair.card2);
                player.out = player.hand.length === 0;

                // ç«‹å³æ¸²æŸ“å¼ƒç‰Œå †ï¼ˆæ— ç¼è¡”æ¥ï¼‰
                renderDiscardPile(game);

                // å»¶è¿Ÿæ¸²æŸ“æ‰‹ç‰Œï¼Œç­‰å¾…æ‰‹ç‰Œè°ƒæ•´åŠ¨ç”»å®Œæˆ
                setTimeout(() => {
                  // æ›´æ–°UI
                  renderSeats(game);

                  // å»¶è¿Ÿåå‡ºä¸‹ä¸€å¯¹
                  pairIdx++;
                  if (pairIdx < pairs.length) {
                    const pairDelay = 800 + Math.random() * 400;
                    setTimeout(() => {
                      playNextPair();
                    }, pairDelay);
                  } else {
                    // è¯¥AIæ‰€æœ‰ç‰Œå‡ºå®Œï¼Œè¿›å…¥ä¸‹ä¸€ä¸ªAI
                    currentPlayerIdx++;
                    playNextPlayer();
                  }
                }, 100); // å»¶è¿Ÿ 100msï¼Œç­‰å¾…æ‰‹ç‰Œè°ƒæ•´
              });

            }

            // å¼€å§‹æ’­æ”¾è¯¥AIçš„ç¬¬ä¸€å¯¹
            console.log(`[é…å¯¹åŠ¨ç”»] ${aiName} å‡†å¤‡æ’­æ”¾ç¬¬ä¸€å¯¹`);
            playNextPair();
          }, thinkDelay);
        }

        // å¼€å§‹æ’­æ”¾ç¬¬ä¸€ä¸ªAI
        playNextPlayer();
      } else {
        // æ²¡æœ‰åˆå§‹é…å¯¹ï¼Œç›´æ¥ç»§ç»­
        proceedAfterInitialPairs();
      }
    }

    function proceedAfterInitialPairs() {
      // é…å¯¹å®Œæˆï¼Œå¼€å§‹æ¸¸æˆ
      renderAll(game, settings);
      runAiLoop(game, settings);
    }

    // åœ¨æœ€åä¸€å¼ å¡åŠ¨ç”»å®Œæˆæ—¶ç«‹å³è§¦å‘Jokerç‰¹æ•ˆ
    window.setTimeout(() => {
      handleJokerThenPairs();
    }, lastCardCompleteMs);

    // ç¨åå†è¿›è¡Œæ¸…ç†
    window.setTimeout(() => {
      // Cleanup
      for (const el of [...allFace, ...aiBacks]) {
        el.classList.remove("dealAnim");
        el.style.animationDelay = "";
        el.style.transitionDelay = "";
        // keep AI fade classes removed as well
        el.classList.remove("dealInit", "dealIn");
      }
      isDealing = false;
      lastTurnPlayerId = game.players[game.currentPlayerIndex]?.id || null;
      markHumanAction();
    }, totalMs);
    lastTurnPlayerId = game.players[game.currentPlayerIndex]?.id || null;
    markHumanAction(); // start the 8s timer baseline if it's your turn
  }

  autoNextToggle.addEventListener("change", syncSettings);
  pairCountInput.addEventListener("input", syncSettings);
  pairCountNum.addEventListener("input", () => {
    const min = Number(pairCountInput.min || 1);
    const max = Number(pairCountInput.max || 999);
    const step = Number(pairCountInput.step || 1);
    const pc = clampToStep(Number(pairCountNum.value), min, max, step);
    pairCountInput.value = String(pc);
    syncSettings();
  });
  pairCountNum.addEventListener("change", () => {
    // Normalize on blur/enter
    const min = Number(pairCountInput.min || 1);
    const max = Number(pairCountInput.max || 999);
    const step = Number(pairCountInput.step || 1);
    const pc = clampToStep(Number(pairCountNum.value), min, max, step);
    pairCountNum.value = String(pc);
    pairCountInput.value = String(pc);
    syncSettings();
  });

  btnStart.addEventListener("click", startNewGame);
  btnRestart.addEventListener("click", () => {
    $("#game").classList.add("hidden");
    $("#setup").classList.remove("hidden");
    $("#message").innerHTML = "";
    game = null;
    selected = [];
    window.clearTimeout(hintT);
    hintT = null;
    window.clearTimeout(hintHandT);
    hintHandT = null;
    clearHintHand();
    window.clearTimeout(runAiLoop._t);
    runAiLoop._t = null;
    endOverlay.classList.add("hidden");
    updateTuneButtonState();
  });

  btnPlayAgain.addEventListener("click", () => {
    startNewGame();
  });

  $("#btnNextLevel").addEventListener("click", () => {
    // è¿›å…¥ä¸‹ä¸€å…³
    if (window.__GAME_ROUND_TRACKER__.currentLevel < 3) {
      window.__GAME_ROUND_TRACKER__.currentLevel++;
      window.__GAME_ROUND_TRACKER__.roundNumber = window.__GAME_ROUND_TRACKER__.currentLevel - 1;
      startNewGame();
    }
  });

  btnBackToSetup.addEventListener("click", () => {
    // è¿”å›è®¾ç½®æ—¶é‡ç½®å…³å¡
    window.__GAME_ROUND_TRACKER__.currentLevel = 1;
    window.__GAME_ROUND_TRACKER__.roundNumber = 0;
    btnRestart.click();
  });

  btnTune.addEventListener("click", () => {
    if (btnTune.disabled) return;
    tunerPanel.classList.toggle("hidden");
  });
  btnTuneClose.addEventListener("click", () => {
    tunerPanel.classList.add("hidden");
  });
  btnTuneReset.addEventListener("click", () => {
    layout = JSON.parse(JSON.stringify(DEFAULT_LAYOUT));
    saveLayout(layout);
    applyLayout(layout);
    buildTunerUI(layout);
  });

  btnTuneImport.addEventListener("click", () => {
    const example = JSON.stringify(layout, null, 2);
    const raw = window.prompt("ç²˜è´´å¸ƒå±€ JSONï¼ˆä¼šè¦†ç›–å½“å‰å¸ƒå±€ï¼‰ï¼š", example);
    if (!raw) return;
    try {
      const parsed = JSON.parse(raw);
      const required = ["top", "left", "right", "bottom", "center"];
      for (const k of required) {
        if (!parsed[k]) throw new Error("missing " + k);
        for (const p of ["left", "top", "width", "height"]) {
          if (typeof parsed[k][p] !== "number") throw new Error(`invalid ${k}.${p}`);
        }
      }
      if (parsed.buttons) {
        // Optional
        for (const key of ["hint", "match", "endturn"]) {
          if (parsed.buttons[key]) {
            if (typeof parsed.buttons[key].x !== "number") throw new Error(`invalid buttons.${key}.x`);
            if (typeof parsed.buttons[key].y !== "number") throw new Error(`invalid buttons.${key}.y`);
          }
        }
      }
      layout = parsed;
      if (!layout.buttons) layout.buttons = JSON.parse(JSON.stringify(DEFAULT_LAYOUT.buttons));
      saveLayout(layout);
      applyLayout(layout);
      buildTunerUI(layout);
    } catch (e) {
      alert("å¯¼å…¥å¤±è´¥ï¼šJSON æ ¼å¼æˆ–å­—æ®µä¸å¯¹ã€‚");
    }
  });
  btnTuneCopy.addEventListener("click", async () => {
    const text = JSON.stringify(layout, null, 2);
    try {
      await navigator.clipboard.writeText(text);
      alert("å‚æ•°å·²å¤åˆ¶åˆ°å‰ªè´´æ¿ï¼");
    } catch {
      // Fallback: prompt copy
      const copied = window.prompt("å¤åˆ¶ä¸‹é¢çš„å‚æ•°ï¼ˆCmd+Cï¼‰ï¼š", text);
      if (copied !== null) {
        alert("è¯·æ‰‹åŠ¨å¤åˆ¶ä¸Šé¢çš„å‚æ•°");
      }
    }
  });

  function syncSelectionUi() {
    const isHumanTurn = game && !game.gameOver && game.players[game.currentPlayerIndex].kind === "human";
    const canTry = isHumanTurn && selected.length === 2;
    btnTryMatch.disabled = !canTry;
    btnClearSelect.disabled = !isHumanTurn || selected.length === 0;
  }

  function renderSelectionHighlights() {
    const cards = Array.from($("#pBottomHand").querySelectorAll(".faceCard"));
    for (const el of cards) {
      const id = el.dataset.cardId;
      el.classList.toggle("selected", selected.includes(id));
    }
  }

  function clearSelection() {
    selected = [];
    renderSelectionHighlights();
    syncSelectionUi();
  }

  // ä¸Šå®¶æ‰‹ç‰ŒåŠ¨ç”»ï¼šæŒ‰ä½æ—¶ä¿æŒå¯è§ï¼Œæ¾æ‰‹åéšè—
  function animateUpstreamRotateAndOpen(fromIdx) {
    const upstream = game.players[fromIdx];
    if (!upstream || upstream.hand.length === 0) {
      openDrawOverlay(fromIdx);
      return;
    }

    const handEl = seatHandElByPlayerIndex(fromIdx);
    const backs = Array.from(handEl.querySelectorAll(".miniBack"));
    if (backs.length === 0) {
      openDrawOverlay(fromIdx);
      return;
    }

    // è¾¹ç•Œæƒ…å†µï¼šåªæœ‰1å¼ ç‰Œï¼Œç›´æ¥æ‰“å¼€æŠ½ç‰Œç•Œé¢
    if (backs.length === 1) {
      openDrawOverlay(fromIdx);
      return;
    }

    // â­ æ–°é€»è¾‘ï¼šæŒ‰ä½æ—¶åªåˆæ‹¢åˆ°ä¸­å¿ƒç‚¹ï¼Œä¸æ—‹è½¬ã€ä¸ç¼©æ”¾
    // å¿«é€Ÿè¿‡æ¸¡ï¼š80mså®ŒæˆåŠ¨ç”»
    backs.forEach(card => {
      card.style.transition = 'left 80ms ease-out, top 80ms ease-out';
    });

    requestAnimationFrame(() => {
      backs.forEach(card => {
        // èšåˆåˆ°ä¸­å¿ƒç‚¹ï¼ˆ0, 0ï¼‰ï¼Œå³æ‰‹ç‰ŒåŒºåŸŸçš„ä¸­å¿ƒ
        card.style.setProperty('--sx', '0px');
        card.style.setProperty('--sy', '0px');
        // ä¸ä¿®æ”¹ transformï¼Œä¿æŒåŸæœ‰çš„æ—‹è½¬å’Œç¼©æ”¾
      });
    });

    // æ ‡è®°åŠ¨ç”»å·²å®Œæˆï¼Œç­‰å¾… pointerup
    setTimeout(() => {
      handEl.dataset.animationComplete = "true";
    }, 80);
  }

  function openDrawOverlay(fromIdx) {
    console.log(">>> openDrawOverlay è¢«è°ƒç”¨, fromIdx:", fromIdx);

    if (!game || game.gameOver) {
      console.log(">>> æ¸¸æˆä¸å­˜åœ¨æˆ–å·²ç»“æŸ");
      return;
    }
    advancePastOutPlayers();
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.out || current.kind !== "human") {
      console.log(">>> å½“å‰ç©å®¶ä¸æ˜¯äººç±»æˆ–å·²å‡ºå±€");
      return;
    }
    if (game.turnHasDrawn) {
      console.log(">>> æœ¬å›åˆå·²ç»æŠ½è¿‡ç‰Œäº†");
      return;
    }
    const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
    if (fromIdx !== upstreamIdx) {
      console.log(">>> fromIdx ä¸æ˜¯ä¸Šå®¶:", fromIdx, "!=", upstreamIdx);
      return;
    }
    const target = game.players[fromIdx];
    if (!target || target.out || target.hand.length === 0) {
      console.log(">>> ç›®æ ‡ç©å®¶ä¸å­˜åœ¨æˆ–å·²å‡ºå±€æˆ–æ— ç‰Œ");
      return;
    }

    console.log(">>> å‡†å¤‡è°ƒç”¨ ensureHumanCanMatch");

    // åœ¨æ˜¾ç¤ºæŠ½ç‰Œç•Œé¢å‰ï¼Œæ ¹æ®è¿ç»­æœªåŒ¹é…æ¬¡æ•°å†³å®šæ˜¯å¦ä½œå¼Šæ¢ç‰Œ
    try {
      window.Game.ensureHumanCanMatch(game);
      console.log(">>> ensureHumanCanMatch è°ƒç”¨å®Œæˆ");
    } catch (e) {
      console.error(">>> ensureHumanCanMatch error:", e);
    }

    console.log(">>> æ˜¾ç¤ºæŠ½ç‰Œç•Œé¢");
    drawOverlay.classList.remove("hidden");
    // Restore content visibility (in case it was hidden during animation)
    if (drawOverlayInner) drawOverlayInner.style.opacity = "";
    drawRow.innerHTML = "";
    drawScroll.classList.add("hidden");
    drawThumb.style.setProperty("--thumbW", "100%");
    drawThumb.style.setProperty("--thumbX", "0px");

    // Clamp overlay width to the background table so cards never exceed table edges.
    try {
      const tableBg = document.querySelector(".tableBg");
      if (tableBg && drawOverlayInner) {
        const rect = tableBg.getBoundingClientRect();
        const w = Math.max(320, Math.floor(rect.width));
        drawOverlayInner.style.width = `${w}px`;
        // Also align overlay vertically to the tableBg center (prevents the row looking "too low").
        const tableCy = rect.top + rect.height / 2;
        const viewCy = window.innerHeight / 2;
        const dy = tableCy - viewCy;
        drawOverlayInner.style.transform = `translateY(${Math.round(dy)}px)`;
      }
    } catch {
      // ignore
    }

    // No auto-sizing: drawBack uses fixed CSS size; row can scroll horizontally if needed.
    // Ensure the first card is fully visible by default.
    try {
      drawRow.scrollLeft = 0;
    } catch {
      // ignore
    }

    // ç¦ç”¨è¿‡æ¸¡ghostå¡ç‰ŒåŠ¨ç”»ï¼ˆç›´æ¥æ‰“å¼€æŠ½ç‰Œç•Œé¢ï¼Œæ— è¿‡æ¸¡ï¼‰
    // if (!suppressDrawOverlayGhost) { ... } å·²åˆ é™¤

    // Thumb animation: start as full bar, then shrink to correct width in sync with the "spread" timeline.
    // If the user interacts (wheel/drag), we will instantly finish this animation for max smoothness.
    try { if (drawThumbAnimRaf != null) window.cancelAnimationFrame(drawThumbAnimRaf); } catch { /* ignore */ }
    drawThumbAnimRaf = null;
    drawThumbFinalWPercent = 100;
    drawThumb.style.setProperty("--thumbDur", `0ms`);
    drawThumb.style.setProperty("--thumbW", "100%");
    drawThumb.style.setProperty("--thumbX", "0px");

    // ä½¿ç”¨çœŸå®æ‰‹ç‰Œæ•°é‡
    const handSize = target.hand.length;

    for (let i = 0; i < handSize; i++) {
      const b = document.createElement("button");
      b.type = "button";
      b.className = "drawBack";
      b.dataset.fromPlayerIndex = String(fromIdx);
      b.dataset.drawIndex = String(i);
      // "ç å¼€" feel: start overlapped then spread to normal positions.
      b.style.setProperty("--preX", `${-i * 26}px`);
      b.addEventListener("click", () => {
        if (!game || game.gameOver) return;
        advancePastOutPlayers();
        const cur = game.players[game.currentPlayerIndex];
        if (!cur || cur.out || cur.kind !== "human") {
          closeDrawOverlay();
          renderAll(game, settings);
          runAiLoop(game, settings);
          return;
        }
        if (game.turnHasDrawn) return;
        markHumanAction();

        // ğŸ†• æ¦‚ç‡åŒ¹é…æœºå™¨ï¼šæ ¹æ®è¿ç»­æœªåŒ¹é…æ¬¡æ•°å†³å®šæŠ½ç‰Œæ¦‚ç‡
        let probability = 0.5;
        if (game.humanDrawAttempts === 1) probability = 0.7;
        if (game.humanDrawAttempts >= 2) probability = 1.0;

        const shouldMatch = Math.random() < probability;

        console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] å°è¯•æ¬¡æ•°:${game.humanDrawAttempts} æ¦‚ç‡:${(probability*100).toFixed(0)}% è§¦å‘:${shouldMatch}`);

        // ä»ä¸Šå®¶æ‰‹ç‰Œä¸­æŠ½å–ï¼ˆçœŸå®å¡ç‰Œï¼‰
        let drawnCard = target.hand[i];
        let foundMatch = false;

        // å¦‚æœéœ€è¦åŒ¹é…ï¼Œå°è¯•æ›¿æ¢ä¸ºèƒ½é…å¯¹çš„ç‰Œ
        if (shouldMatch) {
          // æŸ¥æ‰¾ç©å®¶æ‰‹ä¸­å¯é…å¯¹çš„ç‰Œ
          for (const playerCard of cur.hand) {
            if (!playerCard.pairId) continue;

            // åœ¨ä¸Šå®¶æ‰‹ä¸­æ‰¾å¯¹åº”çš„é…å¯¹ç‰Œ
            const neededSide = playerCard.side === "A" ? "B" : "A";
            const matchingIndex = target.hand.findIndex(c =>
              c.pairId === playerCard.pairId && c.side === neededSide
            );

            if (matchingIndex !== -1) {
              // æ‰¾åˆ°åŒ¹é…çš„ç‰Œï¼Œæ›¿æ¢åŸæœ¬è¦æŠ½çš„ç‰Œ
              drawnCard = target.hand[matchingIndex];
              console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] æ›¿æ¢ä¸ºåŒ¹é…å¡: ${drawnCard.id} (ä¸ ${playerCard.id} é…å¯¹)`);
              foundMatch = true;
              break;
            }
          }

          // å¦‚æœ100%æ¦‚ç‡ä½†ä¸Šå®¶æ²¡æœ‰å¯é…å¯¹çš„ç‰Œï¼Œä»å…¶ä»–ç©å®¶æ‰‹ä¸­æ‰¾å¹¶é™é»˜äº¤æ¢
          if (!foundMatch && probability === 1.0) {
            console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] ä¸Šå®¶æ— å¯åŒ¹é…çš„ç‰Œï¼Œå°è¯•ä»å…¶ä»–ç©å®¶äº¤æ¢...`);

            // æŸ¥æ‰¾å…¶ä»–ç©å®¶ï¼ˆä¸åŒ…æ‹¬å½“å‰ç©å®¶å’Œä¸Šå®¶ï¼‰
            const otherPlayers = game.players.filter((p, idx) =>
              idx !== game.currentPlayerIndex &&
              idx !== fromIdx &&
              !p.out &&
              p.hand.length > 0
            );

            // éå†ç©å®¶æ‰‹ç‰Œï¼Œæ‰¾å¯é…å¯¹çš„ç‰Œ
            for (const playerCard of cur.hand) {
              if (!playerCard.pairId || foundMatch) continue;

              const neededSide = playerCard.side === "A" ? "B" : "A";

              // åœ¨å…¶ä»–ç©å®¶ä¸­æ‰¾å¯é…å¯¹çš„ç‰Œ
              for (const otherPlayer of otherPlayers) {
                const matchingCardIndex = otherPlayer.hand.findIndex(c =>
                  c.pairId === playerCard.pairId && c.side === neededSide
                );

                if (matchingCardIndex !== -1) {
                  // æ‰¾åˆ°äº†ï¼é™é»˜äº¤æ¢ï¼šå…¶ä»–ç©å®¶çš„é…å¯¹ç‰Œ â†” ä¸Šå®¶çš„æŸå¼ éšæœºç‰Œ
                  const matchingCard = otherPlayer.hand[matchingCardIndex];
                  const randomUpstreamIndex = Math.floor(Math.random() * target.hand.length);
                  const swapCard = target.hand[randomUpstreamIndex];

                  // æ‰§è¡Œäº¤æ¢
                  otherPlayer.hand[matchingCardIndex] = swapCard;
                  target.hand[randomUpstreamIndex] = matchingCard;

                  // å¦‚æœç©å®¶ç‚¹å‡»çš„æ­£å¥½æ˜¯è¢«äº¤æ¢èµ°çš„ç‰Œï¼Œæ›´æ–°drawnCard
                  if (i === randomUpstreamIndex) {
                    drawnCard = matchingCard;
                  } else {
                    // å¦åˆ™ç›´æ¥ä½¿ç”¨è¿™å¼ é…å¯¹ç‰Œ
                    drawnCard = matchingCard;
                  }

                  console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] é™é»˜äº¤æ¢æˆåŠŸ: ${otherPlayer.name}çš„${matchingCard.id} â†” ${target.name}çš„${swapCard.id}`);
                  console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] ç©å®¶å°†æŠ½åˆ°é…å¯¹ç‰Œ: ${drawnCard.id} (ä¸ ${playerCard.id} é…å¯¹)`);
                  foundMatch = true;
                  break;
                }
              }

              if (foundMatch) break;
            }

            if (!foundMatch) {
              console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] å…¶ä»–ç©å®¶ä¹Ÿæ— å¯åŒ¹é…çš„ç‰Œï¼ŒæŠ½å–åŸå§‹ç‰Œ: ${drawnCard.id}`);
            }
          } else if (!foundMatch) {
            console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] ä¸Šå®¶æ— å¯åŒ¹é…çš„ç‰Œï¼ŒæŠ½å–åŸå§‹ç‰Œ: ${drawnCard.id}`);
          }
        } else {
          console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] æœªè§¦å‘ï¼ŒæŠ½å–åŸå§‹ç‰Œ: ${drawnCard.id}`);
        }

        const isJoker = drawnCard && drawnCard.type === "joker";

        // ğŸ†• åŸåœ°ç¿»è½¬åŠ¨ç”»ï¼šå¡èƒŒ â†’ æ­£é¢ï¼ˆä¸å…‹éš†ï¼Œç›´æ¥ä¿®æ”¹å½“å‰æŒ‰é’®ï¼‰
        // å°†æŒ‰é’®æ”¹é€ æˆåŒé¢å¡ç»“æ„
        b.disabled = true; // ç¦ç”¨æŒ‰é’®ï¼Œé˜²æ­¢é‡å¤ç‚¹å‡»
        b.style.transformStyle = "preserve-3d";
        b.style.transition = "none"; // æ¸…é™¤ CSS è¿‡æ¸¡

        // åˆ›å»ºæ­£é¢ï¼ˆå¡ç‰Œå†…å®¹ï¼‰- 0degæ—¶å¯è§
        const frontFace = document.createElement("div");
        frontFace.className = `faceCard ${isJoker ? "joker imgCard" : "imgCard"}`;
        frontFace.style.width = "100%";
        frontFace.style.height = "100%";
        frontFace.style.position = "absolute";
        frontFace.style.left = "0";
        frontFace.style.top = "0";
        frontFace.style.backfaceVisibility = "hidden";
        frontFace.style.WebkitBackfaceVisibility = "hidden";
        frontFace.style.transform = "rotateY(0deg)";
        frontFace.style.margin = "0";
        frontFace.style.padding = "0";  // æ— paddingï¼Œè®©å›¾ç‰‡é“ºæ»¡
        frontFace.style.boxSizing = "border-box";
        frontFace.style.overflow = "hidden";

        // åˆ›å»ºèƒŒé¢ï¼ˆå¡èƒŒï¼‰- 180degæ—¶å¯è§
        const backFace = document.createElement("div");
        backFace.className = "miniBack";
        backFace.style.width = "100%";
        backFace.style.height = "100%";
        backFace.style.position = "absolute";
        backFace.style.left = "0";
        backFace.style.top = "0";
        backFace.style.backfaceVisibility = "hidden";
        backFace.style.WebkitBackfaceVisibility = "hidden";
        backFace.style.transform = "rotateY(180deg)";

        if (isJoker) {
          frontFace.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="./assets/joker.png" alt="joker" draggable="false" /></div>
            </div>
          `;
        } else if (drawnCard) {
          frontFace.innerHTML = `
            <div class="cardContent">
              <div class="imgWrap"><img class="cardImg" src="${escapeHtml(drawnCard.imgSrc)}" alt="card" draggable="false" /></div>
            </div>
          `;
        }

        // æ¸…ç©ºæŒ‰é’®å†…å®¹ï¼Œæ·»åŠ åŒé¢ç»“æ„
        b.innerHTML = "";
        b.appendChild(frontFace);
        b.appendChild(backFace);

        // åˆå§‹çŠ¶æ€ï¼šæ˜¾ç¤ºèƒŒé¢ï¼ˆ180degï¼‰
        b.style.transform = "rotateY(180deg)";

        // ç¿»è½¬åŠ¨ç”»ï¼š180deg â†’ 360degï¼ˆæ˜¾ç¤ºæ­£é¢ï¼‰
        const flipAnim = b.animate(
          [
            { transform: "rotateY(180deg)" },
            { transform: "rotateY(360deg)" }
          ],
          { duration: 360, easing: "cubic-bezier(0.4, 0, 0.2, 1)", fill: "forwards" }
        );

        flipAnim.onfinish = () => {
          console.log("[ç¿»è½¬å®Œæˆ] å¼€å§‹è·å–å¡ç‰Œä½ç½®...");
          // ğŸ†• ç¿»è½¬å®Œæˆåï¼Œè·å–å½“å‰å¡ç‰Œçš„å®é™…ä½ç½®ä½œä¸ºé£è¡Œèµ·ç‚¹
          const cardRect = b.getBoundingClientRect();
          const cardStartX = cardRect.left + cardRect.width / 2;
          const cardStartY = cardRect.top + cardRect.height / 2;
          console.log("[ç¿»è½¬å®Œæˆ] å¡ç‰Œä½ç½®:", { x: cardStartX, y: cardStartY });

          // å…³é—­æŠ½ç‰Œç•Œé¢
          console.log("[ç¿»è½¬å®Œæˆ] å…³é—­æŠ½ç‰Œç•Œé¢...");
          closeDrawOverlay();

          if (isJoker) {
            console.log("[ç¿»è½¬å®Œæˆ] æ£€æµ‹åˆ°Jokerï¼Œå¯åŠ¨æ–°çš„JokeråŠ¨ç”»");
            // Joker: é£åˆ°å±å¹•ä¸­é—´äº®ç›¸0.8sï¼Œç„¶åé£å‘æ‰‹ç‰Œ
            animateJokerDrawFromPoint(cardStartX, cardStartY, 0, () => {
              // ğŸ†• ç›´æ¥æ·»åŠ ç”Ÿæˆçš„å¡ç‰Œåˆ°ç©å®¶æ‰‹ç‰Œ
              cur.hand.push(drawnCard);
              game.turnHasDrawn = true;

              // æ›´æ–°æ¦‚ç‡
              const hasPotentialMatch = !!drawnCard.pairId && cur.hand.some((c) => c !== drawnCard && c.pairId === drawnCard.pairId);
              if (hasPotentialMatch) {
                game.humanDrawAttempts = 0;
                console.log("[æ¦‚ç‡åŒ¹é…æœºå™¨] åŒ¹é…æˆåŠŸï¼å°è¯•æ¬¡æ•°é‡ç½®ä¸º0ï¼Œä¸‹æ¬¡æ¦‚ç‡50%");
              } else {
                game.humanDrawAttempts++;
                console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] æœªåŒ¹é…ï¼Œå°è¯•æ¬¡æ•°å¢åŠ è‡³${game.humanDrawAttempts}ï¼Œä¸‹æ¬¡æ¦‚ç‡${game.humanDrawAttempts===1?'70%':'100%'}`);
              }

              clearSelection();
              renderAll(game, settings);
            });
          } else {
            console.log("[ç¿»è½¬å®Œæˆ] æ™®é€šå¡ç‰Œï¼Œå¯åŠ¨é£è¡ŒåŠ¨ç”»", { drawnCard, cardStartX, cardStartY });
            // Normal card: fly directly to hand (ä»ç¿»è½¬åçš„å®é™…ä½ç½®å¼€å§‹)
            // ç©å®¶æŠ½ç‰Œï¼Œç›®æ ‡æ˜¯ç´¢å¼•0ï¼ˆäººç±»ç©å®¶ï¼‰
            animateDrawCardFlyFromPoint(cardStartX, cardStartY, 0, drawnCard, () => {
              console.log("[é£è¡Œå®Œæˆ] æ‰§è¡ŒdrawCard...");
              // ğŸ†• ç›´æ¥æ·»åŠ ç”Ÿæˆçš„å¡ç‰Œåˆ°ç©å®¶æ‰‹ç‰Œ
              cur.hand.push(drawnCard);
              game.turnHasDrawn = true;

              // æ›´æ–°æ¦‚ç‡
              const hasPotentialMatch = !!drawnCard.pairId && cur.hand.some((c) => c !== drawnCard && c.pairId === drawnCard.pairId);
              if (hasPotentialMatch) {
                game.humanDrawAttempts = 0;
                console.log("[æ¦‚ç‡åŒ¹é…æœºå™¨] åŒ¹é…æˆåŠŸï¼å°è¯•æ¬¡æ•°é‡ç½®ä¸º0ï¼Œä¸‹æ¬¡æ¦‚ç‡50%");
              } else {
                game.humanDrawAttempts++;
                console.log(`[æ¦‚ç‡åŒ¹é…æœºå™¨] æœªåŒ¹é…ï¼Œå°è¯•æ¬¡æ•°å¢åŠ è‡³${game.humanDrawAttempts}ï¼Œä¸‹æ¬¡æ¦‚ç‡${game.humanDrawAttempts===1?'70%':'100%'}`);
              }

              clearSelection();
              renderAll(game, settings);
              console.log("[é£è¡Œå®Œæˆ] renderAllå®Œæˆ");
            });
          }
        };
      });
      drawRow.appendChild(b);
      // stagger in: ä»å·¦åˆ°å³ä¾æ¬¡å¿«é€Ÿæ¸æ˜¾ï¼Œæ¯å¼ å¡é—´éš”40ms
      window.setTimeout(() => {
        b.classList.add("in");

        // è°ƒè¯•ï¼šæ‰“å°ç¬¬ä¸€å¼ å¡çš„ä¸­å¿ƒç‚¹ä½ç½®
        if (i === 0) {
          window.setTimeout(() => {
            const rect = b.getBoundingClientRect();
            const centerX = rect.left + rect.width / 2;
            const centerY = rect.top + rect.height / 2;
            console.log('æŠ½1å¡ç‰Œä¸­å¿ƒç‚¹ä½ç½®:', { x: centerX, y: centerY, rect });
          }, 500); // ç­‰å¾…å±•å¼€åŠ¨ç”»å®Œæˆ
        }
      }, i * 40); // æ¯å¼ å¡é—´éš”40msï¼Œä»å·¦åˆ°å³å¿«é€Ÿä¾æ¬¡æ˜¾ç¤º
    }

    // Align behavior:
    // - If cards fit in the row, center them (so 1 card sits in the middle).
    // - If overflow, left-align and keep first card fully visible.
    window.requestAnimationFrame(() => {
      try {
        // need a second frame for layout to settle after images/styles
        window.requestAnimationFrame(() => {
          // IMPORTANT: don't rely on scrollWidth here because entry transforms can distort the visual layout
          // and make it *look* like scrolling does nothing. Compute deterministically.
          const nCards = target.hand.length;
          const CARD_W = 140;
          const GAP = 12;
          const PAD = 6; // .drawRow padding left/right
          const contentW = nCards * CARD_W + Math.max(0, nCards - 1) * GAP;
          const avail = Math.max(0, drawRow.clientWidth - PAD * 2);
          const fits = contentW <= avail + 1;

          drawRow.style.justifyContent = fits ? "center" : "flex-start";
          drawRow.scrollLeft = 0;

          // Custom scrollbar: only show when overflow.
          try {
            if (!fits) {
              drawScroll.classList.remove("hidden");
              // Thumb width ratio based on deterministic widths.
              const scrollW = Math.max(avail, contentW);
              const ratio = avail / scrollW;
              const w = Math.max(10, Math.min(100, Math.floor(ratio * 1000) / 10)); // %
              drawThumbFinalWPercent = w;
              // Animate thumb shrinking in sync with the spread.
              // Spread timeline: last card starts at (30 + (n-1)*18) then transitions for ~420ms.
              const total = 30 + Math.max(0, nCards - 1) * 18 + 420;
              const start = performance.now();
              const easeOut = (t) => 1 - Math.pow(1 - t, 3); // close to the feel we use elsewhere
              try { if (drawThumbAnimRaf != null) window.cancelAnimationFrame(drawThumbAnimRaf); } catch { /* ignore */ }
              drawThumbAnimRaf = null;
              const step = (now) => {
                const p01 = Math.max(0, Math.min(1, (now - start) / Math.max(1, total)));
                const e = easeOut(p01);
                const cur = 100 + (drawThumbFinalWPercent - 100) * e;
                drawThumb.style.setProperty("--thumbW", `${cur}%`);
                if (p01 < 1) drawThumbAnimRaf = window.requestAnimationFrame(step);
                else {
                  drawThumbAnimRaf = null;
                  drawThumb.style.setProperty("--thumbW", `${drawThumbFinalWPercent}%`);
                }
              };
              drawThumbAnimRaf = window.requestAnimationFrame(step);
              if (typeof recalcDrawScrollSoon === "function") recalcDrawScrollSoon();
            } else {
              drawScroll.classList.add("hidden");
              if (typeof recalcDrawScrollSoon === "function") recalcDrawScrollSoon();
            }
          } catch {
            // ignore
          }
        });
      } catch {
        // ignore
      }
    });
  }

  function closeDrawOverlay() {
    drawOverlay.classList.add("hidden");
    drawRow.innerHTML = "";
    drawScroll.classList.add("hidden");
    if (typeof recalcDrawScrollSoon === "function") recalcDrawScrollSoon();
    if (drawOverlayInner) {
      drawOverlayInner.style.width = "";
      drawOverlayInner.style.transform = "";
      drawOverlayInner.style.opacity = "";
    }
    // Reset background styles
    drawOverlay.style.background = "";
    drawOverlay.style.backdropFilter = "";

    // ç›´æ¥é‡æ–°æ¸²æŸ“ç©ä¸Šæ‰‹ç‰Œï¼Œæ— å±•å¼€åŠ¨ç”»
    if (game && !game.gameOver) {
      renderSeats(game);
    }
  }

  drawOverlay.addEventListener("click", (e) => {
    if (e.target === drawOverlay) closeDrawOverlay();
  });
  btnDrawClose.addEventListener("click", closeDrawOverlay);

  // Draw overlay: keep custom scrollbar perfectly in sync with drawRow.scrollLeft (and allow dragging).
  // Rebuilt model (for maximum smoothness):
  // - Thumb movement drives scrollLeft directly (1px thumb -> proportional scrollLeft).
  // - ScrollLeft (wheel/touchpad) updates thumb position.
  // - While the entry "spread" is animating, thumb starts full-width then shrinks; first user interaction
  //   instantly finishes both the spread and the thumb shrink animation to avoid any jitter.
  (() => {
    const ROW_PAD_X = 6; // .drawRow padding left/right
    const CARD_W = 140;  // .drawBack width
    const GAP = 12;      // .drawRow gap

    const st = {
      rafSync: null,
      rafRecalc: null,
      dragging: false,
      // cached geometry
      maxScroll: 0,
      trackW: 0,
      thumbWPercent: 100,
      thumbWPx: 0,
      thumbXMax: 0,
      // thumb position cache (px on track)
      thumbX: 0,
      // drag state
      spid: null,
      startClientX: 0,
      startThumbX: 0,
    };

    function clamp01(x) {
      return Math.max(0, Math.min(1, x));
    }
    function clamp(n, min, max) {
      return Math.max(min, Math.min(max, n));
    }

    function readThumbWPercent() {
      // Prefer the CSS variable we set (e.g. "23.4%"), not offsetWidth (layout read).
      try {
        const raw = getComputedStyle(drawThumb).getPropertyValue("--thumbW").trim();
        if (!raw) return 100;
        const s = raw.endsWith("%") ? raw.slice(0, -1) : raw;
        const n = Number.parseFloat(s);
        if (!Number.isFinite(n)) return 100;
        return Math.max(1, Math.min(100, n));
      } catch {
        return 100;
      }
    }

    function recalc() {
      try {
        if (drawScroll.classList.contains("hidden")) {
          st.maxScroll = 0;
          st.trackW = 0;
          st.thumbXMax = 0;
          return;
        }

        st.trackW = drawScroll.clientWidth;
        st.thumbWPercent = readThumbWPercent();
        st.thumbWPx = st.trackW * (st.thumbWPercent / 100);
        st.thumbXMax = Math.max(0, st.trackW - st.thumbWPx);

        // Use deterministic geometry during entry transforms (more stable), but fall back to real scrollWidth
        // when it's larger (after spread has finished).
        const nCards = drawRow ? drawRow.children.length : 0;
        const avail = Math.max(0, drawRow.clientWidth - ROW_PAD_X * 2);
        const contentW = nCards * CARD_W + Math.max(0, nCards - 1) * GAP;
        const detMax = Math.max(0, contentW - avail);
        const realMax = Math.max(0, drawRow.scrollWidth - drawRow.clientWidth);
        st.maxScroll = Math.max(detMax, realMax);

        // Keep cached thumbX inside bounds after geometry changes.
        st.thumbX = clamp(st.thumbX, 0, st.thumbXMax);
      } catch {
        // ignore
      }
    }

    function setThumbX(x) {
      st.thumbX = clamp(x, 0, st.thumbXMax);
      drawThumb.style.setProperty("--thumbX", `${st.thumbX}px`);
    }

    function setThumbFromScrollLeft(scrollLeft) {
      try {
        if (drawScroll.classList.contains("hidden")) return;
        const max = Math.max(1, st.maxScroll);
        const p = clamp01(scrollLeft / max);
        setThumbX(p * st.thumbXMax);
      } catch {
        // ignore
      }
    }

    function ensureInstantSpread() {
      // Entry uses transforms (visual-only). If user starts scrolling/dragging,
      // finish the spread immediately so scroll feedback is visible.
      try { drawRow.classList.add("instant"); } catch { /* ignore */ }
      // Also instantly finish thumb width animation if it's running.
      try {
        if (drawThumbAnimRaf != null) {
          window.cancelAnimationFrame(drawThumbAnimRaf);
          drawThumbAnimRaf = null;
        }
        if (Number.isFinite(drawThumbFinalWPercent)) {
          drawThumb.style.setProperty("--thumbW", `${drawThumbFinalWPercent}%`);
        }
      } catch { /* ignore */ }
    }

    function scheduleRecalc() {
      if (st.rafRecalc != null) return;
      st.rafRecalc = window.requestAnimationFrame(() => {
        st.rafRecalc = null;
        recalc();
        setThumbFromScrollLeft(drawRow.scrollLeft);
      });
    }

    function scheduleSync() {
      if (st.rafSync != null) return;
      st.rafSync = window.requestAnimationFrame(() => {
        st.rafSync = null;
        if (st.dragging) return; // drag path drives thumb directly (more responsive)
        setThumbFromScrollLeft(drawRow.scrollLeft);
      });
    }

    // Init once.
    scheduleRecalc();
    // Expose to open/close overlay code (so showing/hiding the bar always refreshes metrics).
    recalcDrawScrollSoon = scheduleRecalc;

    drawRow.addEventListener("scroll", () => scheduleSync(), { passive: true });
    drawRow.addEventListener("wheel", () => ensureInstantSpread(), { passive: true });

    // Recalc on size changes (overlay width changes / viewport resize).
    try {
      const ro = new ResizeObserver(() => scheduleRecalc());
      ro.observe(drawRow);
      ro.observe(drawScroll);
    } catch {
      window.addEventListener("resize", () => scheduleRecalc(), { passive: true });
    }

    function beginDrag(e) {
      if (drawScroll.classList.contains("hidden")) return;
      if (!drawRow) return;
      // Only primary button for mouse
      if (e.button != null && e.button !== 0) return;

      ensureInstantSpread();
      recalc();
      if (st.maxScroll <= 0 || st.thumbXMax <= 0) return;

      st.spid = e.pointerId;
      st.startClientX = e.clientX;
      st.startThumbX = st.thumbX;
      st.dragging = true;

      try { drawScroll.setPointerCapture(st.spid); } catch { /* ignore */ }
      e.preventDefault();

      // If user clicked the track (not the thumb), jump so the thumb centers around the click.
      const isThumb = e.target === drawThumb || (e.target && e.target.closest && e.target.closest("#drawThumb"));
      if (!isThumb) {
        const trackRect = drawScroll.getBoundingClientRect();
        const clickX = e.clientX - trackRect.left;
        const thumbCenterX = st.thumbX + st.thumbWPx / 2;
        const dx = clickX - thumbCenterX;
        setThumbX(st.thumbX + dx);
        // Drive scroll immediately.
        const p = st.thumbXMax <= 0 ? 0 : st.thumbX / st.thumbXMax;
        drawRow.scrollLeft = p * st.maxScroll;
        // rebase after jump
        st.startClientX = e.clientX;
        st.startThumbX = st.thumbX;
      }
    }

    function moveDrag(e) {
      if (st.spid == null || e.pointerId !== st.spid) return;
      if (st.maxScroll <= 0) return;
      // Use coalesced events for smoother-than-1px mouse steps where available.
      const evs = typeof e.getCoalescedEvents === "function" ? e.getCoalescedEvents() : [e];
      let lastX = st.startThumbX;
      for (const ev of evs) {
        const dx = ev.clientX - st.startClientX;
        lastX = st.startThumbX + dx;
      }
      setThumbX(lastX);
      const p = st.thumbXMax <= 0 ? 0 : st.thumbX / st.thumbXMax;
      drawRow.scrollLeft = p * st.maxScroll;
      e.preventDefault();
    }

    function endDrag(e) {
      if (st.spid == null || e.pointerId !== st.spid) return;
      try { drawScroll.releasePointerCapture(st.spid); } catch { /* ignore */ }
      st.spid = null;
      st.dragging = false;
      scheduleSync();
    }

    drawScroll.addEventListener("pointerdown", beginDrag);
    drawScroll.addEventListener("pointermove", moveDrag);
    drawScroll.addEventListener("pointerup", endDrag);
    drawScroll.addEventListener("pointercancel", endDrag);
  })();

  // Single-card drag (2D) with asymmetric caps + damping:
  // - Horizontal: max 200px (left/right)
  // - Vertical: only upward, max 400px; cannot drag downward
  // - Damping increases near caps; once hitting a cap, lock until release.
  const bottomHandEl = $("#pBottomHand");
  let cardPointerId = null;
  let cardEl = null;
  let cardLastX = 0;
  let cardLastY = 0;
  let cardLastT = 0;
  let cardDx = 0;
  let cardDy = 0;
  let cardVx = 0;
  let cardVy = 0;
  let cardS = 1;
  let cardDragged = false;
  let cardDownAt = 0;
  const CARD_DRAG_CAP_X_PX = 200;
  const CARD_DRAG_CAP_UP_PX = 300;
  const CARD_DRAG_DAMP_P = 2.5; // exponent for ease-out damping increase (slightly softer near the end)
  const CARD_DRAG_SCALE_BASE = 1.0;
  const CARD_DRAG_SCALE_EXTRA = 0.3; // additional scale near caps (ease-out) - max 1.3x
  const EDGE_DAMP_RADIUS_PX = 220; // within this distance to table edge, damping ramps to max
  const DAMP_START_FRAC = 1 / 3; // start damping after 1/3 of the pull-to-cap distance
  let cardLocked = false; // once reached lock point, stop reacting until release
  let springRaf = null;
  // No hover-lift; click selection handles the lift.

  function clamp(n, min, max) {
    return Math.max(min, Math.min(max, n));
  }
  function projectToDragRegion(dx, dy) {
    // dy: only upward (negative), cannot go downward (positive)
    const ndy = clamp(dy, -CARD_DRAG_CAP_UP_PX, 0);
    const ndx = dx;
    if (CARD_DRAG_CAP_X_PX <= 0 || CARD_DRAG_CAP_UP_PX <= 0) {
      return { dx: 0, dy: 0, hit: true };
    }

    // Elliptical boundary (smooth arc):
    // (x/CAP_X)^2 + (y/CAP_UP)^2 <= 1, with y = -dy (upward distance)
    let tx = ndx / CARD_DRAG_CAP_X_PX;
    let ty = Math.max(0, -ndy) / CARD_DRAG_CAP_UP_PX;
    const r2 = tx * tx + ty * ty;
    if (r2 <= 1) return { dx: ndx, dy: ndy, hit: false };
    const r = Math.sqrt(r2) || 1;
    tx /= r;
    ty /= r;
    const x2 = tx * CARD_DRAG_CAP_X_PX;
    const y2 = -ty * CARD_DRAG_CAP_UP_PX;
    return { dx: x2, dy: y2, hit: true };
  }
  function dragFrac(dx, dy) {
    // 0..1 based on radial distance inside the ellipse.
    if (CARD_DRAG_CAP_X_PX <= 0 || CARD_DRAG_CAP_UP_PX <= 0) return 1;
    const tx = dx / CARD_DRAG_CAP_X_PX;
    const ty = Math.max(0, -dy) / CARD_DRAG_CAP_UP_PX;
    return clamp(Math.sqrt(tx * tx + ty * ty), 0, 1);
  }
  const tableBgEl = document.querySelector(".tableBg");
  function edgeFracFromPointer(clientX, clientY) {
    // 0..1: 0 means far from edge, 1 means at/over the edge of table background.
    // This is used to force max damping when the mouse reaches the background edge.
    if (!tableBgEl) return 0;
    const r = tableBgEl.getBoundingClientRect();
    const dx = Math.max(r.left - clientX, 0, clientX - r.right);
    const dy = Math.max(r.top - clientY, 0, clientY - r.bottom);
    // If pointer is outside, treat as edge (max damping).
    if (dx > 0 || dy > 0) return 1;
    const toLeft = clientX - r.left;
    const toRight = r.right - clientX;
    const toTop = clientY - r.top;
    const toBottom = r.bottom - clientY;
    const minDist = Math.max(0, Math.min(toLeft, toRight, toTop, toBottom));
    const t = 1 - clamp(minDist / EDGE_DAMP_RADIUS_PX, 0, 1);
    return t;
  }
  function setCardOffset(el, dx, dy) {
    el.style.setProperty("--dx", `${dx}px`);
    el.style.setProperty("--dy", `${dy}px`);
  }
  function setCardScale(el, s) {
    el.style.setProperty("--s", `${s}`);
  }
  function easeOutPow(t, p) {
    const x = clamp(t, 0, 1);
    return 1 - Math.pow(1 - x, p);
  }
  function easeInPow(t, p) {
    const x = clamp(t, 0, 1);
    return Math.pow(x, p);
  }
  function combinedFrac(frac, edgeFrac) {
    // Avoid "instant big -> small -> big" at drag start when the hand is physically near the table edge:
    // only let edge-based damping contribute once the card is actually pulled out.
    // Weight edge influence by pull fraction so it's ~0 near origin and increases smoothly.
    const f = clamp(frac, 0, 1);
    const e = clamp(edgeFrac, 0, 1);
    const w = easeOutPow(f, 1.4); // 0 -> 1 as pull increases (out curve)
    return Math.max(f, e * w);
  }
  function dampDriver(frac) {
    // Gate the damping so it doesn't start too early:
    // below DAMP_START_FRAC => 0, then ramps 0..1 afterwards.
    const x = clamp(frac, 0, 1);
    const t0 = clamp(DAMP_START_FRAC, 0, 0.95);
    if (x <= t0) return 0;
    return clamp((x - t0) / (1 - t0), 0, 1);
  }

  function stopSpring() {
    if (springRaf) {
      cancelAnimationFrame(springRaf);
      springRaf = null;
    }
  }

  function startSpringBack(el, x0, y0, vx0, vy0, s0) {
    stopSpring();
    if (!el) return;

    // Hard spring snapback with landing bounce on impact
    let x = x0;
    let y = y0;
    const VMAX = 1200; // px/s
    let vx = clamp(vx0, -VMAX, VMAX) * 0.5;
    let vy = clamp(vy0, -VMAX, VMAX) * 0.5;
    let sStart = typeof s0 === "number" && Number.isFinite(s0) ? s0 : 1;
    let tAcc = 0;
    let last = performance.now();
    const startDist = Math.max(1, Math.hypot(x0, y0));
    const v0 = Math.hypot(vx, vy);

    // Hard spring: high omega, critically damped
    const omega = clamp(35 + startDist / 160, 35, 52); // rad/s - fast, hard spring
    const zeta = clamp(1.0 + v0 / 18000, 0.98, 1.15); // critically damped
    const k = omega * omega;
    const c = 2 * zeta * omega;

    el.classList.add("springing");
    el.classList.remove("snapBack");
    el.classList.remove("overshoot");

    // Landing bounce parameters
    const BOUNCE_COEF = 0.28; // coefficient of restitution (energy preserved on bounce)
    const BOUNCE_GRAVITY = 4800; // px/s^2
    const BOUNCE_MIN_VY = 60; // px/s - minimum velocity to trigger bounce

    const step = (now) => {
      let dt = clamp((now - last) / 1000, 0.001, 0.034);
      last = now;
      tAcc += dt;

      // Semi-implicit Euler
      const px = x;
      const py = y;
      const ax = -k * x - c * vx;
      const ay = -k * y - c * vy;
      vx += ax * dt;
      vy += ay * dt;
      x += vx * dt;
      y += vy * dt;

      // X-axis: hard stop at zero
      if ((px > 0 && x <= 0) || (px < 0 && x >= 0)) {
        x = 0;
        vx = 0;
      }

      // Y-axis: detect landing and trigger bounce
      if (py < 0 && y >= 0 && vy > 0) {
        // Just crossed zero from above with downward velocity
        const impactVy = Math.abs(vy);
        x = 0;
        y = 0;
        vx = 0;
        vy = 0;

        // Start landing bounce if impact velocity is significant
        if (impactVy >= BOUNCE_MIN_VY) {
          const bounceVy = -impactVy * BOUNCE_COEF; // upward velocity after bounce
          let by = 0;
          let bvy = bounceVy;
          let lastB = performance.now();

          const bounceStep = (nowB) => {
            const dtB = clamp((nowB - lastB) / 1000, 0.001, 0.034);
            lastB = nowB;
            bvy += BOUNCE_GRAVITY * dtB;
            by += bvy * dtB;

            // Bounce finished when back at ground moving downward
            if (by >= 0 && bvy >= 0) {
              setCardOffset(el, 0, 0);
              setCardScale(el, 1);
              el.classList.remove("springing");
              springRaf = null;
              return;
            }

            setCardOffset(el, 0, by);
            setCardScale(el, 1);
            springRaf = requestAnimationFrame(bounceStep);
          };
          springRaf = requestAnimationFrame(bounceStep);
          return;
        } else {
          // Impact too soft, just stop
          setCardOffset(el, 0, 0);
          setCardScale(el, 1);
          el.classList.remove("springing");
          springRaf = null;
          return;
        }
      }

      setCardOffset(el, x, y);
      // Scale follows ease-in curve (accelerating shrink)
      const scaleT = clamp(1 - Math.exp(-8 * tAcc), 0, 1);
      const s = 1 + (sStart - 1) * (1 - easeInPow(scaleT, 2.0));
      setCardScale(el, s);

      // Check if settled near origin with low velocity
      const settled = Math.hypot(x, y) < 0.5 && Math.hypot(vx, vy) < 18;
      if (settled) {
        setCardOffset(el, 0, 0);
        setCardScale(el, 1);
        el.classList.remove("springing");
        springRaf = null;
        return;
      }

      springRaf = requestAnimationFrame(step);
    };
    springRaf = requestAnimationFrame(step);
  }

  bottomHandEl.addEventListener("pointerdown", (e) => {
    if (isDealing) return;
    if (e.button != null && e.button !== 0) return;
    const target = e.target.closest(".faceCard");
    if (!target) return;
    cardPointerId = e.pointerId;
    cardEl = target;
    // Ensure snapback easing only applies on release (not during drag).
    cardEl.classList.remove("snapBack");
    cardEl.classList.remove("overshoot");
    cardEl.classList.remove("springing");
    stopSpring();
    cardLastX = e.clientX;
    cardLastY = e.clientY;
    cardLastT = performance.now();
    cardDx = 0;
    cardDy = 0;
    cardVx = 0;
    cardVy = 0;
    cardS = CARD_DRAG_SCALE_BASE;
    cardDragged = false;
    cardDownAt = Date.now();
    cardLocked = false;
    cardEl.classList.add("dragging");
    setCardOffset(cardEl, 0, 0);
    setCardScale(cardEl, cardS);
    try { cardEl.setPointerCapture(cardPointerId); } catch { /* ignore */ }
  });

  bottomHandEl.addEventListener("pointermove", (e) => {
    if (isDealing) return;
    if (cardPointerId == null || e.pointerId !== cardPointerId) return;
    if (!cardEl) return;
    if (cardLocked) return;
    const tNow = performance.now();
    const dt = clamp((tNow - cardLastT) / 1000, 0.001, 0.05);
    cardLastT = tNow;
    const ddx0 = e.clientX - cardLastX;
    const ddy0 = e.clientY - cardLastY;
    cardLastX = e.clientX;
    cardLastY = e.clientY;

    const prevDx = cardDx;
    const prevDy = cardDy;

    const oldFrac = dragFrac(cardDx, cardDy);
    const edgeFrac = edgeFracFromPointer(e.clientX, e.clientY);
    const oldCombined = combinedFrac(oldFrac, edgeFrac);
    const oldD = dampDriver(oldCombined);
    // Target offset if perfectly following the pointer
    let ddx = ddx0;
    let ddy = ddy0;
    let nextDx = cardDx + ddx;
    let nextDy = cardDy + ddy;
    // Apply "no downward" immediately for intent detection (downward movement shouldn't help push outward)
    if (nextDy > 0) nextDy = 0;
    let nextFrac = dragFrac(nextDx, nextDy);
    const nextCombined = combinedFrac(nextFrac, edgeFrac);
    const nextD = dampDriver(nextCombined);

    // Damping: apply whenever we are NOT moving inward (i.e., not getting farther from caps).
    // Joystick feel: resist radial (outward) motion much more than tangential (around-the-edge) motion.
    // This prevents the "pause / straight line" feel when sliding left/right at a given height.
    if (nextD >= oldD) {
      // Combined damping driver: either card approaching its drag caps, OR pointer approaching table edge.
      // When mouse reaches the table edge, edgeFrac -> 1 => strength -> 1 (max damping).
      const strength = easeOutPow(oldD, CARD_DRAG_DAMP_P);
      const radialGain = 1 - strength; // strongest resistance
      // Tangential (left/right) should remain smooth, but when pulled upward "high enough",
      // increase tangential damping so the arc stays small (avoid the "can draw a circle" feel).
      let tanGain = 1 - strength * 0.35; // base tangential damping near edge

      // Work in normalized ellipse-space so the boundary is a circle:
      // vx = dx/CAP_X, vy = (-dy)/CAP_UP
      const capX = CARD_DRAG_CAP_X_PX;
      const capY = CARD_DRAG_CAP_UP_PX;
      if (capX > 0 && capY > 0) {
        const ux0 = cardDx / capX;
        const uy0 = Math.max(0, -cardDy) / capY;
        const un = Math.hypot(ux0, uy0);
        if (un > 1e-4) {
          const ux = ux0 / un;
          const uy = uy0 / un;

          // Height-dependent tangential damping:
          // - below ~35% upward pull: almost unchanged
          // - above that: tangential gets increasingly "sticky" so sliding left/right produces only a small arc
          const upFrac = clamp(uy0, 0, 1); // 0..1 upward fraction
          const tUp = clamp((upFrac - 0.35) / (1 - 0.35), 0, 1);
          // Up to ~55% additional tangential damping at max upward pull.
          tanGain *= 1 - 0.55 * tUp;

          let dvx = ddx0 / capX;
          let dvy = -ddy0 / capY;

          // Decompose dv into radial/tangential components.
          const dr = dvx * ux + dvy * uy;
          const tvx = dvx - dr * ux;
          const tvy = dvy - dr * uy;

          // Only resist radial-outward component (dr > 0). Inward dr stays responsive.
          const dr2 = dr > 0 ? dr * radialGain : dr;
          dvx = dr2 * ux + tvx * tanGain;
          dvy = dr2 * uy + tvy * tanGain;

          ddx = dvx * capX;
          ddy = -dvy * capY;
        } else {
          // Near origin: fall back to uniform damping.
          const gain = 1 - strength;
          ddx = ddx0 * gain;
          ddy = ddy0 * gain;
        }
      } else {
        const gain = 1 - strength;
        ddx = ddx0 * gain;
        ddy = ddy0 * gain;
      }

      nextDx = cardDx + ddx;
      nextDy = cardDy + ddy;
      if (nextDy > 0) nextDy = 0;
      nextFrac = dragFrac(nextDx, nextDy);
    }

    // Clamp to a smooth arc (ellipse). Do NOT lock; keep motion continuous along the boundary (no "pause").
    const proj = projectToDragRegion(nextDx, nextDy);
    nextDx = proj.dx;
    nextDy = proj.dy;

    cardDx = nextDx;
    cardDy = nextDy;

    // Scale follows the same ease-out "damping strength" rhythm.
    const curFrac = dragFrac(cardDx, cardDy);
    const curCombined = combinedFrac(curFrac, edgeFrac);
    const curD = dampDriver(curCombined);
    const curStrength = easeOutPow(curD, CARD_DRAG_DAMP_P);
    cardS = CARD_DRAG_SCALE_BASE + CARD_DRAG_SCALE_EXTRA * curStrength;

    // Velocity estimate (for physical release). Smooth a bit to reduce noise.
    const instVx = (cardDx - prevDx) / dt;
    const instVy = (cardDy - prevDy) / dt;
    cardVx = cardVx * 0.65 + instVx * 0.35;
    cardVy = cardVy * 0.65 + instVy * 0.35;

    if (!cardDragged) {
      const moved = Math.hypot(cardDx, cardDy) > 6 && Date.now() - cardDownAt > 40;
      if (moved) cardDragged = true;
    }
    setCardOffset(cardEl, cardDx, cardDy);
    setCardScale(cardEl, cardS);
  });

  function endCardPointer(e) {
    if (cardPointerId == null || e.pointerId !== cardPointerId) return;
    const el = cardEl;
    const lastDx = cardDx;
    const lastDy = cardDy;
    const lastVx = cardVx;
    const lastVy = cardVy;
    const lastS = cardS;
    const dragDist = Math.hypot(lastDx, lastDy);
    cardPointerId = null;
    cardEl = null;

    if (el) {
      el.classList.remove("dragging");
      // Only spring back if we actually dragged (or moved meaningfully).
      const moved = Math.hypot(lastDx, lastDy) > 1.5 || cardDragged;
      if (moved) {
        startSpringBack(el, lastDx, lastDy, lastVx, lastVy, lastS);
      } else {
        // No movement: don't run spring animation (prevents "return then pop" on click).
        setCardOffset(el, 0, 0);
        setCardScale(el, 1);
        el.classList.remove("springing");
        el.classList.remove("overshoot");
      }
      try { el.releasePointerCapture(e.pointerId); } catch { /* ignore */ }
    }
    // If it was a drag, suppress click selection.
    if (cardDragged) suppressHandClickUntil = Date.now() + 220;

    cardDragged = false;
    cardLocked = false;
    cardVx = 0;
    cardVy = 0;
    cardS = 1;
  }
  bottomHandEl.addEventListener("pointerup", endCardPointer);
  bottomHandEl.addEventListener("pointercancel", endCardPointer);

  // Click your cards to select (on table)
  bottomHandEl.addEventListener("click", (e) => {
    if (isDealing) return;
    if (Date.now() < suppressHandClickUntil) return;
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;
    const c = e.target.closest(".faceCard");
    if (!c) return;
    const id = c.dataset.cardId;
    if (!id) return;
    markHumanAction();
    if (selected.includes(id)) selected = selected.filter((x) => x !== id);
    else selected = selected.length >= 2 ? [selected[1], id] : [...selected, id];
    renderSelectionHighlights();
    syncSelectionUi();
  });

  // UI image buttons
  // Prevent image/element drag (fixes mobile/desktop "can drag" and hit-testing weirdness)
  for (const el of [btnHintImg, btnMatchImg, btnEndTurnImg]) {
    el.addEventListener("dragstart", (e) => e.preventDefault());
    const img = el.querySelector("img");
    if (img) img.addEventListener("dragstart", (e) => e.preventDefault());
  }

  // Prevent native HTML drag on card images (otherwise non-joker image cards may bypass our 50px lift cap).
  bottomHandEl.addEventListener(
    "dragstart",
    (e) => {
      const t = e.target;
      if (t && t.closest && t.closest(".faceCard")) e.preventDefault();
    },
    { capture: true }
  );

  btnHintImg.addEventListener("click", () => {
    if (isDealing) return;
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.kind !== "human") return;
    markHumanAction();

    // Toggle hint: if already showing hint (2 cards selected), clear them; otherwise show hint
    if (selected.length === 2) {
      // Check if the current selection is a valid pair (hint result)
      const pair = window.Game.findAnyPairInHand(game.players[0].hand);
      const isHintPair = pair &&
        ((selected[0] === pair[0].id && selected[1] === pair[1].id) ||
         (selected[0] === pair[1].id && selected[1] === pair[0].id));

      if (isHintPair) {
        // Clear hint: deselect cards and return them to original position
        clearSelection();
        return;
      }
    }

    // Show hint: select the matching pair
    maybeShowHint();
  });

  btnMatchImg.addEventListener("click", () => {
    if (isDealing) return;
    // same as "åŒ¹é…å‡ºç‰Œ"
    btnTryMatch.click();
  });

  btnEndTurnImg.addEventListener("click", () => {
    if (isDealing) return;
    btnEndTurn.click();
  });

  // è®°å½•å½“å‰æ­£åœ¨è¿›è¡ŒåŠ¨ç”»çš„æ‰‹ç‰ŒåŒºåŸŸ
  let activeHandElement = null;

  // Click upstream backs to draw
  document.addEventListener("pointerdown", (e) => {
    const b = e.target.closest(".seatHand[data-from-player-index]");
    if (!b) return;
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (current.kind !== "human") return;
    const fromIdx = Number(b.dataset.fromPlayerIndex);
    markHumanAction();

    // è®°å½•å½“å‰ç‚¹å‡»çš„å…ƒç´ 
    activeHandElement = b;

    // ç«‹å³ä¿å­˜ fromIdxï¼Œé˜²æ­¢å¿«é€Ÿæ¾æ‰‹æ—¶è·å–ä¸åˆ°
    b.dataset.pendingFromIdx = String(fromIdx);

    // è§¦å‘ç”©å¡åŠ¨ç”»ï¼ˆé¼ æ ‡æŒ‰ä¸‹ç¬é—´è§¦å‘ï¼‰
    animateUpstreamRotateAndOpen(fromIdx);
  });

  // ç›‘å¬ pointerup äº‹ä»¶ï¼Œæ¾æ‰‹æ—¶æ˜¾ç¤ºèƒŒæ™¯å’Œæ‰“å¼€æŠ½ç‰Œç•Œé¢
  document.addEventListener("pointerup", () => {
    // æ£€æŸ¥æ˜¯å¦æœ‰æ´»è·ƒçš„æ‰‹ç‰ŒåŒºåŸŸ
    if (!activeHandElement) return;

    const b = activeHandElement;
    const fromIdx = Number(b.dataset.pendingFromIdx);

    // å®šä¹‰æ‰§è¡ŒåŠ¨ç”»çš„å‡½æ•°
    const executeAnimation = () => {
      // æ¸…é™¤æ ‡è®°å’Œæ´»è·ƒå…ƒç´ 
      b.dataset.animationComplete = "";
      b.dataset.pendingFromIdx = "";
      activeHandElement = null; // é‡ç½®æ´»è·ƒå…ƒç´ 

      // â­ æ¾æ‰‹æ—¶ç«‹å³éšè—ä¸Šå®¶æ‰€æœ‰æ‰‹ç‰Œå¹¶ç«‹å³æ‰“å¼€æŠ½ç‰Œç•Œé¢
      const backs = Array.from(b.querySelectorAll(".miniBack"));
      backs.forEach(card => {
        card.style.opacity = '0';
        card.style.transition = 'opacity 150ms ease-out';
      });

      // ğŸ”§ ç«‹å³æ‰“å¼€æŠ½ç‰Œç•Œé¢ï¼Œä¸æ‰‹ç‰Œæ·¡å‡ºåŒæ—¶è¿›è¡Œ
      console.log('[ç©ä¸Šâ†’æŠ½1] æ¾æ‰‹ï¼Œéšè—æ‰‹ç‰Œå¹¶ç«‹å³æ‰“å¼€æŠ½ç‰Œç•Œé¢');
      openDrawOverlay(fromIdx);

    }; // executeAnimation å‡½æ•°ç»“æŸ

    // æ£€æŸ¥åŠ¨ç”»æ˜¯å¦å®Œæˆï¼Œå¦‚æœå®Œæˆåˆ™ç«‹å³æ‰§è¡Œï¼Œå¦åˆ™ç­‰å¾…
    if (b.dataset.animationComplete === "true") {
      executeAnimation();
    } else {
      // ç­‰å¾…åŠ¨ç”»å®Œæˆï¼ˆæœ€å¤šç­‰å¾…100msï¼‰
      const checkInterval = setInterval(() => {
        if (b.dataset.animationComplete === "true") {
          clearInterval(checkInterval);
          executeAnimation();
        }
      }, 10);

      // 100ms åå¼ºåˆ¶æ‰§è¡Œ
      setTimeout(() => {
        clearInterval(checkInterval);
        if (activeHandElement === b) {
          executeAnimation();
        }
      }, 100);
    }
  });

  btnTryMatch.addEventListener("click", () => {
    if (!game || game.gameOver) return;
    advancePastOutPlayers();
    const current = game.players[game.currentPlayerIndex];
    if (!current || current.out || current.kind !== "human") return;
    if (selected.length !== 2) return;
    markHumanAction();
    const [a, b] = selected;

    // Animate the two selected cards to discard pile if it matches.
    const aEl = $("#pBottomHand").querySelector(`.faceCard[data-card-id="${CSS.escape(a)}"]`);
    const bEl = $("#pBottomHand").querySelector(`.faceCard[data-card-id="${CSS.escape(b)}"]`);
    const res = window.Game.tryDiscardPairByCardIds(game, 0, a, b);
    if (res.ok) {
      const bottomHandEl = $("#pBottomHand");

      // è·å–æ‰€æœ‰å‰©ä½™æ‰‹ç‰Œï¼ˆä¸åŒ…æ‹¬å³å°†é£èµ°çš„ä¸¤å¼ ï¼‰
      const allCards = Array.from(bottomHandEl.querySelectorAll(".faceCard"));
      const remainingCards = allCards.filter(el => el !== aEl && el !== bEl);

      // æ ‡è®°æ‰‹ç‰ŒåŒºåŸŸæ­£åœ¨åšè‡ªé€‚åº”åŠ¨ç”»
      bottomHandEl.dataset.adjusting = "true";

      // è®¡ç®—æ–°çš„å¸ƒå±€ä½ç½®ï¼ˆæ‰‹ç‰Œæ•°é‡å‡2ï¼‰
      const newN = remainingCards.length;
      const newCenter = (newN - 1) / 2;
      const maxFanWidth = 920;
      const newSpread = Math.min(62, maxFanWidth / Math.max(1, newN - 1));

      // ç«‹å³ä¸ºå‰©ä½™æ‰‹ç‰Œæ·»åŠ transitionï¼Œå¹¶æ›´æ–°å®ƒä»¬çš„ä½ç½®ï¼ˆå¡«è¡¥ç©ºç¼ºï¼‰
      remainingCards.forEach((card, newIdx) => {
        const newD = newIdx - newCenter;
        const newX = newD * newSpread;
        const newRot = newD * 0.9;
        const newY = Math.abs(newD) * 0.8;

        // æ·»åŠ å¹³æ»‘è¿‡æ¸¡
        card.style.transition = "transform 420ms cubic-bezier(0.22, 1, 0.36, 1)";

        // ä½¿ç”¨ requestAnimationFrame ç¡®ä¿transitionç”Ÿæ•ˆ
        requestAnimationFrame(() => {
          card.style.setProperty("--x", `${newX}px`);
          card.style.setProperty("--rot", `${newRot}deg`);
          card.style.setProperty("--y", `${newY}px`);
        });
      });

      // å¯åŠ¨å‡ºç‰Œé£è¡ŒåŠ¨ç”»ï¼ˆåŒæ—¶è¿›è¡Œï¼‰
      if (aEl) flyToDiscard(aEl);
      if (bEl) flyToDiscard(bEl);

      // ç­‰å¾…è‡ªé€‚åº”åŠ¨ç”»å®Œæˆåï¼Œæ¸…é™¤æ ‡è®°å¹¶é‡æ–°æ¸²æŸ“ï¼ˆæ¸…ç†transitionç­‰ï¼‰
      setTimeout(() => {
        bottomHandEl.dataset.adjusting = "";
        renderSeats(game);
        renderDiscardPile(game);
        renderAction(game, settings);
        showLastEvent(game, settings);
      }, 500); // ç•¥é•¿äºè‡ªé€‚åº”åŠ¨ç”»æ—¶é•¿ï¼ˆ420msï¼‰

      clearSelection();
    } else {
      // é…å¯¹å¤±è´¥ï¼Œæ­£å¸¸æ›´æ–°
      renderAll(game, settings);
    }
    // If the human just went out, immediately pass the turn.
    if (!game.gameOver && game.players[game.currentPlayerIndex]?.out) {
      closeDrawOverlay();
      window.Game.advanceTurn(game);
      renderAll(game, settings);
      runAiLoop(game, settings);
    }
  });

  btnClearSelect.addEventListener("click", () => {
    markHumanAction();
    clearSelection();
  });

  btnEndTurn.addEventListener("click", () => {
    if (!game || game.gameOver) return;
    const current = game.players[game.currentPlayerIndex];
    if (current.kind !== "human") return;
    const upstreamIdx = window.Game.getUpstreamPlayerIndex(game);
    const canDrawUpstream = window.Game.canDrawFrom(game, upstreamIdx);
    if (!game.turnHasDrawn && canDrawUpstream) return;
    markHumanAction();
    clearSelection();
    closeDrawOverlay();
    window.Game.advanceTurn(game);
    renderAll(game, settings);
    runAiLoop(game, settings);
  });

  syncSettings();

  // When AI advances and it becomes the human's turn, start the 8s timer baseline.
  const _renderAll = renderAll;
  renderAll = function patchedRenderAll(g, s) {
    _renderAll(g, s);
    if (!g) return;
    if (g.gameOver) {
      window.clearTimeout(hintT);
      hintT = null;
      window.clearTimeout(hintHandT);
      hintHandT = null;
      window.clearTimeout(runAiLoop._t);
      runAiLoop._t = null;
      clearHintHighlight();
      clearHintHand();

      const loser = window.Game.findJokerHolder(g.players);
      const youLose = loser && loser.id === g.players[0].id;
      const currentLevel = window.__GAME_ROUND_TRACKER__.currentLevel;

      // æ˜¾ç¤ºå…³å¡ç»“æœ
      if (youLose) {
        endTitle.textContent = `ç¬¬${currentLevel}å…³å¤±è´¥`;
        endSubtitle.textContent = `ä½ æ‰‹é‡Œç•™ç€"ç‹å…«ç‰Œ"ï¼`;
        $("#btnNextLevel").style.display = "none";
      } else {
        endTitle.textContent = `ğŸ‰ ç¬¬${currentLevel}å…³é€šè¿‡ï¼`;
        endSubtitle.textContent = loser ? `${loser.name} æ‹¿ç€ç‹å…«ç‰Œã€‚` : "æ­å–œè¿‡å…³ï¼";

        // å¦‚æœä¸æ˜¯ç¬¬ä¸‰å…³ï¼Œæ˜¾ç¤º"è¿›å…¥ä¸‹ä¸€å…³"æŒ‰é’®
        if (currentLevel < 3) {
          $("#btnNextLevel").style.display = "block";
          $("#btnPlayAgain").textContent = "é‡æ–°æŒ‘æˆ˜æœ¬å…³";
        } else {
          $("#btnNextLevel").style.display = "none";
          $("#btnPlayAgain").textContent = "é‡æ–°æŒ‘æˆ˜";
          endSubtitle.textContent = "ğŸŠ æ­å–œé€šå…³å…¨éƒ¨ä¸‰å…³ï¼";
        }
      }

      endOverlay.classList.remove("hidden");
      return;
    }
    const pid = g.players[g.currentPlayerIndex]?.id || null;
    if (pid !== lastTurnPlayerId) {
      lastTurnPlayerId = pid;
      if (g.players[g.currentPlayerIndex]?.kind === "human") {
        markHumanAction();
      } else {
        // not human turn: stop hints
        window.clearTimeout(hintT);
        hintT = null;
        window.clearTimeout(hintHandT);
        hintHandT = null;
        clearHintHighlight();
        clearHintHand();
        // ensure AI loop always starts when it's AI's turn (prevents "stuck after end turn")
        if (s.aiPaceMs < 1e6) {
          try {
            runAiLoop(g, s);
          } catch {
            // ignore
          }
        }
      }
    } else {
      // same turn: only schedule hints if it's human's turn
      // (avoid interfering with AI actions or player's existing hints)
      if (g.players[g.currentPlayerIndex]?.kind === "human") {
        scheduleHintFromNow();
      }
    }
  };
}

window.initUi = initUi;

